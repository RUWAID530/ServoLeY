
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model admin_actions
 * 
 */
export type admin_actions = $Result.DefaultSelection<Prisma.$admin_actionsPayload>
/**
 * Model call_logs
 * 
 */
export type call_logs = $Result.DefaultSelection<Prisma.$call_logsPayload>
/**
 * Model call_sessions
 * 
 */
export type call_sessions = $Result.DefaultSelection<Prisma.$call_sessionsPayload>
/**
 * Model faqs
 * 
 */
export type faqs = $Result.DefaultSelection<Prisma.$faqsPayload>
/**
 * Model messages
 * 
 */
export type messages = $Result.DefaultSelection<Prisma.$messagesPayload>
/**
 * Model notification_preferences
 * 
 */
export type notification_preferences = $Result.DefaultSelection<Prisma.$notification_preferencesPayload>
/**
 * Model notification_tokens
 * 
 */
export type notification_tokens = $Result.DefaultSelection<Prisma.$notification_tokensPayload>
/**
 * Model notifications
 * 
 */
export type notifications = $Result.DefaultSelection<Prisma.$notificationsPayload>
/**
 * Model orders
 * 
 */
export type orders = $Result.DefaultSelection<Prisma.$ordersPayload>
/**
 * Model otps
 * 
 */
export type otps = $Result.DefaultSelection<Prisma.$otpsPayload>
/**
 * Model payment_orders
 * 
 */
export type payment_orders = $Result.DefaultSelection<Prisma.$payment_ordersPayload>
/**
 * Model profiles
 * 
 */
export type profiles = $Result.DefaultSelection<Prisma.$profilesPayload>
/**
 * Model provider_locations
 * 
 */
export type provider_locations = $Result.DefaultSelection<Prisma.$provider_locationsPayload>
/**
 * Model providers
 * 
 */
export type providers = $Result.DefaultSelection<Prisma.$providersPayload>
/**
 * Model report_schedules
 * 
 */
export type report_schedules = $Result.DefaultSelection<Prisma.$report_schedulesPayload>
/**
 * Model reviews
 * 
 */
export type reviews = $Result.DefaultSelection<Prisma.$reviewsPayload>
/**
 * Model services
 * 
 */
export type services = $Result.DefaultSelection<Prisma.$servicesPayload>
/**
 * Model tickets
 * 
 */
export type tickets = $Result.DefaultSelection<Prisma.$ticketsPayload>
/**
 * Model transactions
 * 
 */
export type transactions = $Result.DefaultSelection<Prisma.$transactionsPayload>
/**
 * Model user_payment_methods
 * 
 */
export type user_payment_methods = $Result.DefaultSelection<Prisma.$user_payment_methodsPayload>
/**
 * Model user_verifications
 * 
 */
export type user_verifications = $Result.DefaultSelection<Prisma.$user_verificationsPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model virtual_assignments
 * 
 */
export type virtual_assignments = $Result.DefaultSelection<Prisma.$virtual_assignmentsPayload>
/**
 * Model virtual_numbers
 * 
 */
export type virtual_numbers = $Result.DefaultSelection<Prisma.$virtual_numbersPayload>
/**
 * Model wallets
 * 
 */
export type wallets = $Result.DefaultSelection<Prisma.$walletsPayload>
/**
 * Model zones
 * 
 */
export type zones = $Result.DefaultSelection<Prisma.$zonesPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const OrderStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  REJECTED: 'REJECTED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const PaymentMethod: {
  UPI: 'UPI',
  CARD: 'CARD',
  NET_BANKING: 'NET_BANKING',
  WALLET: 'WALLET'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const ProviderType: {
  FREELANCER: 'FREELANCER',
  STORE: 'STORE'
};

export type ProviderType = (typeof ProviderType)[keyof typeof ProviderType]


export const TransactionType: {
  CREDIT: 'CREDIT',
  DEBIT: 'DEBIT',
  REFUND: 'REFUND',
  COMMISSION: 'COMMISSION',
  WITHDRAWAL: 'WITHDRAWAL'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const UserType: {
  CUSTOMER: 'CUSTOMER',
  PROVIDER: 'PROVIDER',
  ADMIN: 'ADMIN'
};

export type UserType = (typeof UserType)[keyof typeof UserType]

}

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type ProviderType = $Enums.ProviderType

export const ProviderType: typeof $Enums.ProviderType

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type UserType = $Enums.UserType

export const UserType: typeof $Enums.UserType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Admin_actions
 * const admin_actions = await prisma.admin_actions.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Admin_actions
   * const admin_actions = await prisma.admin_actions.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.admin_actions`: Exposes CRUD operations for the **admin_actions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admin_actions
    * const admin_actions = await prisma.admin_actions.findMany()
    * ```
    */
  get admin_actions(): Prisma.admin_actionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.call_logs`: Exposes CRUD operations for the **call_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Call_logs
    * const call_logs = await prisma.call_logs.findMany()
    * ```
    */
  get call_logs(): Prisma.call_logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.call_sessions`: Exposes CRUD operations for the **call_sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Call_sessions
    * const call_sessions = await prisma.call_sessions.findMany()
    * ```
    */
  get call_sessions(): Prisma.call_sessionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.faqs`: Exposes CRUD operations for the **faqs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faqs
    * const faqs = await prisma.faqs.findMany()
    * ```
    */
  get faqs(): Prisma.faqsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messages`: Exposes CRUD operations for the **messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.messages.findMany()
    * ```
    */
  get messages(): Prisma.messagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification_preferences`: Exposes CRUD operations for the **notification_preferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notification_preferences
    * const notification_preferences = await prisma.notification_preferences.findMany()
    * ```
    */
  get notification_preferences(): Prisma.notification_preferencesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification_tokens`: Exposes CRUD operations for the **notification_tokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notification_tokens
    * const notification_tokens = await prisma.notification_tokens.findMany()
    * ```
    */
  get notification_tokens(): Prisma.notification_tokensDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.notificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orders`: Exposes CRUD operations for the **orders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.orders.findMany()
    * ```
    */
  get orders(): Prisma.ordersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.otps`: Exposes CRUD operations for the **otps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Otps
    * const otps = await prisma.otps.findMany()
    * ```
    */
  get otps(): Prisma.otpsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment_orders`: Exposes CRUD operations for the **payment_orders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payment_orders
    * const payment_orders = await prisma.payment_orders.findMany()
    * ```
    */
  get payment_orders(): Prisma.payment_ordersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profiles`: Exposes CRUD operations for the **profiles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profiles.findMany()
    * ```
    */
  get profiles(): Prisma.profilesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.provider_locations`: Exposes CRUD operations for the **provider_locations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Provider_locations
    * const provider_locations = await prisma.provider_locations.findMany()
    * ```
    */
  get provider_locations(): Prisma.provider_locationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.providers`: Exposes CRUD operations for the **providers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Providers
    * const providers = await prisma.providers.findMany()
    * ```
    */
  get providers(): Prisma.providersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.report_schedules`: Exposes CRUD operations for the **report_schedules** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Report_schedules
    * const report_schedules = await prisma.report_schedules.findMany()
    * ```
    */
  get report_schedules(): Prisma.report_schedulesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviews`: Exposes CRUD operations for the **reviews** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.reviews.findMany()
    * ```
    */
  get reviews(): Prisma.reviewsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.services`: Exposes CRUD operations for the **services** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.services.findMany()
    * ```
    */
  get services(): Prisma.servicesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tickets`: Exposes CRUD operations for the **tickets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.tickets.findMany()
    * ```
    */
  get tickets(): Prisma.ticketsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactions`: Exposes CRUD operations for the **transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transactions.findMany()
    * ```
    */
  get transactions(): Prisma.transactionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_payment_methods`: Exposes CRUD operations for the **user_payment_methods** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_payment_methods
    * const user_payment_methods = await prisma.user_payment_methods.findMany()
    * ```
    */
  get user_payment_methods(): Prisma.user_payment_methodsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_verifications`: Exposes CRUD operations for the **user_verifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_verifications
    * const user_verifications = await prisma.user_verifications.findMany()
    * ```
    */
  get user_verifications(): Prisma.user_verificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.virtual_assignments`: Exposes CRUD operations for the **virtual_assignments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Virtual_assignments
    * const virtual_assignments = await prisma.virtual_assignments.findMany()
    * ```
    */
  get virtual_assignments(): Prisma.virtual_assignmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.virtual_numbers`: Exposes CRUD operations for the **virtual_numbers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Virtual_numbers
    * const virtual_numbers = await prisma.virtual_numbers.findMany()
    * ```
    */
  get virtual_numbers(): Prisma.virtual_numbersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wallets`: Exposes CRUD operations for the **wallets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallets.findMany()
    * ```
    */
  get wallets(): Prisma.walletsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zones`: Exposes CRUD operations for the **zones** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Zones
    * const zones = await prisma.zones.findMany()
    * ```
    */
  get zones(): Prisma.zonesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    admin_actions: 'admin_actions',
    call_logs: 'call_logs',
    call_sessions: 'call_sessions',
    faqs: 'faqs',
    messages: 'messages',
    notification_preferences: 'notification_preferences',
    notification_tokens: 'notification_tokens',
    notifications: 'notifications',
    orders: 'orders',
    otps: 'otps',
    payment_orders: 'payment_orders',
    profiles: 'profiles',
    provider_locations: 'provider_locations',
    providers: 'providers',
    report_schedules: 'report_schedules',
    reviews: 'reviews',
    services: 'services',
    tickets: 'tickets',
    transactions: 'transactions',
    user_payment_methods: 'user_payment_methods',
    user_verifications: 'user_verifications',
    users: 'users',
    virtual_assignments: 'virtual_assignments',
    virtual_numbers: 'virtual_numbers',
    wallets: 'wallets',
    zones: 'zones'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "admin_actions" | "call_logs" | "call_sessions" | "faqs" | "messages" | "notification_preferences" | "notification_tokens" | "notifications" | "orders" | "otps" | "payment_orders" | "profiles" | "provider_locations" | "providers" | "report_schedules" | "reviews" | "services" | "tickets" | "transactions" | "user_payment_methods" | "user_verifications" | "users" | "virtual_assignments" | "virtual_numbers" | "wallets" | "zones"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      admin_actions: {
        payload: Prisma.$admin_actionsPayload<ExtArgs>
        fields: Prisma.admin_actionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.admin_actionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_actionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.admin_actionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_actionsPayload>
          }
          findFirst: {
            args: Prisma.admin_actionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_actionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.admin_actionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_actionsPayload>
          }
          findMany: {
            args: Prisma.admin_actionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_actionsPayload>[]
          }
          create: {
            args: Prisma.admin_actionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_actionsPayload>
          }
          createMany: {
            args: Prisma.admin_actionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.admin_actionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_actionsPayload>[]
          }
          delete: {
            args: Prisma.admin_actionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_actionsPayload>
          }
          update: {
            args: Prisma.admin_actionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_actionsPayload>
          }
          deleteMany: {
            args: Prisma.admin_actionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.admin_actionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.admin_actionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_actionsPayload>[]
          }
          upsert: {
            args: Prisma.admin_actionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_actionsPayload>
          }
          aggregate: {
            args: Prisma.Admin_actionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin_actions>
          }
          groupBy: {
            args: Prisma.admin_actionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Admin_actionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.admin_actionsCountArgs<ExtArgs>
            result: $Utils.Optional<Admin_actionsCountAggregateOutputType> | number
          }
        }
      }
      call_logs: {
        payload: Prisma.$call_logsPayload<ExtArgs>
        fields: Prisma.call_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.call_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$call_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.call_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$call_logsPayload>
          }
          findFirst: {
            args: Prisma.call_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$call_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.call_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$call_logsPayload>
          }
          findMany: {
            args: Prisma.call_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$call_logsPayload>[]
          }
          create: {
            args: Prisma.call_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$call_logsPayload>
          }
          createMany: {
            args: Prisma.call_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.call_logsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$call_logsPayload>[]
          }
          delete: {
            args: Prisma.call_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$call_logsPayload>
          }
          update: {
            args: Prisma.call_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$call_logsPayload>
          }
          deleteMany: {
            args: Prisma.call_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.call_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.call_logsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$call_logsPayload>[]
          }
          upsert: {
            args: Prisma.call_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$call_logsPayload>
          }
          aggregate: {
            args: Prisma.Call_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCall_logs>
          }
          groupBy: {
            args: Prisma.call_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Call_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.call_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Call_logsCountAggregateOutputType> | number
          }
        }
      }
      call_sessions: {
        payload: Prisma.$call_sessionsPayload<ExtArgs>
        fields: Prisma.call_sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.call_sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$call_sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.call_sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$call_sessionsPayload>
          }
          findFirst: {
            args: Prisma.call_sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$call_sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.call_sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$call_sessionsPayload>
          }
          findMany: {
            args: Prisma.call_sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$call_sessionsPayload>[]
          }
          create: {
            args: Prisma.call_sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$call_sessionsPayload>
          }
          createMany: {
            args: Prisma.call_sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.call_sessionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$call_sessionsPayload>[]
          }
          delete: {
            args: Prisma.call_sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$call_sessionsPayload>
          }
          update: {
            args: Prisma.call_sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$call_sessionsPayload>
          }
          deleteMany: {
            args: Prisma.call_sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.call_sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.call_sessionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$call_sessionsPayload>[]
          }
          upsert: {
            args: Prisma.call_sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$call_sessionsPayload>
          }
          aggregate: {
            args: Prisma.Call_sessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCall_sessions>
          }
          groupBy: {
            args: Prisma.call_sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Call_sessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.call_sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<Call_sessionsCountAggregateOutputType> | number
          }
        }
      }
      faqs: {
        payload: Prisma.$faqsPayload<ExtArgs>
        fields: Prisma.faqsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.faqsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.faqsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqsPayload>
          }
          findFirst: {
            args: Prisma.faqsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.faqsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqsPayload>
          }
          findMany: {
            args: Prisma.faqsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqsPayload>[]
          }
          create: {
            args: Prisma.faqsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqsPayload>
          }
          createMany: {
            args: Prisma.faqsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.faqsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqsPayload>[]
          }
          delete: {
            args: Prisma.faqsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqsPayload>
          }
          update: {
            args: Prisma.faqsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqsPayload>
          }
          deleteMany: {
            args: Prisma.faqsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.faqsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.faqsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqsPayload>[]
          }
          upsert: {
            args: Prisma.faqsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$faqsPayload>
          }
          aggregate: {
            args: Prisma.FaqsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFaqs>
          }
          groupBy: {
            args: Prisma.faqsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FaqsGroupByOutputType>[]
          }
          count: {
            args: Prisma.faqsCountArgs<ExtArgs>
            result: $Utils.Optional<FaqsCountAggregateOutputType> | number
          }
        }
      }
      messages: {
        payload: Prisma.$messagesPayload<ExtArgs>
        fields: Prisma.messagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.messagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.messagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          findFirst: {
            args: Prisma.messagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.messagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          findMany: {
            args: Prisma.messagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>[]
          }
          create: {
            args: Prisma.messagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          createMany: {
            args: Prisma.messagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.messagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>[]
          }
          delete: {
            args: Prisma.messagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          update: {
            args: Prisma.messagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          deleteMany: {
            args: Prisma.messagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.messagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.messagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>[]
          }
          upsert: {
            args: Prisma.messagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          aggregate: {
            args: Prisma.MessagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessages>
          }
          groupBy: {
            args: Prisma.messagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.messagesCountArgs<ExtArgs>
            result: $Utils.Optional<MessagesCountAggregateOutputType> | number
          }
        }
      }
      notification_preferences: {
        payload: Prisma.$notification_preferencesPayload<ExtArgs>
        fields: Prisma.notification_preferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notification_preferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_preferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notification_preferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_preferencesPayload>
          }
          findFirst: {
            args: Prisma.notification_preferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_preferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notification_preferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_preferencesPayload>
          }
          findMany: {
            args: Prisma.notification_preferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_preferencesPayload>[]
          }
          create: {
            args: Prisma.notification_preferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_preferencesPayload>
          }
          createMany: {
            args: Prisma.notification_preferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notification_preferencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_preferencesPayload>[]
          }
          delete: {
            args: Prisma.notification_preferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_preferencesPayload>
          }
          update: {
            args: Prisma.notification_preferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_preferencesPayload>
          }
          deleteMany: {
            args: Prisma.notification_preferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notification_preferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notification_preferencesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_preferencesPayload>[]
          }
          upsert: {
            args: Prisma.notification_preferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_preferencesPayload>
          }
          aggregate: {
            args: Prisma.Notification_preferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification_preferences>
          }
          groupBy: {
            args: Prisma.notification_preferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Notification_preferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.notification_preferencesCountArgs<ExtArgs>
            result: $Utils.Optional<Notification_preferencesCountAggregateOutputType> | number
          }
        }
      }
      notification_tokens: {
        payload: Prisma.$notification_tokensPayload<ExtArgs>
        fields: Prisma.notification_tokensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notification_tokensFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_tokensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notification_tokensFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_tokensPayload>
          }
          findFirst: {
            args: Prisma.notification_tokensFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_tokensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notification_tokensFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_tokensPayload>
          }
          findMany: {
            args: Prisma.notification_tokensFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_tokensPayload>[]
          }
          create: {
            args: Prisma.notification_tokensCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_tokensPayload>
          }
          createMany: {
            args: Prisma.notification_tokensCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notification_tokensCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_tokensPayload>[]
          }
          delete: {
            args: Prisma.notification_tokensDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_tokensPayload>
          }
          update: {
            args: Prisma.notification_tokensUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_tokensPayload>
          }
          deleteMany: {
            args: Prisma.notification_tokensDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notification_tokensUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notification_tokensUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_tokensPayload>[]
          }
          upsert: {
            args: Prisma.notification_tokensUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_tokensPayload>
          }
          aggregate: {
            args: Prisma.Notification_tokensAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification_tokens>
          }
          groupBy: {
            args: Prisma.notification_tokensGroupByArgs<ExtArgs>
            result: $Utils.Optional<Notification_tokensGroupByOutputType>[]
          }
          count: {
            args: Prisma.notification_tokensCountArgs<ExtArgs>
            result: $Utils.Optional<Notification_tokensCountAggregateOutputType> | number
          }
        }
      }
      notifications: {
        payload: Prisma.$notificationsPayload<ExtArgs>
        fields: Prisma.notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findFirst: {
            args: Prisma.notificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findMany: {
            args: Prisma.notificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          create: {
            args: Prisma.notificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          createMany: {
            args: Prisma.notificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          delete: {
            args: Prisma.notificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          update: {
            args: Prisma.notificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          deleteMany: {
            args: Prisma.notificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notificationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          upsert: {
            args: Prisma.notificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.notificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      orders: {
        payload: Prisma.$ordersPayload<ExtArgs>
        fields: Prisma.ordersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ordersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ordersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          findFirst: {
            args: Prisma.ordersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ordersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          findMany: {
            args: Prisma.ordersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>[]
          }
          create: {
            args: Prisma.ordersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          createMany: {
            args: Prisma.ordersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ordersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>[]
          }
          delete: {
            args: Prisma.ordersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          update: {
            args: Prisma.ordersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          deleteMany: {
            args: Prisma.ordersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ordersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ordersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>[]
          }
          upsert: {
            args: Prisma.ordersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          aggregate: {
            args: Prisma.OrdersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrders>
          }
          groupBy: {
            args: Prisma.ordersGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrdersGroupByOutputType>[]
          }
          count: {
            args: Prisma.ordersCountArgs<ExtArgs>
            result: $Utils.Optional<OrdersCountAggregateOutputType> | number
          }
        }
      }
      otps: {
        payload: Prisma.$otpsPayload<ExtArgs>
        fields: Prisma.otpsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.otpsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.otpsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpsPayload>
          }
          findFirst: {
            args: Prisma.otpsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.otpsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpsPayload>
          }
          findMany: {
            args: Prisma.otpsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpsPayload>[]
          }
          create: {
            args: Prisma.otpsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpsPayload>
          }
          createMany: {
            args: Prisma.otpsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.otpsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpsPayload>[]
          }
          delete: {
            args: Prisma.otpsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpsPayload>
          }
          update: {
            args: Prisma.otpsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpsPayload>
          }
          deleteMany: {
            args: Prisma.otpsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.otpsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.otpsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpsPayload>[]
          }
          upsert: {
            args: Prisma.otpsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpsPayload>
          }
          aggregate: {
            args: Prisma.OtpsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtps>
          }
          groupBy: {
            args: Prisma.otpsGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtpsGroupByOutputType>[]
          }
          count: {
            args: Prisma.otpsCountArgs<ExtArgs>
            result: $Utils.Optional<OtpsCountAggregateOutputType> | number
          }
        }
      }
      payment_orders: {
        payload: Prisma.$payment_ordersPayload<ExtArgs>
        fields: Prisma.payment_ordersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.payment_ordersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_ordersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.payment_ordersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_ordersPayload>
          }
          findFirst: {
            args: Prisma.payment_ordersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_ordersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.payment_ordersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_ordersPayload>
          }
          findMany: {
            args: Prisma.payment_ordersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_ordersPayload>[]
          }
          create: {
            args: Prisma.payment_ordersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_ordersPayload>
          }
          createMany: {
            args: Prisma.payment_ordersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.payment_ordersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_ordersPayload>[]
          }
          delete: {
            args: Prisma.payment_ordersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_ordersPayload>
          }
          update: {
            args: Prisma.payment_ordersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_ordersPayload>
          }
          deleteMany: {
            args: Prisma.payment_ordersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.payment_ordersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.payment_ordersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_ordersPayload>[]
          }
          upsert: {
            args: Prisma.payment_ordersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_ordersPayload>
          }
          aggregate: {
            args: Prisma.Payment_ordersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment_orders>
          }
          groupBy: {
            args: Prisma.payment_ordersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Payment_ordersGroupByOutputType>[]
          }
          count: {
            args: Prisma.payment_ordersCountArgs<ExtArgs>
            result: $Utils.Optional<Payment_ordersCountAggregateOutputType> | number
          }
        }
      }
      profiles: {
        payload: Prisma.$profilesPayload<ExtArgs>
        fields: Prisma.profilesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.profilesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.profilesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesPayload>
          }
          findFirst: {
            args: Prisma.profilesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.profilesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesPayload>
          }
          findMany: {
            args: Prisma.profilesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesPayload>[]
          }
          create: {
            args: Prisma.profilesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesPayload>
          }
          createMany: {
            args: Prisma.profilesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.profilesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesPayload>[]
          }
          delete: {
            args: Prisma.profilesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesPayload>
          }
          update: {
            args: Prisma.profilesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesPayload>
          }
          deleteMany: {
            args: Prisma.profilesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.profilesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.profilesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesPayload>[]
          }
          upsert: {
            args: Prisma.profilesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilesPayload>
          }
          aggregate: {
            args: Prisma.ProfilesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfiles>
          }
          groupBy: {
            args: Prisma.profilesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfilesGroupByOutputType>[]
          }
          count: {
            args: Prisma.profilesCountArgs<ExtArgs>
            result: $Utils.Optional<ProfilesCountAggregateOutputType> | number
          }
        }
      }
      provider_locations: {
        payload: Prisma.$provider_locationsPayload<ExtArgs>
        fields: Prisma.provider_locationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.provider_locationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_locationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.provider_locationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_locationsPayload>
          }
          findFirst: {
            args: Prisma.provider_locationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_locationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.provider_locationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_locationsPayload>
          }
          findMany: {
            args: Prisma.provider_locationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_locationsPayload>[]
          }
          create: {
            args: Prisma.provider_locationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_locationsPayload>
          }
          createMany: {
            args: Prisma.provider_locationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.provider_locationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_locationsPayload>[]
          }
          delete: {
            args: Prisma.provider_locationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_locationsPayload>
          }
          update: {
            args: Prisma.provider_locationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_locationsPayload>
          }
          deleteMany: {
            args: Prisma.provider_locationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.provider_locationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.provider_locationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_locationsPayload>[]
          }
          upsert: {
            args: Prisma.provider_locationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_locationsPayload>
          }
          aggregate: {
            args: Prisma.Provider_locationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProvider_locations>
          }
          groupBy: {
            args: Prisma.provider_locationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Provider_locationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.provider_locationsCountArgs<ExtArgs>
            result: $Utils.Optional<Provider_locationsCountAggregateOutputType> | number
          }
        }
      }
      providers: {
        payload: Prisma.$providersPayload<ExtArgs>
        fields: Prisma.providersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.providersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.providersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>
          }
          findFirst: {
            args: Prisma.providersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.providersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>
          }
          findMany: {
            args: Prisma.providersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>[]
          }
          create: {
            args: Prisma.providersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>
          }
          createMany: {
            args: Prisma.providersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.providersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>[]
          }
          delete: {
            args: Prisma.providersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>
          }
          update: {
            args: Prisma.providersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>
          }
          deleteMany: {
            args: Prisma.providersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.providersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.providersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>[]
          }
          upsert: {
            args: Prisma.providersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>
          }
          aggregate: {
            args: Prisma.ProvidersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProviders>
          }
          groupBy: {
            args: Prisma.providersGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProvidersGroupByOutputType>[]
          }
          count: {
            args: Prisma.providersCountArgs<ExtArgs>
            result: $Utils.Optional<ProvidersCountAggregateOutputType> | number
          }
        }
      }
      report_schedules: {
        payload: Prisma.$report_schedulesPayload<ExtArgs>
        fields: Prisma.report_schedulesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.report_schedulesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_schedulesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.report_schedulesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_schedulesPayload>
          }
          findFirst: {
            args: Prisma.report_schedulesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_schedulesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.report_schedulesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_schedulesPayload>
          }
          findMany: {
            args: Prisma.report_schedulesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_schedulesPayload>[]
          }
          create: {
            args: Prisma.report_schedulesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_schedulesPayload>
          }
          createMany: {
            args: Prisma.report_schedulesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.report_schedulesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_schedulesPayload>[]
          }
          delete: {
            args: Prisma.report_schedulesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_schedulesPayload>
          }
          update: {
            args: Prisma.report_schedulesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_schedulesPayload>
          }
          deleteMany: {
            args: Prisma.report_schedulesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.report_schedulesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.report_schedulesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_schedulesPayload>[]
          }
          upsert: {
            args: Prisma.report_schedulesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_schedulesPayload>
          }
          aggregate: {
            args: Prisma.Report_schedulesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport_schedules>
          }
          groupBy: {
            args: Prisma.report_schedulesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Report_schedulesGroupByOutputType>[]
          }
          count: {
            args: Prisma.report_schedulesCountArgs<ExtArgs>
            result: $Utils.Optional<Report_schedulesCountAggregateOutputType> | number
          }
        }
      }
      reviews: {
        payload: Prisma.$reviewsPayload<ExtArgs>
        fields: Prisma.reviewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reviewsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reviewsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          findFirst: {
            args: Prisma.reviewsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reviewsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          findMany: {
            args: Prisma.reviewsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>[]
          }
          create: {
            args: Prisma.reviewsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          createMany: {
            args: Prisma.reviewsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.reviewsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>[]
          }
          delete: {
            args: Prisma.reviewsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          update: {
            args: Prisma.reviewsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          deleteMany: {
            args: Prisma.reviewsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reviewsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.reviewsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>[]
          }
          upsert: {
            args: Prisma.reviewsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          aggregate: {
            args: Prisma.ReviewsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviews>
          }
          groupBy: {
            args: Prisma.reviewsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.reviewsCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewsCountAggregateOutputType> | number
          }
        }
      }
      services: {
        payload: Prisma.$servicesPayload<ExtArgs>
        fields: Prisma.servicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.servicesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.servicesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>
          }
          findFirst: {
            args: Prisma.servicesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.servicesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>
          }
          findMany: {
            args: Prisma.servicesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>[]
          }
          create: {
            args: Prisma.servicesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>
          }
          createMany: {
            args: Prisma.servicesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.servicesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>[]
          }
          delete: {
            args: Prisma.servicesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>
          }
          update: {
            args: Prisma.servicesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>
          }
          deleteMany: {
            args: Prisma.servicesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.servicesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.servicesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>[]
          }
          upsert: {
            args: Prisma.servicesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>
          }
          aggregate: {
            args: Prisma.ServicesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServices>
          }
          groupBy: {
            args: Prisma.servicesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.servicesCountArgs<ExtArgs>
            result: $Utils.Optional<ServicesCountAggregateOutputType> | number
          }
        }
      }
      tickets: {
        payload: Prisma.$ticketsPayload<ExtArgs>
        fields: Prisma.ticketsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ticketsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ticketsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketsPayload>
          }
          findFirst: {
            args: Prisma.ticketsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ticketsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketsPayload>
          }
          findMany: {
            args: Prisma.ticketsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketsPayload>[]
          }
          create: {
            args: Prisma.ticketsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketsPayload>
          }
          createMany: {
            args: Prisma.ticketsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ticketsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketsPayload>[]
          }
          delete: {
            args: Prisma.ticketsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketsPayload>
          }
          update: {
            args: Prisma.ticketsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketsPayload>
          }
          deleteMany: {
            args: Prisma.ticketsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ticketsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ticketsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketsPayload>[]
          }
          upsert: {
            args: Prisma.ticketsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketsPayload>
          }
          aggregate: {
            args: Prisma.TicketsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTickets>
          }
          groupBy: {
            args: Prisma.ticketsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ticketsCountArgs<ExtArgs>
            result: $Utils.Optional<TicketsCountAggregateOutputType> | number
          }
        }
      }
      transactions: {
        payload: Prisma.$transactionsPayload<ExtArgs>
        fields: Prisma.transactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          findFirst: {
            args: Prisma.transactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          findMany: {
            args: Prisma.transactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>[]
          }
          create: {
            args: Prisma.transactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          createMany: {
            args: Prisma.transactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.transactionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>[]
          }
          delete: {
            args: Prisma.transactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          update: {
            args: Prisma.transactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          deleteMany: {
            args: Prisma.transactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.transactionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>[]
          }
          upsert: {
            args: Prisma.transactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          aggregate: {
            args: Prisma.TransactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactions>
          }
          groupBy: {
            args: Prisma.transactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.transactionsCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionsCountAggregateOutputType> | number
          }
        }
      }
      user_payment_methods: {
        payload: Prisma.$user_payment_methodsPayload<ExtArgs>
        fields: Prisma.user_payment_methodsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_payment_methodsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_payment_methodsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>
          }
          findFirst: {
            args: Prisma.user_payment_methodsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_payment_methodsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>
          }
          findMany: {
            args: Prisma.user_payment_methodsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>[]
          }
          create: {
            args: Prisma.user_payment_methodsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>
          }
          createMany: {
            args: Prisma.user_payment_methodsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_payment_methodsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>[]
          }
          delete: {
            args: Prisma.user_payment_methodsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>
          }
          update: {
            args: Prisma.user_payment_methodsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>
          }
          deleteMany: {
            args: Prisma.user_payment_methodsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_payment_methodsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_payment_methodsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>[]
          }
          upsert: {
            args: Prisma.user_payment_methodsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_payment_methodsPayload>
          }
          aggregate: {
            args: Prisma.User_payment_methodsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_payment_methods>
          }
          groupBy: {
            args: Prisma.user_payment_methodsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_payment_methodsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_payment_methodsCountArgs<ExtArgs>
            result: $Utils.Optional<User_payment_methodsCountAggregateOutputType> | number
          }
        }
      }
      user_verifications: {
        payload: Prisma.$user_verificationsPayload<ExtArgs>
        fields: Prisma.user_verificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_verificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_verificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_verificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_verificationsPayload>
          }
          findFirst: {
            args: Prisma.user_verificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_verificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_verificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_verificationsPayload>
          }
          findMany: {
            args: Prisma.user_verificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_verificationsPayload>[]
          }
          create: {
            args: Prisma.user_verificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_verificationsPayload>
          }
          createMany: {
            args: Prisma.user_verificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_verificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_verificationsPayload>[]
          }
          delete: {
            args: Prisma.user_verificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_verificationsPayload>
          }
          update: {
            args: Prisma.user_verificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_verificationsPayload>
          }
          deleteMany: {
            args: Prisma.user_verificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_verificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_verificationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_verificationsPayload>[]
          }
          upsert: {
            args: Prisma.user_verificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_verificationsPayload>
          }
          aggregate: {
            args: Prisma.User_verificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_verifications>
          }
          groupBy: {
            args: Prisma.user_verificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_verificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_verificationsCountArgs<ExtArgs>
            result: $Utils.Optional<User_verificationsCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      virtual_assignments: {
        payload: Prisma.$virtual_assignmentsPayload<ExtArgs>
        fields: Prisma.virtual_assignmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.virtual_assignmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$virtual_assignmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.virtual_assignmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$virtual_assignmentsPayload>
          }
          findFirst: {
            args: Prisma.virtual_assignmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$virtual_assignmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.virtual_assignmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$virtual_assignmentsPayload>
          }
          findMany: {
            args: Prisma.virtual_assignmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$virtual_assignmentsPayload>[]
          }
          create: {
            args: Prisma.virtual_assignmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$virtual_assignmentsPayload>
          }
          createMany: {
            args: Prisma.virtual_assignmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.virtual_assignmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$virtual_assignmentsPayload>[]
          }
          delete: {
            args: Prisma.virtual_assignmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$virtual_assignmentsPayload>
          }
          update: {
            args: Prisma.virtual_assignmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$virtual_assignmentsPayload>
          }
          deleteMany: {
            args: Prisma.virtual_assignmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.virtual_assignmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.virtual_assignmentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$virtual_assignmentsPayload>[]
          }
          upsert: {
            args: Prisma.virtual_assignmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$virtual_assignmentsPayload>
          }
          aggregate: {
            args: Prisma.Virtual_assignmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVirtual_assignments>
          }
          groupBy: {
            args: Prisma.virtual_assignmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Virtual_assignmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.virtual_assignmentsCountArgs<ExtArgs>
            result: $Utils.Optional<Virtual_assignmentsCountAggregateOutputType> | number
          }
        }
      }
      virtual_numbers: {
        payload: Prisma.$virtual_numbersPayload<ExtArgs>
        fields: Prisma.virtual_numbersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.virtual_numbersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$virtual_numbersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.virtual_numbersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$virtual_numbersPayload>
          }
          findFirst: {
            args: Prisma.virtual_numbersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$virtual_numbersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.virtual_numbersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$virtual_numbersPayload>
          }
          findMany: {
            args: Prisma.virtual_numbersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$virtual_numbersPayload>[]
          }
          create: {
            args: Prisma.virtual_numbersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$virtual_numbersPayload>
          }
          createMany: {
            args: Prisma.virtual_numbersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.virtual_numbersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$virtual_numbersPayload>[]
          }
          delete: {
            args: Prisma.virtual_numbersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$virtual_numbersPayload>
          }
          update: {
            args: Prisma.virtual_numbersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$virtual_numbersPayload>
          }
          deleteMany: {
            args: Prisma.virtual_numbersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.virtual_numbersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.virtual_numbersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$virtual_numbersPayload>[]
          }
          upsert: {
            args: Prisma.virtual_numbersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$virtual_numbersPayload>
          }
          aggregate: {
            args: Prisma.Virtual_numbersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVirtual_numbers>
          }
          groupBy: {
            args: Prisma.virtual_numbersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Virtual_numbersGroupByOutputType>[]
          }
          count: {
            args: Prisma.virtual_numbersCountArgs<ExtArgs>
            result: $Utils.Optional<Virtual_numbersCountAggregateOutputType> | number
          }
        }
      }
      wallets: {
        payload: Prisma.$walletsPayload<ExtArgs>
        fields: Prisma.walletsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.walletsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.walletsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletsPayload>
          }
          findFirst: {
            args: Prisma.walletsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.walletsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletsPayload>
          }
          findMany: {
            args: Prisma.walletsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletsPayload>[]
          }
          create: {
            args: Prisma.walletsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletsPayload>
          }
          createMany: {
            args: Prisma.walletsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.walletsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletsPayload>[]
          }
          delete: {
            args: Prisma.walletsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletsPayload>
          }
          update: {
            args: Prisma.walletsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletsPayload>
          }
          deleteMany: {
            args: Prisma.walletsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.walletsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.walletsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletsPayload>[]
          }
          upsert: {
            args: Prisma.walletsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletsPayload>
          }
          aggregate: {
            args: Prisma.WalletsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallets>
          }
          groupBy: {
            args: Prisma.walletsGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletsGroupByOutputType>[]
          }
          count: {
            args: Prisma.walletsCountArgs<ExtArgs>
            result: $Utils.Optional<WalletsCountAggregateOutputType> | number
          }
        }
      }
      zones: {
        payload: Prisma.$zonesPayload<ExtArgs>
        fields: Prisma.zonesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.zonesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.zonesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonesPayload>
          }
          findFirst: {
            args: Prisma.zonesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.zonesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonesPayload>
          }
          findMany: {
            args: Prisma.zonesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonesPayload>[]
          }
          create: {
            args: Prisma.zonesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonesPayload>
          }
          createMany: {
            args: Prisma.zonesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.zonesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonesPayload>[]
          }
          delete: {
            args: Prisma.zonesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonesPayload>
          }
          update: {
            args: Prisma.zonesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonesPayload>
          }
          deleteMany: {
            args: Prisma.zonesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.zonesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.zonesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonesPayload>[]
          }
          upsert: {
            args: Prisma.zonesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonesPayload>
          }
          aggregate: {
            args: Prisma.ZonesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZones>
          }
          groupBy: {
            args: Prisma.zonesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZonesGroupByOutputType>[]
          }
          count: {
            args: Prisma.zonesCountArgs<ExtArgs>
            result: $Utils.Optional<ZonesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    admin_actions?: admin_actionsOmit
    call_logs?: call_logsOmit
    call_sessions?: call_sessionsOmit
    faqs?: faqsOmit
    messages?: messagesOmit
    notification_preferences?: notification_preferencesOmit
    notification_tokens?: notification_tokensOmit
    notifications?: notificationsOmit
    orders?: ordersOmit
    otps?: otpsOmit
    payment_orders?: payment_ordersOmit
    profiles?: profilesOmit
    provider_locations?: provider_locationsOmit
    providers?: providersOmit
    report_schedules?: report_schedulesOmit
    reviews?: reviewsOmit
    services?: servicesOmit
    tickets?: ticketsOmit
    transactions?: transactionsOmit
    user_payment_methods?: user_payment_methodsOmit
    user_verifications?: user_verificationsOmit
    users?: usersOmit
    virtual_assignments?: virtual_assignmentsOmit
    virtual_numbers?: virtual_numbersOmit
    wallets?: walletsOmit
    zones?: zonesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Call_sessionsCountOutputType
   */

  export type Call_sessionsCountOutputType = {
    call_logs: number
  }

  export type Call_sessionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    call_logs?: boolean | Call_sessionsCountOutputTypeCountCall_logsArgs
  }

  // Custom InputTypes
  /**
   * Call_sessionsCountOutputType without action
   */
  export type Call_sessionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Call_sessionsCountOutputType
     */
    select?: Call_sessionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Call_sessionsCountOutputType without action
   */
  export type Call_sessionsCountOutputTypeCountCall_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: call_logsWhereInput
  }


  /**
   * Count Type OrdersCountOutputType
   */

  export type OrdersCountOutputType = {
    call_sessions: number
  }

  export type OrdersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    call_sessions?: boolean | OrdersCountOutputTypeCountCall_sessionsArgs
  }

  // Custom InputTypes
  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdersCountOutputType
     */
    select?: OrdersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeCountCall_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: call_sessionsWhereInput
  }


  /**
   * Count Type ProvidersCountOutputType
   */

  export type ProvidersCountOutputType = {
    provider_locations: number
    reviews: number
    services: number
  }

  export type ProvidersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider_locations?: boolean | ProvidersCountOutputTypeCountProvider_locationsArgs
    reviews?: boolean | ProvidersCountOutputTypeCountReviewsArgs
    services?: boolean | ProvidersCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * ProvidersCountOutputType without action
   */
  export type ProvidersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvidersCountOutputType
     */
    select?: ProvidersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProvidersCountOutputType without action
   */
  export type ProvidersCountOutputTypeCountProvider_locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: provider_locationsWhereInput
  }

  /**
   * ProvidersCountOutputType without action
   */
  export type ProvidersCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewsWhereInput
  }

  /**
   * ProvidersCountOutputType without action
   */
  export type ProvidersCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: servicesWhereInput
  }


  /**
   * Count Type ServicesCountOutputType
   */

  export type ServicesCountOutputType = {
    orders: number
  }

  export type ServicesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | ServicesCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * ServicesCountOutputType without action
   */
  export type ServicesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesCountOutputType
     */
    select?: ServicesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServicesCountOutputType without action
   */
  export type ServicesCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ordersWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    admin_actions: number
    call_sessions_call_sessions_customerIdTousers: number
    call_sessions_call_sessions_providerIdTousers: number
    messages_messages_receiverIdTousers: number
    messages_messages_senderIdTousers: number
    notification_tokens: number
    notifications: number
    orders_orders_customerIdTousers: number
    orders_orders_providerIdTousers: number
    otps: number
    payment_orders: number
    report_schedules: number
    reviews_reviews_revieweeIdTousers: number
    reviews_reviews_reviewerIdTousers: number
    tickets: number
    user_payment_methods: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_actions?: boolean | UsersCountOutputTypeCountAdmin_actionsArgs
    call_sessions_call_sessions_customerIdTousers?: boolean | UsersCountOutputTypeCountCall_sessions_call_sessions_customerIdTousersArgs
    call_sessions_call_sessions_providerIdTousers?: boolean | UsersCountOutputTypeCountCall_sessions_call_sessions_providerIdTousersArgs
    messages_messages_receiverIdTousers?: boolean | UsersCountOutputTypeCountMessages_messages_receiverIdTousersArgs
    messages_messages_senderIdTousers?: boolean | UsersCountOutputTypeCountMessages_messages_senderIdTousersArgs
    notification_tokens?: boolean | UsersCountOutputTypeCountNotification_tokensArgs
    notifications?: boolean | UsersCountOutputTypeCountNotificationsArgs
    orders_orders_customerIdTousers?: boolean | UsersCountOutputTypeCountOrders_orders_customerIdTousersArgs
    orders_orders_providerIdTousers?: boolean | UsersCountOutputTypeCountOrders_orders_providerIdTousersArgs
    otps?: boolean | UsersCountOutputTypeCountOtpsArgs
    payment_orders?: boolean | UsersCountOutputTypeCountPayment_ordersArgs
    report_schedules?: boolean | UsersCountOutputTypeCountReport_schedulesArgs
    reviews_reviews_revieweeIdTousers?: boolean | UsersCountOutputTypeCountReviews_reviews_revieweeIdTousersArgs
    reviews_reviews_reviewerIdTousers?: boolean | UsersCountOutputTypeCountReviews_reviews_reviewerIdTousersArgs
    tickets?: boolean | UsersCountOutputTypeCountTicketsArgs
    user_payment_methods?: boolean | UsersCountOutputTypeCountUser_payment_methodsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAdmin_actionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: admin_actionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCall_sessions_call_sessions_customerIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: call_sessionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCall_sessions_call_sessions_providerIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: call_sessionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMessages_messages_receiverIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messagesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMessages_messages_senderIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messagesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotification_tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notification_tokensWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountOrders_orders_customerIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ordersWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountOrders_orders_providerIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ordersWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountOtpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: otpsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPayment_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_ordersWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountReport_schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: report_schedulesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountReviews_reviews_revieweeIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountReviews_reviews_reviewerIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ticketsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_payment_methodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_payment_methodsWhereInput
  }


  /**
   * Count Type Virtual_numbersCountOutputType
   */

  export type Virtual_numbersCountOutputType = {
    virtual_assignments: number
  }

  export type Virtual_numbersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    virtual_assignments?: boolean | Virtual_numbersCountOutputTypeCountVirtual_assignmentsArgs
  }

  // Custom InputTypes
  /**
   * Virtual_numbersCountOutputType without action
   */
  export type Virtual_numbersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Virtual_numbersCountOutputType
     */
    select?: Virtual_numbersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Virtual_numbersCountOutputType without action
   */
  export type Virtual_numbersCountOutputTypeCountVirtual_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: virtual_assignmentsWhereInput
  }


  /**
   * Count Type WalletsCountOutputType
   */

  export type WalletsCountOutputType = {
    transactions: number
  }

  export type WalletsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | WalletsCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * WalletsCountOutputType without action
   */
  export type WalletsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletsCountOutputType
     */
    select?: WalletsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WalletsCountOutputType without action
   */
  export type WalletsCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionsWhereInput
  }


  /**
   * Count Type ZonesCountOutputType
   */

  export type ZonesCountOutputType = {
    provider_locations: number
  }

  export type ZonesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider_locations?: boolean | ZonesCountOutputTypeCountProvider_locationsArgs
  }

  // Custom InputTypes
  /**
   * ZonesCountOutputType without action
   */
  export type ZonesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZonesCountOutputType
     */
    select?: ZonesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ZonesCountOutputType without action
   */
  export type ZonesCountOutputTypeCountProvider_locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: provider_locationsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model admin_actions
   */

  export type AggregateAdmin_actions = {
    _count: Admin_actionsCountAggregateOutputType | null
    _min: Admin_actionsMinAggregateOutputType | null
    _max: Admin_actionsMaxAggregateOutputType | null
  }

  export type Admin_actionsMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    action: string | null
    targetId: string | null
    createdAt: Date | null
  }

  export type Admin_actionsMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    action: string | null
    targetId: string | null
    createdAt: Date | null
  }

  export type Admin_actionsCountAggregateOutputType = {
    id: number
    adminId: number
    action: number
    targetId: number
    details: number
    createdAt: number
    _all: number
  }


  export type Admin_actionsMinAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    targetId?: true
    createdAt?: true
  }

  export type Admin_actionsMaxAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    targetId?: true
    createdAt?: true
  }

  export type Admin_actionsCountAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    targetId?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type Admin_actionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin_actions to aggregate.
     */
    where?: admin_actionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_actions to fetch.
     */
    orderBy?: admin_actionsOrderByWithRelationInput | admin_actionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: admin_actionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admin_actions
    **/
    _count?: true | Admin_actionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Admin_actionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Admin_actionsMaxAggregateInputType
  }

  export type GetAdmin_actionsAggregateType<T extends Admin_actionsAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin_actions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin_actions[P]>
      : GetScalarType<T[P], AggregateAdmin_actions[P]>
  }




  export type admin_actionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: admin_actionsWhereInput
    orderBy?: admin_actionsOrderByWithAggregationInput | admin_actionsOrderByWithAggregationInput[]
    by: Admin_actionsScalarFieldEnum[] | Admin_actionsScalarFieldEnum
    having?: admin_actionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Admin_actionsCountAggregateInputType | true
    _min?: Admin_actionsMinAggregateInputType
    _max?: Admin_actionsMaxAggregateInputType
  }

  export type Admin_actionsGroupByOutputType = {
    id: string
    adminId: string
    action: string
    targetId: string
    details: JsonValue | null
    createdAt: Date
    _count: Admin_actionsCountAggregateOutputType | null
    _min: Admin_actionsMinAggregateOutputType | null
    _max: Admin_actionsMaxAggregateOutputType | null
  }

  type GetAdmin_actionsGroupByPayload<T extends admin_actionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Admin_actionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Admin_actionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Admin_actionsGroupByOutputType[P]>
            : GetScalarType<T[P], Admin_actionsGroupByOutputType[P]>
        }
      >
    >


  export type admin_actionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    targetId?: boolean
    details?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin_actions"]>

  export type admin_actionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    targetId?: boolean
    details?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin_actions"]>

  export type admin_actionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    targetId?: boolean
    details?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin_actions"]>

  export type admin_actionsSelectScalar = {
    id?: boolean
    adminId?: boolean
    action?: boolean
    targetId?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type admin_actionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "action" | "targetId" | "details" | "createdAt", ExtArgs["result"]["admin_actions"]>
  export type admin_actionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type admin_actionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type admin_actionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $admin_actionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admin_actions"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      action: string
      targetId: string
      details: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["admin_actions"]>
    composites: {}
  }

  type admin_actionsGetPayload<S extends boolean | null | undefined | admin_actionsDefaultArgs> = $Result.GetResult<Prisma.$admin_actionsPayload, S>

  type admin_actionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<admin_actionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Admin_actionsCountAggregateInputType | true
    }

  export interface admin_actionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admin_actions'], meta: { name: 'admin_actions' } }
    /**
     * Find zero or one Admin_actions that matches the filter.
     * @param {admin_actionsFindUniqueArgs} args - Arguments to find a Admin_actions
     * @example
     * // Get one Admin_actions
     * const admin_actions = await prisma.admin_actions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends admin_actionsFindUniqueArgs>(args: SelectSubset<T, admin_actionsFindUniqueArgs<ExtArgs>>): Prisma__admin_actionsClient<$Result.GetResult<Prisma.$admin_actionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin_actions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {admin_actionsFindUniqueOrThrowArgs} args - Arguments to find a Admin_actions
     * @example
     * // Get one Admin_actions
     * const admin_actions = await prisma.admin_actions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends admin_actionsFindUniqueOrThrowArgs>(args: SelectSubset<T, admin_actionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__admin_actionsClient<$Result.GetResult<Prisma.$admin_actionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin_actions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_actionsFindFirstArgs} args - Arguments to find a Admin_actions
     * @example
     * // Get one Admin_actions
     * const admin_actions = await prisma.admin_actions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends admin_actionsFindFirstArgs>(args?: SelectSubset<T, admin_actionsFindFirstArgs<ExtArgs>>): Prisma__admin_actionsClient<$Result.GetResult<Prisma.$admin_actionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin_actions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_actionsFindFirstOrThrowArgs} args - Arguments to find a Admin_actions
     * @example
     * // Get one Admin_actions
     * const admin_actions = await prisma.admin_actions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends admin_actionsFindFirstOrThrowArgs>(args?: SelectSubset<T, admin_actionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__admin_actionsClient<$Result.GetResult<Prisma.$admin_actionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admin_actions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_actionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admin_actions
     * const admin_actions = await prisma.admin_actions.findMany()
     * 
     * // Get first 10 Admin_actions
     * const admin_actions = await prisma.admin_actions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admin_actionsWithIdOnly = await prisma.admin_actions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends admin_actionsFindManyArgs>(args?: SelectSubset<T, admin_actionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_actionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin_actions.
     * @param {admin_actionsCreateArgs} args - Arguments to create a Admin_actions.
     * @example
     * // Create one Admin_actions
     * const Admin_actions = await prisma.admin_actions.create({
     *   data: {
     *     // ... data to create a Admin_actions
     *   }
     * })
     * 
     */
    create<T extends admin_actionsCreateArgs>(args: SelectSubset<T, admin_actionsCreateArgs<ExtArgs>>): Prisma__admin_actionsClient<$Result.GetResult<Prisma.$admin_actionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admin_actions.
     * @param {admin_actionsCreateManyArgs} args - Arguments to create many Admin_actions.
     * @example
     * // Create many Admin_actions
     * const admin_actions = await prisma.admin_actions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends admin_actionsCreateManyArgs>(args?: SelectSubset<T, admin_actionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admin_actions and returns the data saved in the database.
     * @param {admin_actionsCreateManyAndReturnArgs} args - Arguments to create many Admin_actions.
     * @example
     * // Create many Admin_actions
     * const admin_actions = await prisma.admin_actions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admin_actions and only return the `id`
     * const admin_actionsWithIdOnly = await prisma.admin_actions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends admin_actionsCreateManyAndReturnArgs>(args?: SelectSubset<T, admin_actionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_actionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin_actions.
     * @param {admin_actionsDeleteArgs} args - Arguments to delete one Admin_actions.
     * @example
     * // Delete one Admin_actions
     * const Admin_actions = await prisma.admin_actions.delete({
     *   where: {
     *     // ... filter to delete one Admin_actions
     *   }
     * })
     * 
     */
    delete<T extends admin_actionsDeleteArgs>(args: SelectSubset<T, admin_actionsDeleteArgs<ExtArgs>>): Prisma__admin_actionsClient<$Result.GetResult<Prisma.$admin_actionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin_actions.
     * @param {admin_actionsUpdateArgs} args - Arguments to update one Admin_actions.
     * @example
     * // Update one Admin_actions
     * const admin_actions = await prisma.admin_actions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends admin_actionsUpdateArgs>(args: SelectSubset<T, admin_actionsUpdateArgs<ExtArgs>>): Prisma__admin_actionsClient<$Result.GetResult<Prisma.$admin_actionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admin_actions.
     * @param {admin_actionsDeleteManyArgs} args - Arguments to filter Admin_actions to delete.
     * @example
     * // Delete a few Admin_actions
     * const { count } = await prisma.admin_actions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends admin_actionsDeleteManyArgs>(args?: SelectSubset<T, admin_actionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admin_actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_actionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admin_actions
     * const admin_actions = await prisma.admin_actions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends admin_actionsUpdateManyArgs>(args: SelectSubset<T, admin_actionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admin_actions and returns the data updated in the database.
     * @param {admin_actionsUpdateManyAndReturnArgs} args - Arguments to update many Admin_actions.
     * @example
     * // Update many Admin_actions
     * const admin_actions = await prisma.admin_actions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admin_actions and only return the `id`
     * const admin_actionsWithIdOnly = await prisma.admin_actions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends admin_actionsUpdateManyAndReturnArgs>(args: SelectSubset<T, admin_actionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_actionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin_actions.
     * @param {admin_actionsUpsertArgs} args - Arguments to update or create a Admin_actions.
     * @example
     * // Update or create a Admin_actions
     * const admin_actions = await prisma.admin_actions.upsert({
     *   create: {
     *     // ... data to create a Admin_actions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin_actions we want to update
     *   }
     * })
     */
    upsert<T extends admin_actionsUpsertArgs>(args: SelectSubset<T, admin_actionsUpsertArgs<ExtArgs>>): Prisma__admin_actionsClient<$Result.GetResult<Prisma.$admin_actionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admin_actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_actionsCountArgs} args - Arguments to filter Admin_actions to count.
     * @example
     * // Count the number of Admin_actions
     * const count = await prisma.admin_actions.count({
     *   where: {
     *     // ... the filter for the Admin_actions we want to count
     *   }
     * })
    **/
    count<T extends admin_actionsCountArgs>(
      args?: Subset<T, admin_actionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Admin_actionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin_actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_actionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Admin_actionsAggregateArgs>(args: Subset<T, Admin_actionsAggregateArgs>): Prisma.PrismaPromise<GetAdmin_actionsAggregateType<T>>

    /**
     * Group by Admin_actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_actionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends admin_actionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: admin_actionsGroupByArgs['orderBy'] }
        : { orderBy?: admin_actionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, admin_actionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmin_actionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admin_actions model
   */
  readonly fields: admin_actionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admin_actions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__admin_actionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the admin_actions model
   */
  interface admin_actionsFieldRefs {
    readonly id: FieldRef<"admin_actions", 'String'>
    readonly adminId: FieldRef<"admin_actions", 'String'>
    readonly action: FieldRef<"admin_actions", 'String'>
    readonly targetId: FieldRef<"admin_actions", 'String'>
    readonly details: FieldRef<"admin_actions", 'Json'>
    readonly createdAt: FieldRef<"admin_actions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * admin_actions findUnique
   */
  export type admin_actionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_actions
     */
    select?: admin_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_actions
     */
    omit?: admin_actionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_actionsInclude<ExtArgs> | null
    /**
     * Filter, which admin_actions to fetch.
     */
    where: admin_actionsWhereUniqueInput
  }

  /**
   * admin_actions findUniqueOrThrow
   */
  export type admin_actionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_actions
     */
    select?: admin_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_actions
     */
    omit?: admin_actionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_actionsInclude<ExtArgs> | null
    /**
     * Filter, which admin_actions to fetch.
     */
    where: admin_actionsWhereUniqueInput
  }

  /**
   * admin_actions findFirst
   */
  export type admin_actionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_actions
     */
    select?: admin_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_actions
     */
    omit?: admin_actionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_actionsInclude<ExtArgs> | null
    /**
     * Filter, which admin_actions to fetch.
     */
    where?: admin_actionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_actions to fetch.
     */
    orderBy?: admin_actionsOrderByWithRelationInput | admin_actionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admin_actions.
     */
    cursor?: admin_actionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admin_actions.
     */
    distinct?: Admin_actionsScalarFieldEnum | Admin_actionsScalarFieldEnum[]
  }

  /**
   * admin_actions findFirstOrThrow
   */
  export type admin_actionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_actions
     */
    select?: admin_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_actions
     */
    omit?: admin_actionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_actionsInclude<ExtArgs> | null
    /**
     * Filter, which admin_actions to fetch.
     */
    where?: admin_actionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_actions to fetch.
     */
    orderBy?: admin_actionsOrderByWithRelationInput | admin_actionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admin_actions.
     */
    cursor?: admin_actionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admin_actions.
     */
    distinct?: Admin_actionsScalarFieldEnum | Admin_actionsScalarFieldEnum[]
  }

  /**
   * admin_actions findMany
   */
  export type admin_actionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_actions
     */
    select?: admin_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_actions
     */
    omit?: admin_actionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_actionsInclude<ExtArgs> | null
    /**
     * Filter, which admin_actions to fetch.
     */
    where?: admin_actionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_actions to fetch.
     */
    orderBy?: admin_actionsOrderByWithRelationInput | admin_actionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admin_actions.
     */
    cursor?: admin_actionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_actions.
     */
    skip?: number
    distinct?: Admin_actionsScalarFieldEnum | Admin_actionsScalarFieldEnum[]
  }

  /**
   * admin_actions create
   */
  export type admin_actionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_actions
     */
    select?: admin_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_actions
     */
    omit?: admin_actionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_actionsInclude<ExtArgs> | null
    /**
     * The data needed to create a admin_actions.
     */
    data: XOR<admin_actionsCreateInput, admin_actionsUncheckedCreateInput>
  }

  /**
   * admin_actions createMany
   */
  export type admin_actionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admin_actions.
     */
    data: admin_actionsCreateManyInput | admin_actionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin_actions createManyAndReturn
   */
  export type admin_actionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_actions
     */
    select?: admin_actionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admin_actions
     */
    omit?: admin_actionsOmit<ExtArgs> | null
    /**
     * The data used to create many admin_actions.
     */
    data: admin_actionsCreateManyInput | admin_actionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_actionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * admin_actions update
   */
  export type admin_actionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_actions
     */
    select?: admin_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_actions
     */
    omit?: admin_actionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_actionsInclude<ExtArgs> | null
    /**
     * The data needed to update a admin_actions.
     */
    data: XOR<admin_actionsUpdateInput, admin_actionsUncheckedUpdateInput>
    /**
     * Choose, which admin_actions to update.
     */
    where: admin_actionsWhereUniqueInput
  }

  /**
   * admin_actions updateMany
   */
  export type admin_actionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admin_actions.
     */
    data: XOR<admin_actionsUpdateManyMutationInput, admin_actionsUncheckedUpdateManyInput>
    /**
     * Filter which admin_actions to update
     */
    where?: admin_actionsWhereInput
    /**
     * Limit how many admin_actions to update.
     */
    limit?: number
  }

  /**
   * admin_actions updateManyAndReturn
   */
  export type admin_actionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_actions
     */
    select?: admin_actionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admin_actions
     */
    omit?: admin_actionsOmit<ExtArgs> | null
    /**
     * The data used to update admin_actions.
     */
    data: XOR<admin_actionsUpdateManyMutationInput, admin_actionsUncheckedUpdateManyInput>
    /**
     * Filter which admin_actions to update
     */
    where?: admin_actionsWhereInput
    /**
     * Limit how many admin_actions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_actionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * admin_actions upsert
   */
  export type admin_actionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_actions
     */
    select?: admin_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_actions
     */
    omit?: admin_actionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_actionsInclude<ExtArgs> | null
    /**
     * The filter to search for the admin_actions to update in case it exists.
     */
    where: admin_actionsWhereUniqueInput
    /**
     * In case the admin_actions found by the `where` argument doesn't exist, create a new admin_actions with this data.
     */
    create: XOR<admin_actionsCreateInput, admin_actionsUncheckedCreateInput>
    /**
     * In case the admin_actions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<admin_actionsUpdateInput, admin_actionsUncheckedUpdateInput>
  }

  /**
   * admin_actions delete
   */
  export type admin_actionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_actions
     */
    select?: admin_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_actions
     */
    omit?: admin_actionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_actionsInclude<ExtArgs> | null
    /**
     * Filter which admin_actions to delete.
     */
    where: admin_actionsWhereUniqueInput
  }

  /**
   * admin_actions deleteMany
   */
  export type admin_actionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin_actions to delete
     */
    where?: admin_actionsWhereInput
    /**
     * Limit how many admin_actions to delete.
     */
    limit?: number
  }

  /**
   * admin_actions without action
   */
  export type admin_actionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_actions
     */
    select?: admin_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_actions
     */
    omit?: admin_actionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_actionsInclude<ExtArgs> | null
  }


  /**
   * Model call_logs
   */

  export type AggregateCall_logs = {
    _count: Call_logsCountAggregateOutputType | null
    _avg: Call_logsAvgAggregateOutputType | null
    _sum: Call_logsSumAggregateOutputType | null
    _min: Call_logsMinAggregateOutputType | null
    _max: Call_logsMaxAggregateOutputType | null
  }

  export type Call_logsAvgAggregateOutputType = {
    duration: number | null
  }

  export type Call_logsSumAggregateOutputType = {
    duration: number | null
  }

  export type Call_logsMinAggregateOutputType = {
    id: string | null
    callSessionId: string | null
    status: string | null
    duration: number | null
    timestamp: Date | null
  }

  export type Call_logsMaxAggregateOutputType = {
    id: string | null
    callSessionId: string | null
    status: string | null
    duration: number | null
    timestamp: Date | null
  }

  export type Call_logsCountAggregateOutputType = {
    id: number
    callSessionId: number
    status: number
    duration: number
    timestamp: number
    _all: number
  }


  export type Call_logsAvgAggregateInputType = {
    duration?: true
  }

  export type Call_logsSumAggregateInputType = {
    duration?: true
  }

  export type Call_logsMinAggregateInputType = {
    id?: true
    callSessionId?: true
    status?: true
    duration?: true
    timestamp?: true
  }

  export type Call_logsMaxAggregateInputType = {
    id?: true
    callSessionId?: true
    status?: true
    duration?: true
    timestamp?: true
  }

  export type Call_logsCountAggregateInputType = {
    id?: true
    callSessionId?: true
    status?: true
    duration?: true
    timestamp?: true
    _all?: true
  }

  export type Call_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which call_logs to aggregate.
     */
    where?: call_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of call_logs to fetch.
     */
    orderBy?: call_logsOrderByWithRelationInput | call_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: call_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` call_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` call_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned call_logs
    **/
    _count?: true | Call_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Call_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Call_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Call_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Call_logsMaxAggregateInputType
  }

  export type GetCall_logsAggregateType<T extends Call_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateCall_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCall_logs[P]>
      : GetScalarType<T[P], AggregateCall_logs[P]>
  }




  export type call_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: call_logsWhereInput
    orderBy?: call_logsOrderByWithAggregationInput | call_logsOrderByWithAggregationInput[]
    by: Call_logsScalarFieldEnum[] | Call_logsScalarFieldEnum
    having?: call_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Call_logsCountAggregateInputType | true
    _avg?: Call_logsAvgAggregateInputType
    _sum?: Call_logsSumAggregateInputType
    _min?: Call_logsMinAggregateInputType
    _max?: Call_logsMaxAggregateInputType
  }

  export type Call_logsGroupByOutputType = {
    id: string
    callSessionId: string
    status: string
    duration: number | null
    timestamp: Date
    _count: Call_logsCountAggregateOutputType | null
    _avg: Call_logsAvgAggregateOutputType | null
    _sum: Call_logsSumAggregateOutputType | null
    _min: Call_logsMinAggregateOutputType | null
    _max: Call_logsMaxAggregateOutputType | null
  }

  type GetCall_logsGroupByPayload<T extends call_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Call_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Call_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Call_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Call_logsGroupByOutputType[P]>
        }
      >
    >


  export type call_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    callSessionId?: boolean
    status?: boolean
    duration?: boolean
    timestamp?: boolean
    call_sessions?: boolean | call_sessionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["call_logs"]>

  export type call_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    callSessionId?: boolean
    status?: boolean
    duration?: boolean
    timestamp?: boolean
    call_sessions?: boolean | call_sessionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["call_logs"]>

  export type call_logsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    callSessionId?: boolean
    status?: boolean
    duration?: boolean
    timestamp?: boolean
    call_sessions?: boolean | call_sessionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["call_logs"]>

  export type call_logsSelectScalar = {
    id?: boolean
    callSessionId?: boolean
    status?: boolean
    duration?: boolean
    timestamp?: boolean
  }

  export type call_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "callSessionId" | "status" | "duration" | "timestamp", ExtArgs["result"]["call_logs"]>
  export type call_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    call_sessions?: boolean | call_sessionsDefaultArgs<ExtArgs>
  }
  export type call_logsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    call_sessions?: boolean | call_sessionsDefaultArgs<ExtArgs>
  }
  export type call_logsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    call_sessions?: boolean | call_sessionsDefaultArgs<ExtArgs>
  }

  export type $call_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "call_logs"
    objects: {
      call_sessions: Prisma.$call_sessionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      callSessionId: string
      status: string
      duration: number | null
      timestamp: Date
    }, ExtArgs["result"]["call_logs"]>
    composites: {}
  }

  type call_logsGetPayload<S extends boolean | null | undefined | call_logsDefaultArgs> = $Result.GetResult<Prisma.$call_logsPayload, S>

  type call_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<call_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Call_logsCountAggregateInputType | true
    }

  export interface call_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['call_logs'], meta: { name: 'call_logs' } }
    /**
     * Find zero or one Call_logs that matches the filter.
     * @param {call_logsFindUniqueArgs} args - Arguments to find a Call_logs
     * @example
     * // Get one Call_logs
     * const call_logs = await prisma.call_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends call_logsFindUniqueArgs>(args: SelectSubset<T, call_logsFindUniqueArgs<ExtArgs>>): Prisma__call_logsClient<$Result.GetResult<Prisma.$call_logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Call_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {call_logsFindUniqueOrThrowArgs} args - Arguments to find a Call_logs
     * @example
     * // Get one Call_logs
     * const call_logs = await prisma.call_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends call_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, call_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__call_logsClient<$Result.GetResult<Prisma.$call_logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Call_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {call_logsFindFirstArgs} args - Arguments to find a Call_logs
     * @example
     * // Get one Call_logs
     * const call_logs = await prisma.call_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends call_logsFindFirstArgs>(args?: SelectSubset<T, call_logsFindFirstArgs<ExtArgs>>): Prisma__call_logsClient<$Result.GetResult<Prisma.$call_logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Call_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {call_logsFindFirstOrThrowArgs} args - Arguments to find a Call_logs
     * @example
     * // Get one Call_logs
     * const call_logs = await prisma.call_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends call_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, call_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__call_logsClient<$Result.GetResult<Prisma.$call_logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Call_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {call_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Call_logs
     * const call_logs = await prisma.call_logs.findMany()
     * 
     * // Get first 10 Call_logs
     * const call_logs = await prisma.call_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const call_logsWithIdOnly = await prisma.call_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends call_logsFindManyArgs>(args?: SelectSubset<T, call_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$call_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Call_logs.
     * @param {call_logsCreateArgs} args - Arguments to create a Call_logs.
     * @example
     * // Create one Call_logs
     * const Call_logs = await prisma.call_logs.create({
     *   data: {
     *     // ... data to create a Call_logs
     *   }
     * })
     * 
     */
    create<T extends call_logsCreateArgs>(args: SelectSubset<T, call_logsCreateArgs<ExtArgs>>): Prisma__call_logsClient<$Result.GetResult<Prisma.$call_logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Call_logs.
     * @param {call_logsCreateManyArgs} args - Arguments to create many Call_logs.
     * @example
     * // Create many Call_logs
     * const call_logs = await prisma.call_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends call_logsCreateManyArgs>(args?: SelectSubset<T, call_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Call_logs and returns the data saved in the database.
     * @param {call_logsCreateManyAndReturnArgs} args - Arguments to create many Call_logs.
     * @example
     * // Create many Call_logs
     * const call_logs = await prisma.call_logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Call_logs and only return the `id`
     * const call_logsWithIdOnly = await prisma.call_logs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends call_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, call_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$call_logsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Call_logs.
     * @param {call_logsDeleteArgs} args - Arguments to delete one Call_logs.
     * @example
     * // Delete one Call_logs
     * const Call_logs = await prisma.call_logs.delete({
     *   where: {
     *     // ... filter to delete one Call_logs
     *   }
     * })
     * 
     */
    delete<T extends call_logsDeleteArgs>(args: SelectSubset<T, call_logsDeleteArgs<ExtArgs>>): Prisma__call_logsClient<$Result.GetResult<Prisma.$call_logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Call_logs.
     * @param {call_logsUpdateArgs} args - Arguments to update one Call_logs.
     * @example
     * // Update one Call_logs
     * const call_logs = await prisma.call_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends call_logsUpdateArgs>(args: SelectSubset<T, call_logsUpdateArgs<ExtArgs>>): Prisma__call_logsClient<$Result.GetResult<Prisma.$call_logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Call_logs.
     * @param {call_logsDeleteManyArgs} args - Arguments to filter Call_logs to delete.
     * @example
     * // Delete a few Call_logs
     * const { count } = await prisma.call_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends call_logsDeleteManyArgs>(args?: SelectSubset<T, call_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Call_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {call_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Call_logs
     * const call_logs = await prisma.call_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends call_logsUpdateManyArgs>(args: SelectSubset<T, call_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Call_logs and returns the data updated in the database.
     * @param {call_logsUpdateManyAndReturnArgs} args - Arguments to update many Call_logs.
     * @example
     * // Update many Call_logs
     * const call_logs = await prisma.call_logs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Call_logs and only return the `id`
     * const call_logsWithIdOnly = await prisma.call_logs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends call_logsUpdateManyAndReturnArgs>(args: SelectSubset<T, call_logsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$call_logsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Call_logs.
     * @param {call_logsUpsertArgs} args - Arguments to update or create a Call_logs.
     * @example
     * // Update or create a Call_logs
     * const call_logs = await prisma.call_logs.upsert({
     *   create: {
     *     // ... data to create a Call_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Call_logs we want to update
     *   }
     * })
     */
    upsert<T extends call_logsUpsertArgs>(args: SelectSubset<T, call_logsUpsertArgs<ExtArgs>>): Prisma__call_logsClient<$Result.GetResult<Prisma.$call_logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Call_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {call_logsCountArgs} args - Arguments to filter Call_logs to count.
     * @example
     * // Count the number of Call_logs
     * const count = await prisma.call_logs.count({
     *   where: {
     *     // ... the filter for the Call_logs we want to count
     *   }
     * })
    **/
    count<T extends call_logsCountArgs>(
      args?: Subset<T, call_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Call_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Call_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Call_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Call_logsAggregateArgs>(args: Subset<T, Call_logsAggregateArgs>): Prisma.PrismaPromise<GetCall_logsAggregateType<T>>

    /**
     * Group by Call_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {call_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends call_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: call_logsGroupByArgs['orderBy'] }
        : { orderBy?: call_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, call_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCall_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the call_logs model
   */
  readonly fields: call_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for call_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__call_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    call_sessions<T extends call_sessionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, call_sessionsDefaultArgs<ExtArgs>>): Prisma__call_sessionsClient<$Result.GetResult<Prisma.$call_sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the call_logs model
   */
  interface call_logsFieldRefs {
    readonly id: FieldRef<"call_logs", 'String'>
    readonly callSessionId: FieldRef<"call_logs", 'String'>
    readonly status: FieldRef<"call_logs", 'String'>
    readonly duration: FieldRef<"call_logs", 'Int'>
    readonly timestamp: FieldRef<"call_logs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * call_logs findUnique
   */
  export type call_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_logs
     */
    select?: call_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the call_logs
     */
    omit?: call_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_logsInclude<ExtArgs> | null
    /**
     * Filter, which call_logs to fetch.
     */
    where: call_logsWhereUniqueInput
  }

  /**
   * call_logs findUniqueOrThrow
   */
  export type call_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_logs
     */
    select?: call_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the call_logs
     */
    omit?: call_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_logsInclude<ExtArgs> | null
    /**
     * Filter, which call_logs to fetch.
     */
    where: call_logsWhereUniqueInput
  }

  /**
   * call_logs findFirst
   */
  export type call_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_logs
     */
    select?: call_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the call_logs
     */
    omit?: call_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_logsInclude<ExtArgs> | null
    /**
     * Filter, which call_logs to fetch.
     */
    where?: call_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of call_logs to fetch.
     */
    orderBy?: call_logsOrderByWithRelationInput | call_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for call_logs.
     */
    cursor?: call_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` call_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` call_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of call_logs.
     */
    distinct?: Call_logsScalarFieldEnum | Call_logsScalarFieldEnum[]
  }

  /**
   * call_logs findFirstOrThrow
   */
  export type call_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_logs
     */
    select?: call_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the call_logs
     */
    omit?: call_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_logsInclude<ExtArgs> | null
    /**
     * Filter, which call_logs to fetch.
     */
    where?: call_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of call_logs to fetch.
     */
    orderBy?: call_logsOrderByWithRelationInput | call_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for call_logs.
     */
    cursor?: call_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` call_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` call_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of call_logs.
     */
    distinct?: Call_logsScalarFieldEnum | Call_logsScalarFieldEnum[]
  }

  /**
   * call_logs findMany
   */
  export type call_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_logs
     */
    select?: call_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the call_logs
     */
    omit?: call_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_logsInclude<ExtArgs> | null
    /**
     * Filter, which call_logs to fetch.
     */
    where?: call_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of call_logs to fetch.
     */
    orderBy?: call_logsOrderByWithRelationInput | call_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing call_logs.
     */
    cursor?: call_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` call_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` call_logs.
     */
    skip?: number
    distinct?: Call_logsScalarFieldEnum | Call_logsScalarFieldEnum[]
  }

  /**
   * call_logs create
   */
  export type call_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_logs
     */
    select?: call_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the call_logs
     */
    omit?: call_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a call_logs.
     */
    data: XOR<call_logsCreateInput, call_logsUncheckedCreateInput>
  }

  /**
   * call_logs createMany
   */
  export type call_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many call_logs.
     */
    data: call_logsCreateManyInput | call_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * call_logs createManyAndReturn
   */
  export type call_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_logs
     */
    select?: call_logsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the call_logs
     */
    omit?: call_logsOmit<ExtArgs> | null
    /**
     * The data used to create many call_logs.
     */
    data: call_logsCreateManyInput | call_logsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_logsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * call_logs update
   */
  export type call_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_logs
     */
    select?: call_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the call_logs
     */
    omit?: call_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a call_logs.
     */
    data: XOR<call_logsUpdateInput, call_logsUncheckedUpdateInput>
    /**
     * Choose, which call_logs to update.
     */
    where: call_logsWhereUniqueInput
  }

  /**
   * call_logs updateMany
   */
  export type call_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update call_logs.
     */
    data: XOR<call_logsUpdateManyMutationInput, call_logsUncheckedUpdateManyInput>
    /**
     * Filter which call_logs to update
     */
    where?: call_logsWhereInput
    /**
     * Limit how many call_logs to update.
     */
    limit?: number
  }

  /**
   * call_logs updateManyAndReturn
   */
  export type call_logsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_logs
     */
    select?: call_logsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the call_logs
     */
    omit?: call_logsOmit<ExtArgs> | null
    /**
     * The data used to update call_logs.
     */
    data: XOR<call_logsUpdateManyMutationInput, call_logsUncheckedUpdateManyInput>
    /**
     * Filter which call_logs to update
     */
    where?: call_logsWhereInput
    /**
     * Limit how many call_logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_logsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * call_logs upsert
   */
  export type call_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_logs
     */
    select?: call_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the call_logs
     */
    omit?: call_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the call_logs to update in case it exists.
     */
    where: call_logsWhereUniqueInput
    /**
     * In case the call_logs found by the `where` argument doesn't exist, create a new call_logs with this data.
     */
    create: XOR<call_logsCreateInput, call_logsUncheckedCreateInput>
    /**
     * In case the call_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<call_logsUpdateInput, call_logsUncheckedUpdateInput>
  }

  /**
   * call_logs delete
   */
  export type call_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_logs
     */
    select?: call_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the call_logs
     */
    omit?: call_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_logsInclude<ExtArgs> | null
    /**
     * Filter which call_logs to delete.
     */
    where: call_logsWhereUniqueInput
  }

  /**
   * call_logs deleteMany
   */
  export type call_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which call_logs to delete
     */
    where?: call_logsWhereInput
    /**
     * Limit how many call_logs to delete.
     */
    limit?: number
  }

  /**
   * call_logs without action
   */
  export type call_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_logs
     */
    select?: call_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the call_logs
     */
    omit?: call_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_logsInclude<ExtArgs> | null
  }


  /**
   * Model call_sessions
   */

  export type AggregateCall_sessions = {
    _count: Call_sessionsCountAggregateOutputType | null
    _avg: Call_sessionsAvgAggregateOutputType | null
    _sum: Call_sessionsSumAggregateOutputType | null
    _min: Call_sessionsMinAggregateOutputType | null
    _max: Call_sessionsMaxAggregateOutputType | null
  }

  export type Call_sessionsAvgAggregateOutputType = {
    duration: number | null
  }

  export type Call_sessionsSumAggregateOutputType = {
    duration: number | null
  }

  export type Call_sessionsMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    providerId: string | null
    orderId: string | null
    twilioCallSid: string | null
    customerPhone: string | null
    providerPhone: string | null
    status: string | null
    duration: number | null
    startedAt: Date | null
    endedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Call_sessionsMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    providerId: string | null
    orderId: string | null
    twilioCallSid: string | null
    customerPhone: string | null
    providerPhone: string | null
    status: string | null
    duration: number | null
    startedAt: Date | null
    endedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Call_sessionsCountAggregateOutputType = {
    id: number
    customerId: number
    providerId: number
    orderId: number
    twilioCallSid: number
    customerPhone: number
    providerPhone: number
    status: number
    duration: number
    startedAt: number
    endedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Call_sessionsAvgAggregateInputType = {
    duration?: true
  }

  export type Call_sessionsSumAggregateInputType = {
    duration?: true
  }

  export type Call_sessionsMinAggregateInputType = {
    id?: true
    customerId?: true
    providerId?: true
    orderId?: true
    twilioCallSid?: true
    customerPhone?: true
    providerPhone?: true
    status?: true
    duration?: true
    startedAt?: true
    endedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Call_sessionsMaxAggregateInputType = {
    id?: true
    customerId?: true
    providerId?: true
    orderId?: true
    twilioCallSid?: true
    customerPhone?: true
    providerPhone?: true
    status?: true
    duration?: true
    startedAt?: true
    endedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Call_sessionsCountAggregateInputType = {
    id?: true
    customerId?: true
    providerId?: true
    orderId?: true
    twilioCallSid?: true
    customerPhone?: true
    providerPhone?: true
    status?: true
    duration?: true
    startedAt?: true
    endedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Call_sessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which call_sessions to aggregate.
     */
    where?: call_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of call_sessions to fetch.
     */
    orderBy?: call_sessionsOrderByWithRelationInput | call_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: call_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` call_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` call_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned call_sessions
    **/
    _count?: true | Call_sessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Call_sessionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Call_sessionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Call_sessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Call_sessionsMaxAggregateInputType
  }

  export type GetCall_sessionsAggregateType<T extends Call_sessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateCall_sessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCall_sessions[P]>
      : GetScalarType<T[P], AggregateCall_sessions[P]>
  }




  export type call_sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: call_sessionsWhereInput
    orderBy?: call_sessionsOrderByWithAggregationInput | call_sessionsOrderByWithAggregationInput[]
    by: Call_sessionsScalarFieldEnum[] | Call_sessionsScalarFieldEnum
    having?: call_sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Call_sessionsCountAggregateInputType | true
    _avg?: Call_sessionsAvgAggregateInputType
    _sum?: Call_sessionsSumAggregateInputType
    _min?: Call_sessionsMinAggregateInputType
    _max?: Call_sessionsMaxAggregateInputType
  }

  export type Call_sessionsGroupByOutputType = {
    id: string
    customerId: string
    providerId: string
    orderId: string | null
    twilioCallSid: string | null
    customerPhone: string
    providerPhone: string
    status: string
    duration: number | null
    startedAt: Date | null
    endedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: Call_sessionsCountAggregateOutputType | null
    _avg: Call_sessionsAvgAggregateOutputType | null
    _sum: Call_sessionsSumAggregateOutputType | null
    _min: Call_sessionsMinAggregateOutputType | null
    _max: Call_sessionsMaxAggregateOutputType | null
  }

  type GetCall_sessionsGroupByPayload<T extends call_sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Call_sessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Call_sessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Call_sessionsGroupByOutputType[P]>
            : GetScalarType<T[P], Call_sessionsGroupByOutputType[P]>
        }
      >
    >


  export type call_sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    providerId?: boolean
    orderId?: boolean
    twilioCallSid?: boolean
    customerPhone?: boolean
    providerPhone?: boolean
    status?: boolean
    duration?: boolean
    startedAt?: boolean
    endedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    call_logs?: boolean | call_sessions$call_logsArgs<ExtArgs>
    users_call_sessions_customerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    orders?: boolean | call_sessions$ordersArgs<ExtArgs>
    users_call_sessions_providerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | Call_sessionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["call_sessions"]>

  export type call_sessionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    providerId?: boolean
    orderId?: boolean
    twilioCallSid?: boolean
    customerPhone?: boolean
    providerPhone?: boolean
    status?: boolean
    duration?: boolean
    startedAt?: boolean
    endedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_call_sessions_customerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    orders?: boolean | call_sessions$ordersArgs<ExtArgs>
    users_call_sessions_providerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["call_sessions"]>

  export type call_sessionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    providerId?: boolean
    orderId?: boolean
    twilioCallSid?: boolean
    customerPhone?: boolean
    providerPhone?: boolean
    status?: boolean
    duration?: boolean
    startedAt?: boolean
    endedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_call_sessions_customerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    orders?: boolean | call_sessions$ordersArgs<ExtArgs>
    users_call_sessions_providerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["call_sessions"]>

  export type call_sessionsSelectScalar = {
    id?: boolean
    customerId?: boolean
    providerId?: boolean
    orderId?: boolean
    twilioCallSid?: boolean
    customerPhone?: boolean
    providerPhone?: boolean
    status?: boolean
    duration?: boolean
    startedAt?: boolean
    endedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type call_sessionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "providerId" | "orderId" | "twilioCallSid" | "customerPhone" | "providerPhone" | "status" | "duration" | "startedAt" | "endedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["call_sessions"]>
  export type call_sessionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    call_logs?: boolean | call_sessions$call_logsArgs<ExtArgs>
    users_call_sessions_customerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    orders?: boolean | call_sessions$ordersArgs<ExtArgs>
    users_call_sessions_providerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | Call_sessionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type call_sessionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_call_sessions_customerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    orders?: boolean | call_sessions$ordersArgs<ExtArgs>
    users_call_sessions_providerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type call_sessionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_call_sessions_customerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    orders?: boolean | call_sessions$ordersArgs<ExtArgs>
    users_call_sessions_providerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $call_sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "call_sessions"
    objects: {
      call_logs: Prisma.$call_logsPayload<ExtArgs>[]
      users_call_sessions_customerIdTousers: Prisma.$usersPayload<ExtArgs>
      orders: Prisma.$ordersPayload<ExtArgs> | null
      users_call_sessions_providerIdTousers: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      providerId: string
      orderId: string | null
      twilioCallSid: string | null
      customerPhone: string
      providerPhone: string
      status: string
      duration: number | null
      startedAt: Date | null
      endedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["call_sessions"]>
    composites: {}
  }

  type call_sessionsGetPayload<S extends boolean | null | undefined | call_sessionsDefaultArgs> = $Result.GetResult<Prisma.$call_sessionsPayload, S>

  type call_sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<call_sessionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Call_sessionsCountAggregateInputType | true
    }

  export interface call_sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['call_sessions'], meta: { name: 'call_sessions' } }
    /**
     * Find zero or one Call_sessions that matches the filter.
     * @param {call_sessionsFindUniqueArgs} args - Arguments to find a Call_sessions
     * @example
     * // Get one Call_sessions
     * const call_sessions = await prisma.call_sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends call_sessionsFindUniqueArgs>(args: SelectSubset<T, call_sessionsFindUniqueArgs<ExtArgs>>): Prisma__call_sessionsClient<$Result.GetResult<Prisma.$call_sessionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Call_sessions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {call_sessionsFindUniqueOrThrowArgs} args - Arguments to find a Call_sessions
     * @example
     * // Get one Call_sessions
     * const call_sessions = await prisma.call_sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends call_sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, call_sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__call_sessionsClient<$Result.GetResult<Prisma.$call_sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Call_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {call_sessionsFindFirstArgs} args - Arguments to find a Call_sessions
     * @example
     * // Get one Call_sessions
     * const call_sessions = await prisma.call_sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends call_sessionsFindFirstArgs>(args?: SelectSubset<T, call_sessionsFindFirstArgs<ExtArgs>>): Prisma__call_sessionsClient<$Result.GetResult<Prisma.$call_sessionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Call_sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {call_sessionsFindFirstOrThrowArgs} args - Arguments to find a Call_sessions
     * @example
     * // Get one Call_sessions
     * const call_sessions = await prisma.call_sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends call_sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, call_sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__call_sessionsClient<$Result.GetResult<Prisma.$call_sessionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Call_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {call_sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Call_sessions
     * const call_sessions = await prisma.call_sessions.findMany()
     * 
     * // Get first 10 Call_sessions
     * const call_sessions = await prisma.call_sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const call_sessionsWithIdOnly = await prisma.call_sessions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends call_sessionsFindManyArgs>(args?: SelectSubset<T, call_sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$call_sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Call_sessions.
     * @param {call_sessionsCreateArgs} args - Arguments to create a Call_sessions.
     * @example
     * // Create one Call_sessions
     * const Call_sessions = await prisma.call_sessions.create({
     *   data: {
     *     // ... data to create a Call_sessions
     *   }
     * })
     * 
     */
    create<T extends call_sessionsCreateArgs>(args: SelectSubset<T, call_sessionsCreateArgs<ExtArgs>>): Prisma__call_sessionsClient<$Result.GetResult<Prisma.$call_sessionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Call_sessions.
     * @param {call_sessionsCreateManyArgs} args - Arguments to create many Call_sessions.
     * @example
     * // Create many Call_sessions
     * const call_sessions = await prisma.call_sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends call_sessionsCreateManyArgs>(args?: SelectSubset<T, call_sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Call_sessions and returns the data saved in the database.
     * @param {call_sessionsCreateManyAndReturnArgs} args - Arguments to create many Call_sessions.
     * @example
     * // Create many Call_sessions
     * const call_sessions = await prisma.call_sessions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Call_sessions and only return the `id`
     * const call_sessionsWithIdOnly = await prisma.call_sessions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends call_sessionsCreateManyAndReturnArgs>(args?: SelectSubset<T, call_sessionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$call_sessionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Call_sessions.
     * @param {call_sessionsDeleteArgs} args - Arguments to delete one Call_sessions.
     * @example
     * // Delete one Call_sessions
     * const Call_sessions = await prisma.call_sessions.delete({
     *   where: {
     *     // ... filter to delete one Call_sessions
     *   }
     * })
     * 
     */
    delete<T extends call_sessionsDeleteArgs>(args: SelectSubset<T, call_sessionsDeleteArgs<ExtArgs>>): Prisma__call_sessionsClient<$Result.GetResult<Prisma.$call_sessionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Call_sessions.
     * @param {call_sessionsUpdateArgs} args - Arguments to update one Call_sessions.
     * @example
     * // Update one Call_sessions
     * const call_sessions = await prisma.call_sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends call_sessionsUpdateArgs>(args: SelectSubset<T, call_sessionsUpdateArgs<ExtArgs>>): Prisma__call_sessionsClient<$Result.GetResult<Prisma.$call_sessionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Call_sessions.
     * @param {call_sessionsDeleteManyArgs} args - Arguments to filter Call_sessions to delete.
     * @example
     * // Delete a few Call_sessions
     * const { count } = await prisma.call_sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends call_sessionsDeleteManyArgs>(args?: SelectSubset<T, call_sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Call_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {call_sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Call_sessions
     * const call_sessions = await prisma.call_sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends call_sessionsUpdateManyArgs>(args: SelectSubset<T, call_sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Call_sessions and returns the data updated in the database.
     * @param {call_sessionsUpdateManyAndReturnArgs} args - Arguments to update many Call_sessions.
     * @example
     * // Update many Call_sessions
     * const call_sessions = await prisma.call_sessions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Call_sessions and only return the `id`
     * const call_sessionsWithIdOnly = await prisma.call_sessions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends call_sessionsUpdateManyAndReturnArgs>(args: SelectSubset<T, call_sessionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$call_sessionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Call_sessions.
     * @param {call_sessionsUpsertArgs} args - Arguments to update or create a Call_sessions.
     * @example
     * // Update or create a Call_sessions
     * const call_sessions = await prisma.call_sessions.upsert({
     *   create: {
     *     // ... data to create a Call_sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Call_sessions we want to update
     *   }
     * })
     */
    upsert<T extends call_sessionsUpsertArgs>(args: SelectSubset<T, call_sessionsUpsertArgs<ExtArgs>>): Prisma__call_sessionsClient<$Result.GetResult<Prisma.$call_sessionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Call_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {call_sessionsCountArgs} args - Arguments to filter Call_sessions to count.
     * @example
     * // Count the number of Call_sessions
     * const count = await prisma.call_sessions.count({
     *   where: {
     *     // ... the filter for the Call_sessions we want to count
     *   }
     * })
    **/
    count<T extends call_sessionsCountArgs>(
      args?: Subset<T, call_sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Call_sessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Call_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Call_sessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Call_sessionsAggregateArgs>(args: Subset<T, Call_sessionsAggregateArgs>): Prisma.PrismaPromise<GetCall_sessionsAggregateType<T>>

    /**
     * Group by Call_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {call_sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends call_sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: call_sessionsGroupByArgs['orderBy'] }
        : { orderBy?: call_sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, call_sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCall_sessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the call_sessions model
   */
  readonly fields: call_sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for call_sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__call_sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    call_logs<T extends call_sessions$call_logsArgs<ExtArgs> = {}>(args?: Subset<T, call_sessions$call_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$call_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users_call_sessions_customerIdTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orders<T extends call_sessions$ordersArgs<ExtArgs> = {}>(args?: Subset<T, call_sessions$ordersArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users_call_sessions_providerIdTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the call_sessions model
   */
  interface call_sessionsFieldRefs {
    readonly id: FieldRef<"call_sessions", 'String'>
    readonly customerId: FieldRef<"call_sessions", 'String'>
    readonly providerId: FieldRef<"call_sessions", 'String'>
    readonly orderId: FieldRef<"call_sessions", 'String'>
    readonly twilioCallSid: FieldRef<"call_sessions", 'String'>
    readonly customerPhone: FieldRef<"call_sessions", 'String'>
    readonly providerPhone: FieldRef<"call_sessions", 'String'>
    readonly status: FieldRef<"call_sessions", 'String'>
    readonly duration: FieldRef<"call_sessions", 'Int'>
    readonly startedAt: FieldRef<"call_sessions", 'DateTime'>
    readonly endedAt: FieldRef<"call_sessions", 'DateTime'>
    readonly createdAt: FieldRef<"call_sessions", 'DateTime'>
    readonly updatedAt: FieldRef<"call_sessions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * call_sessions findUnique
   */
  export type call_sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_sessions
     */
    select?: call_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the call_sessions
     */
    omit?: call_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which call_sessions to fetch.
     */
    where: call_sessionsWhereUniqueInput
  }

  /**
   * call_sessions findUniqueOrThrow
   */
  export type call_sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_sessions
     */
    select?: call_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the call_sessions
     */
    omit?: call_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which call_sessions to fetch.
     */
    where: call_sessionsWhereUniqueInput
  }

  /**
   * call_sessions findFirst
   */
  export type call_sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_sessions
     */
    select?: call_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the call_sessions
     */
    omit?: call_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which call_sessions to fetch.
     */
    where?: call_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of call_sessions to fetch.
     */
    orderBy?: call_sessionsOrderByWithRelationInput | call_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for call_sessions.
     */
    cursor?: call_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` call_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` call_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of call_sessions.
     */
    distinct?: Call_sessionsScalarFieldEnum | Call_sessionsScalarFieldEnum[]
  }

  /**
   * call_sessions findFirstOrThrow
   */
  export type call_sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_sessions
     */
    select?: call_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the call_sessions
     */
    omit?: call_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which call_sessions to fetch.
     */
    where?: call_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of call_sessions to fetch.
     */
    orderBy?: call_sessionsOrderByWithRelationInput | call_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for call_sessions.
     */
    cursor?: call_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` call_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` call_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of call_sessions.
     */
    distinct?: Call_sessionsScalarFieldEnum | Call_sessionsScalarFieldEnum[]
  }

  /**
   * call_sessions findMany
   */
  export type call_sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_sessions
     */
    select?: call_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the call_sessions
     */
    omit?: call_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which call_sessions to fetch.
     */
    where?: call_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of call_sessions to fetch.
     */
    orderBy?: call_sessionsOrderByWithRelationInput | call_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing call_sessions.
     */
    cursor?: call_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` call_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` call_sessions.
     */
    skip?: number
    distinct?: Call_sessionsScalarFieldEnum | Call_sessionsScalarFieldEnum[]
  }

  /**
   * call_sessions create
   */
  export type call_sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_sessions
     */
    select?: call_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the call_sessions
     */
    omit?: call_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_sessionsInclude<ExtArgs> | null
    /**
     * The data needed to create a call_sessions.
     */
    data: XOR<call_sessionsCreateInput, call_sessionsUncheckedCreateInput>
  }

  /**
   * call_sessions createMany
   */
  export type call_sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many call_sessions.
     */
    data: call_sessionsCreateManyInput | call_sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * call_sessions createManyAndReturn
   */
  export type call_sessionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_sessions
     */
    select?: call_sessionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the call_sessions
     */
    omit?: call_sessionsOmit<ExtArgs> | null
    /**
     * The data used to create many call_sessions.
     */
    data: call_sessionsCreateManyInput | call_sessionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_sessionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * call_sessions update
   */
  export type call_sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_sessions
     */
    select?: call_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the call_sessions
     */
    omit?: call_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_sessionsInclude<ExtArgs> | null
    /**
     * The data needed to update a call_sessions.
     */
    data: XOR<call_sessionsUpdateInput, call_sessionsUncheckedUpdateInput>
    /**
     * Choose, which call_sessions to update.
     */
    where: call_sessionsWhereUniqueInput
  }

  /**
   * call_sessions updateMany
   */
  export type call_sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update call_sessions.
     */
    data: XOR<call_sessionsUpdateManyMutationInput, call_sessionsUncheckedUpdateManyInput>
    /**
     * Filter which call_sessions to update
     */
    where?: call_sessionsWhereInput
    /**
     * Limit how many call_sessions to update.
     */
    limit?: number
  }

  /**
   * call_sessions updateManyAndReturn
   */
  export type call_sessionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_sessions
     */
    select?: call_sessionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the call_sessions
     */
    omit?: call_sessionsOmit<ExtArgs> | null
    /**
     * The data used to update call_sessions.
     */
    data: XOR<call_sessionsUpdateManyMutationInput, call_sessionsUncheckedUpdateManyInput>
    /**
     * Filter which call_sessions to update
     */
    where?: call_sessionsWhereInput
    /**
     * Limit how many call_sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_sessionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * call_sessions upsert
   */
  export type call_sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_sessions
     */
    select?: call_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the call_sessions
     */
    omit?: call_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_sessionsInclude<ExtArgs> | null
    /**
     * The filter to search for the call_sessions to update in case it exists.
     */
    where: call_sessionsWhereUniqueInput
    /**
     * In case the call_sessions found by the `where` argument doesn't exist, create a new call_sessions with this data.
     */
    create: XOR<call_sessionsCreateInput, call_sessionsUncheckedCreateInput>
    /**
     * In case the call_sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<call_sessionsUpdateInput, call_sessionsUncheckedUpdateInput>
  }

  /**
   * call_sessions delete
   */
  export type call_sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_sessions
     */
    select?: call_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the call_sessions
     */
    omit?: call_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_sessionsInclude<ExtArgs> | null
    /**
     * Filter which call_sessions to delete.
     */
    where: call_sessionsWhereUniqueInput
  }

  /**
   * call_sessions deleteMany
   */
  export type call_sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which call_sessions to delete
     */
    where?: call_sessionsWhereInput
    /**
     * Limit how many call_sessions to delete.
     */
    limit?: number
  }

  /**
   * call_sessions.call_logs
   */
  export type call_sessions$call_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_logs
     */
    select?: call_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the call_logs
     */
    omit?: call_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_logsInclude<ExtArgs> | null
    where?: call_logsWhereInput
    orderBy?: call_logsOrderByWithRelationInput | call_logsOrderByWithRelationInput[]
    cursor?: call_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Call_logsScalarFieldEnum | Call_logsScalarFieldEnum[]
  }

  /**
   * call_sessions.orders
   */
  export type call_sessions$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    where?: ordersWhereInput
  }

  /**
   * call_sessions without action
   */
  export type call_sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_sessions
     */
    select?: call_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the call_sessions
     */
    omit?: call_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_sessionsInclude<ExtArgs> | null
  }


  /**
   * Model faqs
   */

  export type AggregateFaqs = {
    _count: FaqsCountAggregateOutputType | null
    _avg: FaqsAvgAggregateOutputType | null
    _sum: FaqsSumAggregateOutputType | null
    _min: FaqsMinAggregateOutputType | null
    _max: FaqsMaxAggregateOutputType | null
  }

  export type FaqsAvgAggregateOutputType = {
    order: number | null
  }

  export type FaqsSumAggregateOutputType = {
    order: number | null
  }

  export type FaqsMinAggregateOutputType = {
    id: string | null
    question: string | null
    answer: string | null
    category: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FaqsMaxAggregateOutputType = {
    id: string | null
    question: string | null
    answer: string | null
    category: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FaqsCountAggregateOutputType = {
    id: number
    question: number
    answer: number
    category: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FaqsAvgAggregateInputType = {
    order?: true
  }

  export type FaqsSumAggregateInputType = {
    order?: true
  }

  export type FaqsMinAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FaqsMaxAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FaqsCountAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    category?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FaqsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which faqs to aggregate.
     */
    where?: faqsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faqs to fetch.
     */
    orderBy?: faqsOrderByWithRelationInput | faqsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: faqsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned faqs
    **/
    _count?: true | FaqsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FaqsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FaqsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FaqsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FaqsMaxAggregateInputType
  }

  export type GetFaqsAggregateType<T extends FaqsAggregateArgs> = {
        [P in keyof T & keyof AggregateFaqs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaqs[P]>
      : GetScalarType<T[P], AggregateFaqs[P]>
  }




  export type faqsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: faqsWhereInput
    orderBy?: faqsOrderByWithAggregationInput | faqsOrderByWithAggregationInput[]
    by: FaqsScalarFieldEnum[] | FaqsScalarFieldEnum
    having?: faqsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FaqsCountAggregateInputType | true
    _avg?: FaqsAvgAggregateInputType
    _sum?: FaqsSumAggregateInputType
    _min?: FaqsMinAggregateInputType
    _max?: FaqsMaxAggregateInputType
  }

  export type FaqsGroupByOutputType = {
    id: string
    question: string
    answer: string
    category: string
    order: number
    createdAt: Date
    updatedAt: Date
    _count: FaqsCountAggregateOutputType | null
    _avg: FaqsAvgAggregateOutputType | null
    _sum: FaqsSumAggregateOutputType | null
    _min: FaqsMinAggregateOutputType | null
    _max: FaqsMaxAggregateOutputType | null
  }

  type GetFaqsGroupByPayload<T extends faqsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FaqsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FaqsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FaqsGroupByOutputType[P]>
            : GetScalarType<T[P], FaqsGroupByOutputType[P]>
        }
      >
    >


  export type faqsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["faqs"]>

  export type faqsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["faqs"]>

  export type faqsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["faqs"]>

  export type faqsSelectScalar = {
    id?: boolean
    question?: boolean
    answer?: boolean
    category?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type faqsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "question" | "answer" | "category" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["faqs"]>

  export type $faqsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "faqs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      question: string
      answer: string
      category: string
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["faqs"]>
    composites: {}
  }

  type faqsGetPayload<S extends boolean | null | undefined | faqsDefaultArgs> = $Result.GetResult<Prisma.$faqsPayload, S>

  type faqsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<faqsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FaqsCountAggregateInputType | true
    }

  export interface faqsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['faqs'], meta: { name: 'faqs' } }
    /**
     * Find zero or one Faqs that matches the filter.
     * @param {faqsFindUniqueArgs} args - Arguments to find a Faqs
     * @example
     * // Get one Faqs
     * const faqs = await prisma.faqs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends faqsFindUniqueArgs>(args: SelectSubset<T, faqsFindUniqueArgs<ExtArgs>>): Prisma__faqsClient<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Faqs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {faqsFindUniqueOrThrowArgs} args - Arguments to find a Faqs
     * @example
     * // Get one Faqs
     * const faqs = await prisma.faqs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends faqsFindUniqueOrThrowArgs>(args: SelectSubset<T, faqsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__faqsClient<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqsFindFirstArgs} args - Arguments to find a Faqs
     * @example
     * // Get one Faqs
     * const faqs = await prisma.faqs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends faqsFindFirstArgs>(args?: SelectSubset<T, faqsFindFirstArgs<ExtArgs>>): Prisma__faqsClient<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faqs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqsFindFirstOrThrowArgs} args - Arguments to find a Faqs
     * @example
     * // Get one Faqs
     * const faqs = await prisma.faqs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends faqsFindFirstOrThrowArgs>(args?: SelectSubset<T, faqsFindFirstOrThrowArgs<ExtArgs>>): Prisma__faqsClient<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Faqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faqs
     * const faqs = await prisma.faqs.findMany()
     * 
     * // Get first 10 Faqs
     * const faqs = await prisma.faqs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const faqsWithIdOnly = await prisma.faqs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends faqsFindManyArgs>(args?: SelectSubset<T, faqsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Faqs.
     * @param {faqsCreateArgs} args - Arguments to create a Faqs.
     * @example
     * // Create one Faqs
     * const Faqs = await prisma.faqs.create({
     *   data: {
     *     // ... data to create a Faqs
     *   }
     * })
     * 
     */
    create<T extends faqsCreateArgs>(args: SelectSubset<T, faqsCreateArgs<ExtArgs>>): Prisma__faqsClient<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Faqs.
     * @param {faqsCreateManyArgs} args - Arguments to create many Faqs.
     * @example
     * // Create many Faqs
     * const faqs = await prisma.faqs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends faqsCreateManyArgs>(args?: SelectSubset<T, faqsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Faqs and returns the data saved in the database.
     * @param {faqsCreateManyAndReturnArgs} args - Arguments to create many Faqs.
     * @example
     * // Create many Faqs
     * const faqs = await prisma.faqs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Faqs and only return the `id`
     * const faqsWithIdOnly = await prisma.faqs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends faqsCreateManyAndReturnArgs>(args?: SelectSubset<T, faqsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Faqs.
     * @param {faqsDeleteArgs} args - Arguments to delete one Faqs.
     * @example
     * // Delete one Faqs
     * const Faqs = await prisma.faqs.delete({
     *   where: {
     *     // ... filter to delete one Faqs
     *   }
     * })
     * 
     */
    delete<T extends faqsDeleteArgs>(args: SelectSubset<T, faqsDeleteArgs<ExtArgs>>): Prisma__faqsClient<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Faqs.
     * @param {faqsUpdateArgs} args - Arguments to update one Faqs.
     * @example
     * // Update one Faqs
     * const faqs = await prisma.faqs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends faqsUpdateArgs>(args: SelectSubset<T, faqsUpdateArgs<ExtArgs>>): Prisma__faqsClient<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Faqs.
     * @param {faqsDeleteManyArgs} args - Arguments to filter Faqs to delete.
     * @example
     * // Delete a few Faqs
     * const { count } = await prisma.faqs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends faqsDeleteManyArgs>(args?: SelectSubset<T, faqsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faqs
     * const faqs = await prisma.faqs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends faqsUpdateManyArgs>(args: SelectSubset<T, faqsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faqs and returns the data updated in the database.
     * @param {faqsUpdateManyAndReturnArgs} args - Arguments to update many Faqs.
     * @example
     * // Update many Faqs
     * const faqs = await prisma.faqs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Faqs and only return the `id`
     * const faqsWithIdOnly = await prisma.faqs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends faqsUpdateManyAndReturnArgs>(args: SelectSubset<T, faqsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Faqs.
     * @param {faqsUpsertArgs} args - Arguments to update or create a Faqs.
     * @example
     * // Update or create a Faqs
     * const faqs = await prisma.faqs.upsert({
     *   create: {
     *     // ... data to create a Faqs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faqs we want to update
     *   }
     * })
     */
    upsert<T extends faqsUpsertArgs>(args: SelectSubset<T, faqsUpsertArgs<ExtArgs>>): Prisma__faqsClient<$Result.GetResult<Prisma.$faqsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqsCountArgs} args - Arguments to filter Faqs to count.
     * @example
     * // Count the number of Faqs
     * const count = await prisma.faqs.count({
     *   where: {
     *     // ... the filter for the Faqs we want to count
     *   }
     * })
    **/
    count<T extends faqsCountArgs>(
      args?: Subset<T, faqsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FaqsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FaqsAggregateArgs>(args: Subset<T, FaqsAggregateArgs>): Prisma.PrismaPromise<GetFaqsAggregateType<T>>

    /**
     * Group by Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends faqsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: faqsGroupByArgs['orderBy'] }
        : { orderBy?: faqsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, faqsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFaqsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the faqs model
   */
  readonly fields: faqsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for faqs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__faqsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the faqs model
   */
  interface faqsFieldRefs {
    readonly id: FieldRef<"faqs", 'String'>
    readonly question: FieldRef<"faqs", 'String'>
    readonly answer: FieldRef<"faqs", 'String'>
    readonly category: FieldRef<"faqs", 'String'>
    readonly order: FieldRef<"faqs", 'Int'>
    readonly createdAt: FieldRef<"faqs", 'DateTime'>
    readonly updatedAt: FieldRef<"faqs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * faqs findUnique
   */
  export type faqsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faqs
     */
    omit?: faqsOmit<ExtArgs> | null
    /**
     * Filter, which faqs to fetch.
     */
    where: faqsWhereUniqueInput
  }

  /**
   * faqs findUniqueOrThrow
   */
  export type faqsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faqs
     */
    omit?: faqsOmit<ExtArgs> | null
    /**
     * Filter, which faqs to fetch.
     */
    where: faqsWhereUniqueInput
  }

  /**
   * faqs findFirst
   */
  export type faqsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faqs
     */
    omit?: faqsOmit<ExtArgs> | null
    /**
     * Filter, which faqs to fetch.
     */
    where?: faqsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faqs to fetch.
     */
    orderBy?: faqsOrderByWithRelationInput | faqsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for faqs.
     */
    cursor?: faqsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of faqs.
     */
    distinct?: FaqsScalarFieldEnum | FaqsScalarFieldEnum[]
  }

  /**
   * faqs findFirstOrThrow
   */
  export type faqsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faqs
     */
    omit?: faqsOmit<ExtArgs> | null
    /**
     * Filter, which faqs to fetch.
     */
    where?: faqsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faqs to fetch.
     */
    orderBy?: faqsOrderByWithRelationInput | faqsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for faqs.
     */
    cursor?: faqsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of faqs.
     */
    distinct?: FaqsScalarFieldEnum | FaqsScalarFieldEnum[]
  }

  /**
   * faqs findMany
   */
  export type faqsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faqs
     */
    omit?: faqsOmit<ExtArgs> | null
    /**
     * Filter, which faqs to fetch.
     */
    where?: faqsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faqs to fetch.
     */
    orderBy?: faqsOrderByWithRelationInput | faqsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing faqs.
     */
    cursor?: faqsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faqs.
     */
    skip?: number
    distinct?: FaqsScalarFieldEnum | FaqsScalarFieldEnum[]
  }

  /**
   * faqs create
   */
  export type faqsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faqs
     */
    omit?: faqsOmit<ExtArgs> | null
    /**
     * The data needed to create a faqs.
     */
    data: XOR<faqsCreateInput, faqsUncheckedCreateInput>
  }

  /**
   * faqs createMany
   */
  export type faqsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many faqs.
     */
    data: faqsCreateManyInput | faqsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * faqs createManyAndReturn
   */
  export type faqsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the faqs
     */
    omit?: faqsOmit<ExtArgs> | null
    /**
     * The data used to create many faqs.
     */
    data: faqsCreateManyInput | faqsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * faqs update
   */
  export type faqsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faqs
     */
    omit?: faqsOmit<ExtArgs> | null
    /**
     * The data needed to update a faqs.
     */
    data: XOR<faqsUpdateInput, faqsUncheckedUpdateInput>
    /**
     * Choose, which faqs to update.
     */
    where: faqsWhereUniqueInput
  }

  /**
   * faqs updateMany
   */
  export type faqsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update faqs.
     */
    data: XOR<faqsUpdateManyMutationInput, faqsUncheckedUpdateManyInput>
    /**
     * Filter which faqs to update
     */
    where?: faqsWhereInput
    /**
     * Limit how many faqs to update.
     */
    limit?: number
  }

  /**
   * faqs updateManyAndReturn
   */
  export type faqsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the faqs
     */
    omit?: faqsOmit<ExtArgs> | null
    /**
     * The data used to update faqs.
     */
    data: XOR<faqsUpdateManyMutationInput, faqsUncheckedUpdateManyInput>
    /**
     * Filter which faqs to update
     */
    where?: faqsWhereInput
    /**
     * Limit how many faqs to update.
     */
    limit?: number
  }

  /**
   * faqs upsert
   */
  export type faqsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faqs
     */
    omit?: faqsOmit<ExtArgs> | null
    /**
     * The filter to search for the faqs to update in case it exists.
     */
    where: faqsWhereUniqueInput
    /**
     * In case the faqs found by the `where` argument doesn't exist, create a new faqs with this data.
     */
    create: XOR<faqsCreateInput, faqsUncheckedCreateInput>
    /**
     * In case the faqs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<faqsUpdateInput, faqsUncheckedUpdateInput>
  }

  /**
   * faqs delete
   */
  export type faqsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faqs
     */
    omit?: faqsOmit<ExtArgs> | null
    /**
     * Filter which faqs to delete.
     */
    where: faqsWhereUniqueInput
  }

  /**
   * faqs deleteMany
   */
  export type faqsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which faqs to delete
     */
    where?: faqsWhereInput
    /**
     * Limit how many faqs to delete.
     */
    limit?: number
  }

  /**
   * faqs without action
   */
  export type faqsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faqs
     */
    select?: faqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the faqs
     */
    omit?: faqsOmit<ExtArgs> | null
  }


  /**
   * Model messages
   */

  export type AggregateMessages = {
    _count: MessagesCountAggregateOutputType | null
    _min: MessagesMinAggregateOutputType | null
    _max: MessagesMaxAggregateOutputType | null
  }

  export type MessagesMinAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    content: string | null
    orderId: string | null
    createdAt: Date | null
  }

  export type MessagesMaxAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    content: string | null
    orderId: string | null
    createdAt: Date | null
  }

  export type MessagesCountAggregateOutputType = {
    id: number
    senderId: number
    receiverId: number
    content: number
    orderId: number
    createdAt: number
    _all: number
  }


  export type MessagesMinAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    orderId?: true
    createdAt?: true
  }

  export type MessagesMaxAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    orderId?: true
    createdAt?: true
  }

  export type MessagesCountAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    orderId?: true
    createdAt?: true
    _all?: true
  }

  export type MessagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which messages to aggregate.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned messages
    **/
    _count?: true | MessagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessagesMaxAggregateInputType
  }

  export type GetMessagesAggregateType<T extends MessagesAggregateArgs> = {
        [P in keyof T & keyof AggregateMessages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessages[P]>
      : GetScalarType<T[P], AggregateMessages[P]>
  }




  export type messagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messagesWhereInput
    orderBy?: messagesOrderByWithAggregationInput | messagesOrderByWithAggregationInput[]
    by: MessagesScalarFieldEnum[] | MessagesScalarFieldEnum
    having?: messagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessagesCountAggregateInputType | true
    _min?: MessagesMinAggregateInputType
    _max?: MessagesMaxAggregateInputType
  }

  export type MessagesGroupByOutputType = {
    id: string
    senderId: string
    receiverId: string
    content: string
    orderId: string | null
    createdAt: Date
    _count: MessagesCountAggregateOutputType | null
    _min: MessagesMinAggregateOutputType | null
    _max: MessagesMaxAggregateOutputType | null
  }

  type GetMessagesGroupByPayload<T extends messagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessagesGroupByOutputType[P]>
            : GetScalarType<T[P], MessagesGroupByOutputType[P]>
        }
      >
    >


  export type messagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    orderId?: boolean
    createdAt?: boolean
    users_messages_receiverIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_messages_senderIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type messagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    orderId?: boolean
    createdAt?: boolean
    users_messages_receiverIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_messages_senderIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type messagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    orderId?: boolean
    createdAt?: boolean
    users_messages_receiverIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_messages_senderIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type messagesSelectScalar = {
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    orderId?: boolean
    createdAt?: boolean
  }

  export type messagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "senderId" | "receiverId" | "content" | "orderId" | "createdAt", ExtArgs["result"]["messages"]>
  export type messagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_messages_receiverIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_messages_senderIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type messagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_messages_receiverIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_messages_senderIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type messagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_messages_receiverIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_messages_senderIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $messagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "messages"
    objects: {
      users_messages_receiverIdTousers: Prisma.$usersPayload<ExtArgs>
      users_messages_senderIdTousers: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      senderId: string
      receiverId: string
      content: string
      orderId: string | null
      createdAt: Date
    }, ExtArgs["result"]["messages"]>
    composites: {}
  }

  type messagesGetPayload<S extends boolean | null | undefined | messagesDefaultArgs> = $Result.GetResult<Prisma.$messagesPayload, S>

  type messagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<messagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessagesCountAggregateInputType | true
    }

  export interface messagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['messages'], meta: { name: 'messages' } }
    /**
     * Find zero or one Messages that matches the filter.
     * @param {messagesFindUniqueArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends messagesFindUniqueArgs>(args: SelectSubset<T, messagesFindUniqueArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Messages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {messagesFindUniqueOrThrowArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends messagesFindUniqueOrThrowArgs>(args: SelectSubset<T, messagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesFindFirstArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends messagesFindFirstArgs>(args?: SelectSubset<T, messagesFindFirstArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Messages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesFindFirstOrThrowArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends messagesFindFirstOrThrowArgs>(args?: SelectSubset<T, messagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.messages.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.messages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messagesWithIdOnly = await prisma.messages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends messagesFindManyArgs>(args?: SelectSubset<T, messagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Messages.
     * @param {messagesCreateArgs} args - Arguments to create a Messages.
     * @example
     * // Create one Messages
     * const Messages = await prisma.messages.create({
     *   data: {
     *     // ... data to create a Messages
     *   }
     * })
     * 
     */
    create<T extends messagesCreateArgs>(args: SelectSubset<T, messagesCreateArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {messagesCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const messages = await prisma.messages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends messagesCreateManyArgs>(args?: SelectSubset<T, messagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {messagesCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const messages = await prisma.messages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messagesWithIdOnly = await prisma.messages.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends messagesCreateManyAndReturnArgs>(args?: SelectSubset<T, messagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Messages.
     * @param {messagesDeleteArgs} args - Arguments to delete one Messages.
     * @example
     * // Delete one Messages
     * const Messages = await prisma.messages.delete({
     *   where: {
     *     // ... filter to delete one Messages
     *   }
     * })
     * 
     */
    delete<T extends messagesDeleteArgs>(args: SelectSubset<T, messagesDeleteArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Messages.
     * @param {messagesUpdateArgs} args - Arguments to update one Messages.
     * @example
     * // Update one Messages
     * const messages = await prisma.messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends messagesUpdateArgs>(args: SelectSubset<T, messagesUpdateArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {messagesDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends messagesDeleteManyArgs>(args?: SelectSubset<T, messagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const messages = await prisma.messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends messagesUpdateManyArgs>(args: SelectSubset<T, messagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {messagesUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const messages = await prisma.messages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messagesWithIdOnly = await prisma.messages.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends messagesUpdateManyAndReturnArgs>(args: SelectSubset<T, messagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Messages.
     * @param {messagesUpsertArgs} args - Arguments to update or create a Messages.
     * @example
     * // Update or create a Messages
     * const messages = await prisma.messages.upsert({
     *   create: {
     *     // ... data to create a Messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Messages we want to update
     *   }
     * })
     */
    upsert<T extends messagesUpsertArgs>(args: SelectSubset<T, messagesUpsertArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.messages.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends messagesCountArgs>(
      args?: Subset<T, messagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessagesAggregateArgs>(args: Subset<T, MessagesAggregateArgs>): Prisma.PrismaPromise<GetMessagesAggregateType<T>>

    /**
     * Group by Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends messagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: messagesGroupByArgs['orderBy'] }
        : { orderBy?: messagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, messagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the messages model
   */
  readonly fields: messagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__messagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_messages_receiverIdTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users_messages_senderIdTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the messages model
   */
  interface messagesFieldRefs {
    readonly id: FieldRef<"messages", 'String'>
    readonly senderId: FieldRef<"messages", 'String'>
    readonly receiverId: FieldRef<"messages", 'String'>
    readonly content: FieldRef<"messages", 'String'>
    readonly orderId: FieldRef<"messages", 'String'>
    readonly createdAt: FieldRef<"messages", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * messages findUnique
   */
  export type messagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages findUniqueOrThrow
   */
  export type messagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages findFirst
   */
  export type messagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * messages findFirstOrThrow
   */
  export type messagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * messages findMany
   */
  export type messagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing messages.
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * messages create
   */
  export type messagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * The data needed to create a messages.
     */
    data: XOR<messagesCreateInput, messagesUncheckedCreateInput>
  }

  /**
   * messages createMany
   */
  export type messagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many messages.
     */
    data: messagesCreateManyInput | messagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * messages createManyAndReturn
   */
  export type messagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * The data used to create many messages.
     */
    data: messagesCreateManyInput | messagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * messages update
   */
  export type messagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * The data needed to update a messages.
     */
    data: XOR<messagesUpdateInput, messagesUncheckedUpdateInput>
    /**
     * Choose, which messages to update.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages updateMany
   */
  export type messagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update messages.
     */
    data: XOR<messagesUpdateManyMutationInput, messagesUncheckedUpdateManyInput>
    /**
     * Filter which messages to update
     */
    where?: messagesWhereInput
    /**
     * Limit how many messages to update.
     */
    limit?: number
  }

  /**
   * messages updateManyAndReturn
   */
  export type messagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * The data used to update messages.
     */
    data: XOR<messagesUpdateManyMutationInput, messagesUncheckedUpdateManyInput>
    /**
     * Filter which messages to update
     */
    where?: messagesWhereInput
    /**
     * Limit how many messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * messages upsert
   */
  export type messagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * The filter to search for the messages to update in case it exists.
     */
    where: messagesWhereUniqueInput
    /**
     * In case the messages found by the `where` argument doesn't exist, create a new messages with this data.
     */
    create: XOR<messagesCreateInput, messagesUncheckedCreateInput>
    /**
     * In case the messages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<messagesUpdateInput, messagesUncheckedUpdateInput>
  }

  /**
   * messages delete
   */
  export type messagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter which messages to delete.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages deleteMany
   */
  export type messagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which messages to delete
     */
    where?: messagesWhereInput
    /**
     * Limit how many messages to delete.
     */
    limit?: number
  }

  /**
   * messages without action
   */
  export type messagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
  }


  /**
   * Model notification_preferences
   */

  export type AggregateNotification_preferences = {
    _count: Notification_preferencesCountAggregateOutputType | null
    _min: Notification_preferencesMinAggregateOutputType | null
    _max: Notification_preferencesMaxAggregateOutputType | null
  }

  export type Notification_preferencesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    pushEnabled: boolean | null
    emailEnabled: boolean | null
    smsEnabled: boolean | null
    orderUpdates: boolean | null
    messages: boolean | null
    promotions: boolean | null
    systemAlerts: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Notification_preferencesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    pushEnabled: boolean | null
    emailEnabled: boolean | null
    smsEnabled: boolean | null
    orderUpdates: boolean | null
    messages: boolean | null
    promotions: boolean | null
    systemAlerts: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Notification_preferencesCountAggregateOutputType = {
    id: number
    userId: number
    pushEnabled: number
    emailEnabled: number
    smsEnabled: number
    orderUpdates: number
    messages: number
    promotions: number
    systemAlerts: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Notification_preferencesMinAggregateInputType = {
    id?: true
    userId?: true
    pushEnabled?: true
    emailEnabled?: true
    smsEnabled?: true
    orderUpdates?: true
    messages?: true
    promotions?: true
    systemAlerts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Notification_preferencesMaxAggregateInputType = {
    id?: true
    userId?: true
    pushEnabled?: true
    emailEnabled?: true
    smsEnabled?: true
    orderUpdates?: true
    messages?: true
    promotions?: true
    systemAlerts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Notification_preferencesCountAggregateInputType = {
    id?: true
    userId?: true
    pushEnabled?: true
    emailEnabled?: true
    smsEnabled?: true
    orderUpdates?: true
    messages?: true
    promotions?: true
    systemAlerts?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Notification_preferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification_preferences to aggregate.
     */
    where?: notification_preferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_preferences to fetch.
     */
    orderBy?: notification_preferencesOrderByWithRelationInput | notification_preferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notification_preferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_preferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notification_preferences
    **/
    _count?: true | Notification_preferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Notification_preferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Notification_preferencesMaxAggregateInputType
  }

  export type GetNotification_preferencesAggregateType<T extends Notification_preferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification_preferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification_preferences[P]>
      : GetScalarType<T[P], AggregateNotification_preferences[P]>
  }




  export type notification_preferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notification_preferencesWhereInput
    orderBy?: notification_preferencesOrderByWithAggregationInput | notification_preferencesOrderByWithAggregationInput[]
    by: Notification_preferencesScalarFieldEnum[] | Notification_preferencesScalarFieldEnum
    having?: notification_preferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Notification_preferencesCountAggregateInputType | true
    _min?: Notification_preferencesMinAggregateInputType
    _max?: Notification_preferencesMaxAggregateInputType
  }

  export type Notification_preferencesGroupByOutputType = {
    id: string
    userId: string
    pushEnabled: boolean
    emailEnabled: boolean
    smsEnabled: boolean
    orderUpdates: boolean
    messages: boolean
    promotions: boolean
    systemAlerts: boolean
    createdAt: Date
    updatedAt: Date
    _count: Notification_preferencesCountAggregateOutputType | null
    _min: Notification_preferencesMinAggregateOutputType | null
    _max: Notification_preferencesMaxAggregateOutputType | null
  }

  type GetNotification_preferencesGroupByPayload<T extends notification_preferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Notification_preferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Notification_preferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Notification_preferencesGroupByOutputType[P]>
            : GetScalarType<T[P], Notification_preferencesGroupByOutputType[P]>
        }
      >
    >


  export type notification_preferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    pushEnabled?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    orderUpdates?: boolean
    messages?: boolean
    promotions?: boolean
    systemAlerts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification_preferences"]>

  export type notification_preferencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    pushEnabled?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    orderUpdates?: boolean
    messages?: boolean
    promotions?: boolean
    systemAlerts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification_preferences"]>

  export type notification_preferencesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    pushEnabled?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    orderUpdates?: boolean
    messages?: boolean
    promotions?: boolean
    systemAlerts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification_preferences"]>

  export type notification_preferencesSelectScalar = {
    id?: boolean
    userId?: boolean
    pushEnabled?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    orderUpdates?: boolean
    messages?: boolean
    promotions?: boolean
    systemAlerts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type notification_preferencesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "pushEnabled" | "emailEnabled" | "smsEnabled" | "orderUpdates" | "messages" | "promotions" | "systemAlerts" | "createdAt" | "updatedAt", ExtArgs["result"]["notification_preferences"]>
  export type notification_preferencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type notification_preferencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type notification_preferencesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $notification_preferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notification_preferences"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      pushEnabled: boolean
      emailEnabled: boolean
      smsEnabled: boolean
      orderUpdates: boolean
      messages: boolean
      promotions: boolean
      systemAlerts: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification_preferences"]>
    composites: {}
  }

  type notification_preferencesGetPayload<S extends boolean | null | undefined | notification_preferencesDefaultArgs> = $Result.GetResult<Prisma.$notification_preferencesPayload, S>

  type notification_preferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notification_preferencesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Notification_preferencesCountAggregateInputType | true
    }

  export interface notification_preferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notification_preferences'], meta: { name: 'notification_preferences' } }
    /**
     * Find zero or one Notification_preferences that matches the filter.
     * @param {notification_preferencesFindUniqueArgs} args - Arguments to find a Notification_preferences
     * @example
     * // Get one Notification_preferences
     * const notification_preferences = await prisma.notification_preferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notification_preferencesFindUniqueArgs>(args: SelectSubset<T, notification_preferencesFindUniqueArgs<ExtArgs>>): Prisma__notification_preferencesClient<$Result.GetResult<Prisma.$notification_preferencesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification_preferences that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notification_preferencesFindUniqueOrThrowArgs} args - Arguments to find a Notification_preferences
     * @example
     * // Get one Notification_preferences
     * const notification_preferences = await prisma.notification_preferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notification_preferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, notification_preferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notification_preferencesClient<$Result.GetResult<Prisma.$notification_preferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification_preferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_preferencesFindFirstArgs} args - Arguments to find a Notification_preferences
     * @example
     * // Get one Notification_preferences
     * const notification_preferences = await prisma.notification_preferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notification_preferencesFindFirstArgs>(args?: SelectSubset<T, notification_preferencesFindFirstArgs<ExtArgs>>): Prisma__notification_preferencesClient<$Result.GetResult<Prisma.$notification_preferencesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification_preferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_preferencesFindFirstOrThrowArgs} args - Arguments to find a Notification_preferences
     * @example
     * // Get one Notification_preferences
     * const notification_preferences = await prisma.notification_preferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notification_preferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, notification_preferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__notification_preferencesClient<$Result.GetResult<Prisma.$notification_preferencesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notification_preferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_preferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notification_preferences
     * const notification_preferences = await prisma.notification_preferences.findMany()
     * 
     * // Get first 10 Notification_preferences
     * const notification_preferences = await prisma.notification_preferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notification_preferencesWithIdOnly = await prisma.notification_preferences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notification_preferencesFindManyArgs>(args?: SelectSubset<T, notification_preferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notification_preferencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification_preferences.
     * @param {notification_preferencesCreateArgs} args - Arguments to create a Notification_preferences.
     * @example
     * // Create one Notification_preferences
     * const Notification_preferences = await prisma.notification_preferences.create({
     *   data: {
     *     // ... data to create a Notification_preferences
     *   }
     * })
     * 
     */
    create<T extends notification_preferencesCreateArgs>(args: SelectSubset<T, notification_preferencesCreateArgs<ExtArgs>>): Prisma__notification_preferencesClient<$Result.GetResult<Prisma.$notification_preferencesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notification_preferences.
     * @param {notification_preferencesCreateManyArgs} args - Arguments to create many Notification_preferences.
     * @example
     * // Create many Notification_preferences
     * const notification_preferences = await prisma.notification_preferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notification_preferencesCreateManyArgs>(args?: SelectSubset<T, notification_preferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notification_preferences and returns the data saved in the database.
     * @param {notification_preferencesCreateManyAndReturnArgs} args - Arguments to create many Notification_preferences.
     * @example
     * // Create many Notification_preferences
     * const notification_preferences = await prisma.notification_preferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notification_preferences and only return the `id`
     * const notification_preferencesWithIdOnly = await prisma.notification_preferences.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notification_preferencesCreateManyAndReturnArgs>(args?: SelectSubset<T, notification_preferencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notification_preferencesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification_preferences.
     * @param {notification_preferencesDeleteArgs} args - Arguments to delete one Notification_preferences.
     * @example
     * // Delete one Notification_preferences
     * const Notification_preferences = await prisma.notification_preferences.delete({
     *   where: {
     *     // ... filter to delete one Notification_preferences
     *   }
     * })
     * 
     */
    delete<T extends notification_preferencesDeleteArgs>(args: SelectSubset<T, notification_preferencesDeleteArgs<ExtArgs>>): Prisma__notification_preferencesClient<$Result.GetResult<Prisma.$notification_preferencesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification_preferences.
     * @param {notification_preferencesUpdateArgs} args - Arguments to update one Notification_preferences.
     * @example
     * // Update one Notification_preferences
     * const notification_preferences = await prisma.notification_preferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notification_preferencesUpdateArgs>(args: SelectSubset<T, notification_preferencesUpdateArgs<ExtArgs>>): Prisma__notification_preferencesClient<$Result.GetResult<Prisma.$notification_preferencesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notification_preferences.
     * @param {notification_preferencesDeleteManyArgs} args - Arguments to filter Notification_preferences to delete.
     * @example
     * // Delete a few Notification_preferences
     * const { count } = await prisma.notification_preferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notification_preferencesDeleteManyArgs>(args?: SelectSubset<T, notification_preferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notification_preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_preferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notification_preferences
     * const notification_preferences = await prisma.notification_preferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notification_preferencesUpdateManyArgs>(args: SelectSubset<T, notification_preferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notification_preferences and returns the data updated in the database.
     * @param {notification_preferencesUpdateManyAndReturnArgs} args - Arguments to update many Notification_preferences.
     * @example
     * // Update many Notification_preferences
     * const notification_preferences = await prisma.notification_preferences.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notification_preferences and only return the `id`
     * const notification_preferencesWithIdOnly = await prisma.notification_preferences.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notification_preferencesUpdateManyAndReturnArgs>(args: SelectSubset<T, notification_preferencesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notification_preferencesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification_preferences.
     * @param {notification_preferencesUpsertArgs} args - Arguments to update or create a Notification_preferences.
     * @example
     * // Update or create a Notification_preferences
     * const notification_preferences = await prisma.notification_preferences.upsert({
     *   create: {
     *     // ... data to create a Notification_preferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification_preferences we want to update
     *   }
     * })
     */
    upsert<T extends notification_preferencesUpsertArgs>(args: SelectSubset<T, notification_preferencesUpsertArgs<ExtArgs>>): Prisma__notification_preferencesClient<$Result.GetResult<Prisma.$notification_preferencesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notification_preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_preferencesCountArgs} args - Arguments to filter Notification_preferences to count.
     * @example
     * // Count the number of Notification_preferences
     * const count = await prisma.notification_preferences.count({
     *   where: {
     *     // ... the filter for the Notification_preferences we want to count
     *   }
     * })
    **/
    count<T extends notification_preferencesCountArgs>(
      args?: Subset<T, notification_preferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Notification_preferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification_preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Notification_preferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Notification_preferencesAggregateArgs>(args: Subset<T, Notification_preferencesAggregateArgs>): Prisma.PrismaPromise<GetNotification_preferencesAggregateType<T>>

    /**
     * Group by Notification_preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_preferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notification_preferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notification_preferencesGroupByArgs['orderBy'] }
        : { orderBy?: notification_preferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notification_preferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotification_preferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notification_preferences model
   */
  readonly fields: notification_preferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notification_preferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notification_preferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notification_preferences model
   */
  interface notification_preferencesFieldRefs {
    readonly id: FieldRef<"notification_preferences", 'String'>
    readonly userId: FieldRef<"notification_preferences", 'String'>
    readonly pushEnabled: FieldRef<"notification_preferences", 'Boolean'>
    readonly emailEnabled: FieldRef<"notification_preferences", 'Boolean'>
    readonly smsEnabled: FieldRef<"notification_preferences", 'Boolean'>
    readonly orderUpdates: FieldRef<"notification_preferences", 'Boolean'>
    readonly messages: FieldRef<"notification_preferences", 'Boolean'>
    readonly promotions: FieldRef<"notification_preferences", 'Boolean'>
    readonly systemAlerts: FieldRef<"notification_preferences", 'Boolean'>
    readonly createdAt: FieldRef<"notification_preferences", 'DateTime'>
    readonly updatedAt: FieldRef<"notification_preferences", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * notification_preferences findUnique
   */
  export type notification_preferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesInclude<ExtArgs> | null
    /**
     * Filter, which notification_preferences to fetch.
     */
    where: notification_preferencesWhereUniqueInput
  }

  /**
   * notification_preferences findUniqueOrThrow
   */
  export type notification_preferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesInclude<ExtArgs> | null
    /**
     * Filter, which notification_preferences to fetch.
     */
    where: notification_preferencesWhereUniqueInput
  }

  /**
   * notification_preferences findFirst
   */
  export type notification_preferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesInclude<ExtArgs> | null
    /**
     * Filter, which notification_preferences to fetch.
     */
    where?: notification_preferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_preferences to fetch.
     */
    orderBy?: notification_preferencesOrderByWithRelationInput | notification_preferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notification_preferences.
     */
    cursor?: notification_preferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_preferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notification_preferences.
     */
    distinct?: Notification_preferencesScalarFieldEnum | Notification_preferencesScalarFieldEnum[]
  }

  /**
   * notification_preferences findFirstOrThrow
   */
  export type notification_preferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesInclude<ExtArgs> | null
    /**
     * Filter, which notification_preferences to fetch.
     */
    where?: notification_preferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_preferences to fetch.
     */
    orderBy?: notification_preferencesOrderByWithRelationInput | notification_preferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notification_preferences.
     */
    cursor?: notification_preferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_preferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notification_preferences.
     */
    distinct?: Notification_preferencesScalarFieldEnum | Notification_preferencesScalarFieldEnum[]
  }

  /**
   * notification_preferences findMany
   */
  export type notification_preferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesInclude<ExtArgs> | null
    /**
     * Filter, which notification_preferences to fetch.
     */
    where?: notification_preferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_preferences to fetch.
     */
    orderBy?: notification_preferencesOrderByWithRelationInput | notification_preferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notification_preferences.
     */
    cursor?: notification_preferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_preferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_preferences.
     */
    skip?: number
    distinct?: Notification_preferencesScalarFieldEnum | Notification_preferencesScalarFieldEnum[]
  }

  /**
   * notification_preferences create
   */
  export type notification_preferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a notification_preferences.
     */
    data: XOR<notification_preferencesCreateInput, notification_preferencesUncheckedCreateInput>
  }

  /**
   * notification_preferences createMany
   */
  export type notification_preferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notification_preferences.
     */
    data: notification_preferencesCreateManyInput | notification_preferencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notification_preferences createManyAndReturn
   */
  export type notification_preferencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * The data used to create many notification_preferences.
     */
    data: notification_preferencesCreateManyInput | notification_preferencesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notification_preferences update
   */
  export type notification_preferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a notification_preferences.
     */
    data: XOR<notification_preferencesUpdateInput, notification_preferencesUncheckedUpdateInput>
    /**
     * Choose, which notification_preferences to update.
     */
    where: notification_preferencesWhereUniqueInput
  }

  /**
   * notification_preferences updateMany
   */
  export type notification_preferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notification_preferences.
     */
    data: XOR<notification_preferencesUpdateManyMutationInput, notification_preferencesUncheckedUpdateManyInput>
    /**
     * Filter which notification_preferences to update
     */
    where?: notification_preferencesWhereInput
    /**
     * Limit how many notification_preferences to update.
     */
    limit?: number
  }

  /**
   * notification_preferences updateManyAndReturn
   */
  export type notification_preferencesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * The data used to update notification_preferences.
     */
    data: XOR<notification_preferencesUpdateManyMutationInput, notification_preferencesUncheckedUpdateManyInput>
    /**
     * Filter which notification_preferences to update
     */
    where?: notification_preferencesWhereInput
    /**
     * Limit how many notification_preferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * notification_preferences upsert
   */
  export type notification_preferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the notification_preferences to update in case it exists.
     */
    where: notification_preferencesWhereUniqueInput
    /**
     * In case the notification_preferences found by the `where` argument doesn't exist, create a new notification_preferences with this data.
     */
    create: XOR<notification_preferencesCreateInput, notification_preferencesUncheckedCreateInput>
    /**
     * In case the notification_preferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notification_preferencesUpdateInput, notification_preferencesUncheckedUpdateInput>
  }

  /**
   * notification_preferences delete
   */
  export type notification_preferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesInclude<ExtArgs> | null
    /**
     * Filter which notification_preferences to delete.
     */
    where: notification_preferencesWhereUniqueInput
  }

  /**
   * notification_preferences deleteMany
   */
  export type notification_preferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification_preferences to delete
     */
    where?: notification_preferencesWhereInput
    /**
     * Limit how many notification_preferences to delete.
     */
    limit?: number
  }

  /**
   * notification_preferences without action
   */
  export type notification_preferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesInclude<ExtArgs> | null
  }


  /**
   * Model notification_tokens
   */

  export type AggregateNotification_tokens = {
    _count: Notification_tokensCountAggregateOutputType | null
    _min: Notification_tokensMinAggregateOutputType | null
    _max: Notification_tokensMaxAggregateOutputType | null
  }

  export type Notification_tokensMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    platform: string | null
    createdAt: Date | null
  }

  export type Notification_tokensMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    platform: string | null
    createdAt: Date | null
  }

  export type Notification_tokensCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    platform: number
    createdAt: number
    _all: number
  }


  export type Notification_tokensMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    platform?: true
    createdAt?: true
  }

  export type Notification_tokensMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    platform?: true
    createdAt?: true
  }

  export type Notification_tokensCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    platform?: true
    createdAt?: true
    _all?: true
  }

  export type Notification_tokensAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification_tokens to aggregate.
     */
    where?: notification_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_tokens to fetch.
     */
    orderBy?: notification_tokensOrderByWithRelationInput | notification_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notification_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notification_tokens
    **/
    _count?: true | Notification_tokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Notification_tokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Notification_tokensMaxAggregateInputType
  }

  export type GetNotification_tokensAggregateType<T extends Notification_tokensAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification_tokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification_tokens[P]>
      : GetScalarType<T[P], AggregateNotification_tokens[P]>
  }




  export type notification_tokensGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notification_tokensWhereInput
    orderBy?: notification_tokensOrderByWithAggregationInput | notification_tokensOrderByWithAggregationInput[]
    by: Notification_tokensScalarFieldEnum[] | Notification_tokensScalarFieldEnum
    having?: notification_tokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Notification_tokensCountAggregateInputType | true
    _min?: Notification_tokensMinAggregateInputType
    _max?: Notification_tokensMaxAggregateInputType
  }

  export type Notification_tokensGroupByOutputType = {
    id: string
    userId: string
    token: string
    platform: string | null
    createdAt: Date
    _count: Notification_tokensCountAggregateOutputType | null
    _min: Notification_tokensMinAggregateOutputType | null
    _max: Notification_tokensMaxAggregateOutputType | null
  }

  type GetNotification_tokensGroupByPayload<T extends notification_tokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Notification_tokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Notification_tokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Notification_tokensGroupByOutputType[P]>
            : GetScalarType<T[P], Notification_tokensGroupByOutputType[P]>
        }
      >
    >


  export type notification_tokensSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    platform?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification_tokens"]>

  export type notification_tokensSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    platform?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification_tokens"]>

  export type notification_tokensSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    platform?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification_tokens"]>

  export type notification_tokensSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    platform?: boolean
    createdAt?: boolean
  }

  export type notification_tokensOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "platform" | "createdAt", ExtArgs["result"]["notification_tokens"]>
  export type notification_tokensInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type notification_tokensIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type notification_tokensIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $notification_tokensPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notification_tokens"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      platform: string | null
      createdAt: Date
    }, ExtArgs["result"]["notification_tokens"]>
    composites: {}
  }

  type notification_tokensGetPayload<S extends boolean | null | undefined | notification_tokensDefaultArgs> = $Result.GetResult<Prisma.$notification_tokensPayload, S>

  type notification_tokensCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notification_tokensFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Notification_tokensCountAggregateInputType | true
    }

  export interface notification_tokensDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notification_tokens'], meta: { name: 'notification_tokens' } }
    /**
     * Find zero or one Notification_tokens that matches the filter.
     * @param {notification_tokensFindUniqueArgs} args - Arguments to find a Notification_tokens
     * @example
     * // Get one Notification_tokens
     * const notification_tokens = await prisma.notification_tokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notification_tokensFindUniqueArgs>(args: SelectSubset<T, notification_tokensFindUniqueArgs<ExtArgs>>): Prisma__notification_tokensClient<$Result.GetResult<Prisma.$notification_tokensPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification_tokens that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notification_tokensFindUniqueOrThrowArgs} args - Arguments to find a Notification_tokens
     * @example
     * // Get one Notification_tokens
     * const notification_tokens = await prisma.notification_tokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notification_tokensFindUniqueOrThrowArgs>(args: SelectSubset<T, notification_tokensFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notification_tokensClient<$Result.GetResult<Prisma.$notification_tokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_tokensFindFirstArgs} args - Arguments to find a Notification_tokens
     * @example
     * // Get one Notification_tokens
     * const notification_tokens = await prisma.notification_tokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notification_tokensFindFirstArgs>(args?: SelectSubset<T, notification_tokensFindFirstArgs<ExtArgs>>): Prisma__notification_tokensClient<$Result.GetResult<Prisma.$notification_tokensPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification_tokens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_tokensFindFirstOrThrowArgs} args - Arguments to find a Notification_tokens
     * @example
     * // Get one Notification_tokens
     * const notification_tokens = await prisma.notification_tokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notification_tokensFindFirstOrThrowArgs>(args?: SelectSubset<T, notification_tokensFindFirstOrThrowArgs<ExtArgs>>): Prisma__notification_tokensClient<$Result.GetResult<Prisma.$notification_tokensPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notification_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_tokensFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notification_tokens
     * const notification_tokens = await prisma.notification_tokens.findMany()
     * 
     * // Get first 10 Notification_tokens
     * const notification_tokens = await prisma.notification_tokens.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notification_tokensWithIdOnly = await prisma.notification_tokens.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notification_tokensFindManyArgs>(args?: SelectSubset<T, notification_tokensFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notification_tokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification_tokens.
     * @param {notification_tokensCreateArgs} args - Arguments to create a Notification_tokens.
     * @example
     * // Create one Notification_tokens
     * const Notification_tokens = await prisma.notification_tokens.create({
     *   data: {
     *     // ... data to create a Notification_tokens
     *   }
     * })
     * 
     */
    create<T extends notification_tokensCreateArgs>(args: SelectSubset<T, notification_tokensCreateArgs<ExtArgs>>): Prisma__notification_tokensClient<$Result.GetResult<Prisma.$notification_tokensPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notification_tokens.
     * @param {notification_tokensCreateManyArgs} args - Arguments to create many Notification_tokens.
     * @example
     * // Create many Notification_tokens
     * const notification_tokens = await prisma.notification_tokens.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notification_tokensCreateManyArgs>(args?: SelectSubset<T, notification_tokensCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notification_tokens and returns the data saved in the database.
     * @param {notification_tokensCreateManyAndReturnArgs} args - Arguments to create many Notification_tokens.
     * @example
     * // Create many Notification_tokens
     * const notification_tokens = await prisma.notification_tokens.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notification_tokens and only return the `id`
     * const notification_tokensWithIdOnly = await prisma.notification_tokens.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notification_tokensCreateManyAndReturnArgs>(args?: SelectSubset<T, notification_tokensCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notification_tokensPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification_tokens.
     * @param {notification_tokensDeleteArgs} args - Arguments to delete one Notification_tokens.
     * @example
     * // Delete one Notification_tokens
     * const Notification_tokens = await prisma.notification_tokens.delete({
     *   where: {
     *     // ... filter to delete one Notification_tokens
     *   }
     * })
     * 
     */
    delete<T extends notification_tokensDeleteArgs>(args: SelectSubset<T, notification_tokensDeleteArgs<ExtArgs>>): Prisma__notification_tokensClient<$Result.GetResult<Prisma.$notification_tokensPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification_tokens.
     * @param {notification_tokensUpdateArgs} args - Arguments to update one Notification_tokens.
     * @example
     * // Update one Notification_tokens
     * const notification_tokens = await prisma.notification_tokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notification_tokensUpdateArgs>(args: SelectSubset<T, notification_tokensUpdateArgs<ExtArgs>>): Prisma__notification_tokensClient<$Result.GetResult<Prisma.$notification_tokensPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notification_tokens.
     * @param {notification_tokensDeleteManyArgs} args - Arguments to filter Notification_tokens to delete.
     * @example
     * // Delete a few Notification_tokens
     * const { count } = await prisma.notification_tokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notification_tokensDeleteManyArgs>(args?: SelectSubset<T, notification_tokensDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notification_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_tokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notification_tokens
     * const notification_tokens = await prisma.notification_tokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notification_tokensUpdateManyArgs>(args: SelectSubset<T, notification_tokensUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notification_tokens and returns the data updated in the database.
     * @param {notification_tokensUpdateManyAndReturnArgs} args - Arguments to update many Notification_tokens.
     * @example
     * // Update many Notification_tokens
     * const notification_tokens = await prisma.notification_tokens.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notification_tokens and only return the `id`
     * const notification_tokensWithIdOnly = await prisma.notification_tokens.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notification_tokensUpdateManyAndReturnArgs>(args: SelectSubset<T, notification_tokensUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notification_tokensPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification_tokens.
     * @param {notification_tokensUpsertArgs} args - Arguments to update or create a Notification_tokens.
     * @example
     * // Update or create a Notification_tokens
     * const notification_tokens = await prisma.notification_tokens.upsert({
     *   create: {
     *     // ... data to create a Notification_tokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification_tokens we want to update
     *   }
     * })
     */
    upsert<T extends notification_tokensUpsertArgs>(args: SelectSubset<T, notification_tokensUpsertArgs<ExtArgs>>): Prisma__notification_tokensClient<$Result.GetResult<Prisma.$notification_tokensPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notification_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_tokensCountArgs} args - Arguments to filter Notification_tokens to count.
     * @example
     * // Count the number of Notification_tokens
     * const count = await prisma.notification_tokens.count({
     *   where: {
     *     // ... the filter for the Notification_tokens we want to count
     *   }
     * })
    **/
    count<T extends notification_tokensCountArgs>(
      args?: Subset<T, notification_tokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Notification_tokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Notification_tokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Notification_tokensAggregateArgs>(args: Subset<T, Notification_tokensAggregateArgs>): Prisma.PrismaPromise<GetNotification_tokensAggregateType<T>>

    /**
     * Group by Notification_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_tokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notification_tokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notification_tokensGroupByArgs['orderBy'] }
        : { orderBy?: notification_tokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notification_tokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotification_tokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notification_tokens model
   */
  readonly fields: notification_tokensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notification_tokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notification_tokensClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notification_tokens model
   */
  interface notification_tokensFieldRefs {
    readonly id: FieldRef<"notification_tokens", 'String'>
    readonly userId: FieldRef<"notification_tokens", 'String'>
    readonly token: FieldRef<"notification_tokens", 'String'>
    readonly platform: FieldRef<"notification_tokens", 'String'>
    readonly createdAt: FieldRef<"notification_tokens", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * notification_tokens findUnique
   */
  export type notification_tokensFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_tokens
     */
    select?: notification_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_tokens
     */
    omit?: notification_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_tokensInclude<ExtArgs> | null
    /**
     * Filter, which notification_tokens to fetch.
     */
    where: notification_tokensWhereUniqueInput
  }

  /**
   * notification_tokens findUniqueOrThrow
   */
  export type notification_tokensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_tokens
     */
    select?: notification_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_tokens
     */
    omit?: notification_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_tokensInclude<ExtArgs> | null
    /**
     * Filter, which notification_tokens to fetch.
     */
    where: notification_tokensWhereUniqueInput
  }

  /**
   * notification_tokens findFirst
   */
  export type notification_tokensFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_tokens
     */
    select?: notification_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_tokens
     */
    omit?: notification_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_tokensInclude<ExtArgs> | null
    /**
     * Filter, which notification_tokens to fetch.
     */
    where?: notification_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_tokens to fetch.
     */
    orderBy?: notification_tokensOrderByWithRelationInput | notification_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notification_tokens.
     */
    cursor?: notification_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notification_tokens.
     */
    distinct?: Notification_tokensScalarFieldEnum | Notification_tokensScalarFieldEnum[]
  }

  /**
   * notification_tokens findFirstOrThrow
   */
  export type notification_tokensFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_tokens
     */
    select?: notification_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_tokens
     */
    omit?: notification_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_tokensInclude<ExtArgs> | null
    /**
     * Filter, which notification_tokens to fetch.
     */
    where?: notification_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_tokens to fetch.
     */
    orderBy?: notification_tokensOrderByWithRelationInput | notification_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notification_tokens.
     */
    cursor?: notification_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notification_tokens.
     */
    distinct?: Notification_tokensScalarFieldEnum | Notification_tokensScalarFieldEnum[]
  }

  /**
   * notification_tokens findMany
   */
  export type notification_tokensFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_tokens
     */
    select?: notification_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_tokens
     */
    omit?: notification_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_tokensInclude<ExtArgs> | null
    /**
     * Filter, which notification_tokens to fetch.
     */
    where?: notification_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_tokens to fetch.
     */
    orderBy?: notification_tokensOrderByWithRelationInput | notification_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notification_tokens.
     */
    cursor?: notification_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_tokens.
     */
    skip?: number
    distinct?: Notification_tokensScalarFieldEnum | Notification_tokensScalarFieldEnum[]
  }

  /**
   * notification_tokens create
   */
  export type notification_tokensCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_tokens
     */
    select?: notification_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_tokens
     */
    omit?: notification_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_tokensInclude<ExtArgs> | null
    /**
     * The data needed to create a notification_tokens.
     */
    data: XOR<notification_tokensCreateInput, notification_tokensUncheckedCreateInput>
  }

  /**
   * notification_tokens createMany
   */
  export type notification_tokensCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notification_tokens.
     */
    data: notification_tokensCreateManyInput | notification_tokensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notification_tokens createManyAndReturn
   */
  export type notification_tokensCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_tokens
     */
    select?: notification_tokensSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notification_tokens
     */
    omit?: notification_tokensOmit<ExtArgs> | null
    /**
     * The data used to create many notification_tokens.
     */
    data: notification_tokensCreateManyInput | notification_tokensCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_tokensIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notification_tokens update
   */
  export type notification_tokensUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_tokens
     */
    select?: notification_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_tokens
     */
    omit?: notification_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_tokensInclude<ExtArgs> | null
    /**
     * The data needed to update a notification_tokens.
     */
    data: XOR<notification_tokensUpdateInput, notification_tokensUncheckedUpdateInput>
    /**
     * Choose, which notification_tokens to update.
     */
    where: notification_tokensWhereUniqueInput
  }

  /**
   * notification_tokens updateMany
   */
  export type notification_tokensUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notification_tokens.
     */
    data: XOR<notification_tokensUpdateManyMutationInput, notification_tokensUncheckedUpdateManyInput>
    /**
     * Filter which notification_tokens to update
     */
    where?: notification_tokensWhereInput
    /**
     * Limit how many notification_tokens to update.
     */
    limit?: number
  }

  /**
   * notification_tokens updateManyAndReturn
   */
  export type notification_tokensUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_tokens
     */
    select?: notification_tokensSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notification_tokens
     */
    omit?: notification_tokensOmit<ExtArgs> | null
    /**
     * The data used to update notification_tokens.
     */
    data: XOR<notification_tokensUpdateManyMutationInput, notification_tokensUncheckedUpdateManyInput>
    /**
     * Filter which notification_tokens to update
     */
    where?: notification_tokensWhereInput
    /**
     * Limit how many notification_tokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_tokensIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * notification_tokens upsert
   */
  export type notification_tokensUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_tokens
     */
    select?: notification_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_tokens
     */
    omit?: notification_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_tokensInclude<ExtArgs> | null
    /**
     * The filter to search for the notification_tokens to update in case it exists.
     */
    where: notification_tokensWhereUniqueInput
    /**
     * In case the notification_tokens found by the `where` argument doesn't exist, create a new notification_tokens with this data.
     */
    create: XOR<notification_tokensCreateInput, notification_tokensUncheckedCreateInput>
    /**
     * In case the notification_tokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notification_tokensUpdateInput, notification_tokensUncheckedUpdateInput>
  }

  /**
   * notification_tokens delete
   */
  export type notification_tokensDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_tokens
     */
    select?: notification_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_tokens
     */
    omit?: notification_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_tokensInclude<ExtArgs> | null
    /**
     * Filter which notification_tokens to delete.
     */
    where: notification_tokensWhereUniqueInput
  }

  /**
   * notification_tokens deleteMany
   */
  export type notification_tokensDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification_tokens to delete
     */
    where?: notification_tokensWhereInput
    /**
     * Limit how many notification_tokens to delete.
     */
    limit?: number
  }

  /**
   * notification_tokens without action
   */
  export type notification_tokensDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_tokens
     */
    select?: notification_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_tokens
     */
    omit?: notification_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_tokensInclude<ExtArgs> | null
  }


  /**
   * Model notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    body: string | null
    type: string | null
    status: string | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    body: string | null
    type: string | null
    status: string | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    body: number
    data: number
    type: number
    status: number
    readAt: number
    createdAt: number
    _all: number
  }


  export type NotificationsMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    body?: true
    type?: true
    status?: true
    readAt?: true
    createdAt?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    body?: true
    type?: true
    status?: true
    readAt?: true
    createdAt?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    body?: true
    data?: true
    type?: true
    status?: true
    readAt?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to aggregate.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithAggregationInput | notificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: string
    userId: string
    title: string
    body: string
    data: JsonValue | null
    type: string
    status: string
    readAt: Date | null
    createdAt: Date
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    type?: boolean
    status?: boolean
    readAt?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    type?: boolean
    status?: boolean
    readAt?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    type?: boolean
    status?: boolean
    readAt?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    type?: boolean
    status?: boolean
    readAt?: boolean
    createdAt?: boolean
  }

  export type notificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "body" | "data" | "type" | "status" | "readAt" | "createdAt", ExtArgs["result"]["notifications"]>
  export type notificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type notificationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type notificationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notifications"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      body: string
      data: Prisma.JsonValue | null
      type: string
      status: string
      readAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type notificationsGetPayload<S extends boolean | null | undefined | notificationsDefaultArgs> = $Result.GetResult<Prisma.$notificationsPayload, S>

  type notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notifications'], meta: { name: 'notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {notificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationsFindUniqueArgs>(args: SelectSubset<T, notificationsFindUniqueArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationsFindFirstArgs>(args?: SelectSubset<T, notificationsFindFirstArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationsFindManyArgs>(args?: SelectSubset<T, notificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notifications.
     * @param {notificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends notificationsCreateArgs>(args: SelectSubset<T, notificationsCreateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {notificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationsCreateManyArgs>(args?: SelectSubset<T, notificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {notificationsCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, notificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notifications.
     * @param {notificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends notificationsDeleteArgs>(args: SelectSubset<T, notificationsDeleteArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notifications.
     * @param {notificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationsUpdateArgs>(args: SelectSubset<T, notificationsUpdateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {notificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationsDeleteManyArgs>(args?: SelectSubset<T, notificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationsUpdateManyArgs>(args: SelectSubset<T, notificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {notificationsUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notificationsUpdateManyAndReturnArgs>(args: SelectSubset<T, notificationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notifications.
     * @param {notificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends notificationsUpsertArgs>(args: SelectSubset<T, notificationsUpsertArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationsCountArgs>(
      args?: Subset<T, notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationsGroupByArgs['orderBy'] }
        : { orderBy?: notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notifications model
   */
  readonly fields: notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notifications model
   */
  interface notificationsFieldRefs {
    readonly id: FieldRef<"notifications", 'String'>
    readonly userId: FieldRef<"notifications", 'String'>
    readonly title: FieldRef<"notifications", 'String'>
    readonly body: FieldRef<"notifications", 'String'>
    readonly data: FieldRef<"notifications", 'Json'>
    readonly type: FieldRef<"notifications", 'String'>
    readonly status: FieldRef<"notifications", 'String'>
    readonly readAt: FieldRef<"notifications", 'DateTime'>
    readonly createdAt: FieldRef<"notifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * notifications findUnique
   */
  export type notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findUniqueOrThrow
   */
  export type notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findFirst
   */
  export type notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findFirstOrThrow
   */
  export type notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findMany
   */
  export type notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications create
   */
  export type notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a notifications.
     */
    data: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
  }

  /**
   * notifications createMany
   */
  export type notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notifications createManyAndReturn
   */
  export type notificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notifications update
   */
  export type notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a notifications.
     */
    data: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
    /**
     * Choose, which notifications to update.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications updateMany
   */
  export type notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
  }

  /**
   * notifications updateManyAndReturn
   */
  export type notificationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * notifications upsert
   */
  export type notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the notifications to update in case it exists.
     */
    where: notificationsWhereUniqueInput
    /**
     * In case the notifications found by the `where` argument doesn't exist, create a new notifications with this data.
     */
    create: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
    /**
     * In case the notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
  }

  /**
   * notifications delete
   */
  export type notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter which notifications to delete.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications deleteMany
   */
  export type notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to delete.
     */
    limit?: number
  }

  /**
   * notifications without action
   */
  export type notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
  }


  /**
   * Model orders
   */

  export type AggregateOrders = {
    _count: OrdersCountAggregateOutputType | null
    _avg: OrdersAvgAggregateOutputType | null
    _sum: OrdersSumAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  export type OrdersAvgAggregateOutputType = {
    totalAmount: number | null
    commission: number | null
  }

  export type OrdersSumAggregateOutputType = {
    totalAmount: number | null
    commission: number | null
  }

  export type OrdersMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    providerId: string | null
    serviceId: string | null
    status: $Enums.OrderStatus | null
    totalAmount: number | null
    commission: number | null
    serviceDate: Date | null
    address: string | null
    notes: string | null
    cancelledBy: string | null
    cancelReason: string | null
    cancelledAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrdersMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    providerId: string | null
    serviceId: string | null
    status: $Enums.OrderStatus | null
    totalAmount: number | null
    commission: number | null
    serviceDate: Date | null
    address: string | null
    notes: string | null
    cancelledBy: string | null
    cancelReason: string | null
    cancelledAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrdersCountAggregateOutputType = {
    id: number
    customerId: number
    providerId: number
    serviceId: number
    status: number
    totalAmount: number
    commission: number
    serviceDate: number
    address: number
    notes: number
    cancelledBy: number
    cancelReason: number
    cancelledAt: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrdersAvgAggregateInputType = {
    totalAmount?: true
    commission?: true
  }

  export type OrdersSumAggregateInputType = {
    totalAmount?: true
    commission?: true
  }

  export type OrdersMinAggregateInputType = {
    id?: true
    customerId?: true
    providerId?: true
    serviceId?: true
    status?: true
    totalAmount?: true
    commission?: true
    serviceDate?: true
    address?: true
    notes?: true
    cancelledBy?: true
    cancelReason?: true
    cancelledAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrdersMaxAggregateInputType = {
    id?: true
    customerId?: true
    providerId?: true
    serviceId?: true
    status?: true
    totalAmount?: true
    commission?: true
    serviceDate?: true
    address?: true
    notes?: true
    cancelledBy?: true
    cancelReason?: true
    cancelledAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrdersCountAggregateInputType = {
    id?: true
    customerId?: true
    providerId?: true
    serviceId?: true
    status?: true
    totalAmount?: true
    commission?: true
    serviceDate?: true
    address?: true
    notes?: true
    cancelledBy?: true
    cancelReason?: true
    cancelledAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrdersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orders to aggregate.
     */
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orders
    **/
    _count?: true | OrdersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrdersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrdersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrdersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrdersMaxAggregateInputType
  }

  export type GetOrdersAggregateType<T extends OrdersAggregateArgs> = {
        [P in keyof T & keyof AggregateOrders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrders[P]>
      : GetScalarType<T[P], AggregateOrders[P]>
  }




  export type ordersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ordersWhereInput
    orderBy?: ordersOrderByWithAggregationInput | ordersOrderByWithAggregationInput[]
    by: OrdersScalarFieldEnum[] | OrdersScalarFieldEnum
    having?: ordersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrdersCountAggregateInputType | true
    _avg?: OrdersAvgAggregateInputType
    _sum?: OrdersSumAggregateInputType
    _min?: OrdersMinAggregateInputType
    _max?: OrdersMaxAggregateInputType
  }

  export type OrdersGroupByOutputType = {
    id: string
    customerId: string
    providerId: string
    serviceId: string
    status: $Enums.OrderStatus
    totalAmount: number
    commission: number
    serviceDate: Date
    address: string
    notes: string | null
    cancelledBy: string | null
    cancelReason: string | null
    cancelledAt: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: OrdersCountAggregateOutputType | null
    _avg: OrdersAvgAggregateOutputType | null
    _sum: OrdersSumAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  type GetOrdersGroupByPayload<T extends ordersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrdersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrdersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrdersGroupByOutputType[P]>
            : GetScalarType<T[P], OrdersGroupByOutputType[P]>
        }
      >
    >


  export type ordersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    providerId?: boolean
    serviceId?: boolean
    status?: boolean
    totalAmount?: boolean
    commission?: boolean
    serviceDate?: boolean
    address?: boolean
    notes?: boolean
    cancelledBy?: boolean
    cancelReason?: boolean
    cancelledAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    call_sessions?: boolean | orders$call_sessionsArgs<ExtArgs>
    users_orders_customerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_orders_providerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    services?: boolean | servicesDefaultArgs<ExtArgs>
    reviews?: boolean | orders$reviewsArgs<ExtArgs>
    virtual_assignments?: boolean | orders$virtual_assignmentsArgs<ExtArgs>
    _count?: boolean | OrdersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orders"]>

  export type ordersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    providerId?: boolean
    serviceId?: boolean
    status?: boolean
    totalAmount?: boolean
    commission?: boolean
    serviceDate?: boolean
    address?: boolean
    notes?: boolean
    cancelledBy?: boolean
    cancelReason?: boolean
    cancelledAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_orders_customerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_orders_providerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    services?: boolean | servicesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orders"]>

  export type ordersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    providerId?: boolean
    serviceId?: boolean
    status?: boolean
    totalAmount?: boolean
    commission?: boolean
    serviceDate?: boolean
    address?: boolean
    notes?: boolean
    cancelledBy?: boolean
    cancelReason?: boolean
    cancelledAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_orders_customerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_orders_providerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    services?: boolean | servicesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orders"]>

  export type ordersSelectScalar = {
    id?: boolean
    customerId?: boolean
    providerId?: boolean
    serviceId?: boolean
    status?: boolean
    totalAmount?: boolean
    commission?: boolean
    serviceDate?: boolean
    address?: boolean
    notes?: boolean
    cancelledBy?: boolean
    cancelReason?: boolean
    cancelledAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ordersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "providerId" | "serviceId" | "status" | "totalAmount" | "commission" | "serviceDate" | "address" | "notes" | "cancelledBy" | "cancelReason" | "cancelledAt" | "completedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["orders"]>
  export type ordersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    call_sessions?: boolean | orders$call_sessionsArgs<ExtArgs>
    users_orders_customerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_orders_providerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    services?: boolean | servicesDefaultArgs<ExtArgs>
    reviews?: boolean | orders$reviewsArgs<ExtArgs>
    virtual_assignments?: boolean | orders$virtual_assignmentsArgs<ExtArgs>
    _count?: boolean | OrdersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ordersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_orders_customerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_orders_providerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    services?: boolean | servicesDefaultArgs<ExtArgs>
  }
  export type ordersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_orders_customerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_orders_providerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    services?: boolean | servicesDefaultArgs<ExtArgs>
  }

  export type $ordersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "orders"
    objects: {
      call_sessions: Prisma.$call_sessionsPayload<ExtArgs>[]
      users_orders_customerIdTousers: Prisma.$usersPayload<ExtArgs>
      users_orders_providerIdTousers: Prisma.$usersPayload<ExtArgs>
      services: Prisma.$servicesPayload<ExtArgs>
      reviews: Prisma.$reviewsPayload<ExtArgs> | null
      virtual_assignments: Prisma.$virtual_assignmentsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      providerId: string
      serviceId: string
      status: $Enums.OrderStatus
      totalAmount: number
      commission: number
      serviceDate: Date
      address: string
      notes: string | null
      cancelledBy: string | null
      cancelReason: string | null
      cancelledAt: Date | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["orders"]>
    composites: {}
  }

  type ordersGetPayload<S extends boolean | null | undefined | ordersDefaultArgs> = $Result.GetResult<Prisma.$ordersPayload, S>

  type ordersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ordersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrdersCountAggregateInputType | true
    }

  export interface ordersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['orders'], meta: { name: 'orders' } }
    /**
     * Find zero or one Orders that matches the filter.
     * @param {ordersFindUniqueArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ordersFindUniqueArgs>(args: SelectSubset<T, ordersFindUniqueArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Orders that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ordersFindUniqueOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ordersFindUniqueOrThrowArgs>(args: SelectSubset<T, ordersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersFindFirstArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ordersFindFirstArgs>(args?: SelectSubset<T, ordersFindFirstArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Orders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersFindFirstOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ordersFindFirstOrThrowArgs>(args?: SelectSubset<T, ordersFindFirstOrThrowArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.orders.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.orders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ordersWithIdOnly = await prisma.orders.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ordersFindManyArgs>(args?: SelectSubset<T, ordersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Orders.
     * @param {ordersCreateArgs} args - Arguments to create a Orders.
     * @example
     * // Create one Orders
     * const Orders = await prisma.orders.create({
     *   data: {
     *     // ... data to create a Orders
     *   }
     * })
     * 
     */
    create<T extends ordersCreateArgs>(args: SelectSubset<T, ordersCreateArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {ordersCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const orders = await prisma.orders.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ordersCreateManyArgs>(args?: SelectSubset<T, ordersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {ordersCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const orders = await prisma.orders.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const ordersWithIdOnly = await prisma.orders.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ordersCreateManyAndReturnArgs>(args?: SelectSubset<T, ordersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Orders.
     * @param {ordersDeleteArgs} args - Arguments to delete one Orders.
     * @example
     * // Delete one Orders
     * const Orders = await prisma.orders.delete({
     *   where: {
     *     // ... filter to delete one Orders
     *   }
     * })
     * 
     */
    delete<T extends ordersDeleteArgs>(args: SelectSubset<T, ordersDeleteArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Orders.
     * @param {ordersUpdateArgs} args - Arguments to update one Orders.
     * @example
     * // Update one Orders
     * const orders = await prisma.orders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ordersUpdateArgs>(args: SelectSubset<T, ordersUpdateArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {ordersDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.orders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ordersDeleteManyArgs>(args?: SelectSubset<T, ordersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const orders = await prisma.orders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ordersUpdateManyArgs>(args: SelectSubset<T, ordersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {ordersUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const orders = await prisma.orders.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const ordersWithIdOnly = await prisma.orders.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ordersUpdateManyAndReturnArgs>(args: SelectSubset<T, ordersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Orders.
     * @param {ordersUpsertArgs} args - Arguments to update or create a Orders.
     * @example
     * // Update or create a Orders
     * const orders = await prisma.orders.upsert({
     *   create: {
     *     // ... data to create a Orders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Orders we want to update
     *   }
     * })
     */
    upsert<T extends ordersUpsertArgs>(args: SelectSubset<T, ordersUpsertArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.orders.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends ordersCountArgs>(
      args?: Subset<T, ordersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrdersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrdersAggregateArgs>(args: Subset<T, OrdersAggregateArgs>): Prisma.PrismaPromise<GetOrdersAggregateType<T>>

    /**
     * Group by Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ordersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ordersGroupByArgs['orderBy'] }
        : { orderBy?: ordersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ordersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrdersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the orders model
   */
  readonly fields: ordersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for orders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ordersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    call_sessions<T extends orders$call_sessionsArgs<ExtArgs> = {}>(args?: Subset<T, orders$call_sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$call_sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users_orders_customerIdTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users_orders_providerIdTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    services<T extends servicesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, servicesDefaultArgs<ExtArgs>>): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviews<T extends orders$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, orders$reviewsArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    virtual_assignments<T extends orders$virtual_assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, orders$virtual_assignmentsArgs<ExtArgs>>): Prisma__virtual_assignmentsClient<$Result.GetResult<Prisma.$virtual_assignmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the orders model
   */
  interface ordersFieldRefs {
    readonly id: FieldRef<"orders", 'String'>
    readonly customerId: FieldRef<"orders", 'String'>
    readonly providerId: FieldRef<"orders", 'String'>
    readonly serviceId: FieldRef<"orders", 'String'>
    readonly status: FieldRef<"orders", 'OrderStatus'>
    readonly totalAmount: FieldRef<"orders", 'Float'>
    readonly commission: FieldRef<"orders", 'Float'>
    readonly serviceDate: FieldRef<"orders", 'DateTime'>
    readonly address: FieldRef<"orders", 'String'>
    readonly notes: FieldRef<"orders", 'String'>
    readonly cancelledBy: FieldRef<"orders", 'String'>
    readonly cancelReason: FieldRef<"orders", 'String'>
    readonly cancelledAt: FieldRef<"orders", 'DateTime'>
    readonly completedAt: FieldRef<"orders", 'DateTime'>
    readonly createdAt: FieldRef<"orders", 'DateTime'>
    readonly updatedAt: FieldRef<"orders", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * orders findUnique
   */
  export type ordersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where: ordersWhereUniqueInput
  }

  /**
   * orders findUniqueOrThrow
   */
  export type ordersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where: ordersWhereUniqueInput
  }

  /**
   * orders findFirst
   */
  export type ordersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     */
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     */
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * orders findFirstOrThrow
   */
  export type ordersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     */
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     */
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * orders findMany
   */
  export type ordersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orders.
     */
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * orders create
   */
  export type ordersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * The data needed to create a orders.
     */
    data: XOR<ordersCreateInput, ordersUncheckedCreateInput>
  }

  /**
   * orders createMany
   */
  export type ordersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many orders.
     */
    data: ordersCreateManyInput | ordersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * orders createManyAndReturn
   */
  export type ordersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * The data used to create many orders.
     */
    data: ordersCreateManyInput | ordersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * orders update
   */
  export type ordersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * The data needed to update a orders.
     */
    data: XOR<ordersUpdateInput, ordersUncheckedUpdateInput>
    /**
     * Choose, which orders to update.
     */
    where: ordersWhereUniqueInput
  }

  /**
   * orders updateMany
   */
  export type ordersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update orders.
     */
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyInput>
    /**
     * Filter which orders to update
     */
    where?: ordersWhereInput
    /**
     * Limit how many orders to update.
     */
    limit?: number
  }

  /**
   * orders updateManyAndReturn
   */
  export type ordersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * The data used to update orders.
     */
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyInput>
    /**
     * Filter which orders to update
     */
    where?: ordersWhereInput
    /**
     * Limit how many orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * orders upsert
   */
  export type ordersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * The filter to search for the orders to update in case it exists.
     */
    where: ordersWhereUniqueInput
    /**
     * In case the orders found by the `where` argument doesn't exist, create a new orders with this data.
     */
    create: XOR<ordersCreateInput, ordersUncheckedCreateInput>
    /**
     * In case the orders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ordersUpdateInput, ordersUncheckedUpdateInput>
  }

  /**
   * orders delete
   */
  export type ordersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * Filter which orders to delete.
     */
    where: ordersWhereUniqueInput
  }

  /**
   * orders deleteMany
   */
  export type ordersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orders to delete
     */
    where?: ordersWhereInput
    /**
     * Limit how many orders to delete.
     */
    limit?: number
  }

  /**
   * orders.call_sessions
   */
  export type orders$call_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_sessions
     */
    select?: call_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the call_sessions
     */
    omit?: call_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_sessionsInclude<ExtArgs> | null
    where?: call_sessionsWhereInput
    orderBy?: call_sessionsOrderByWithRelationInput | call_sessionsOrderByWithRelationInput[]
    cursor?: call_sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Call_sessionsScalarFieldEnum | Call_sessionsScalarFieldEnum[]
  }

  /**
   * orders.reviews
   */
  export type orders$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    where?: reviewsWhereInput
  }

  /**
   * orders.virtual_assignments
   */
  export type orders$virtual_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_assignments
     */
    select?: virtual_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_assignments
     */
    omit?: virtual_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: virtual_assignmentsInclude<ExtArgs> | null
    where?: virtual_assignmentsWhereInput
  }

  /**
   * orders without action
   */
  export type ordersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
  }


  /**
   * Model otps
   */

  export type AggregateOtps = {
    _count: OtpsCountAggregateOutputType | null
    _min: OtpsMinAggregateOutputType | null
    _max: OtpsMaxAggregateOutputType | null
  }

  export type OtpsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    code: string | null
    type: string | null
    isUsed: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type OtpsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    code: string | null
    type: string | null
    isUsed: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type OtpsCountAggregateOutputType = {
    id: number
    userId: number
    code: number
    type: number
    isUsed: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type OtpsMinAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    type?: true
    isUsed?: true
    expiresAt?: true
    createdAt?: true
  }

  export type OtpsMaxAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    type?: true
    isUsed?: true
    expiresAt?: true
    createdAt?: true
  }

  export type OtpsCountAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    type?: true
    isUsed?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type OtpsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which otps to aggregate.
     */
    where?: otpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otps to fetch.
     */
    orderBy?: otpsOrderByWithRelationInput | otpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: otpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned otps
    **/
    _count?: true | OtpsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpsMaxAggregateInputType
  }

  export type GetOtpsAggregateType<T extends OtpsAggregateArgs> = {
        [P in keyof T & keyof AggregateOtps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtps[P]>
      : GetScalarType<T[P], AggregateOtps[P]>
  }




  export type otpsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: otpsWhereInput
    orderBy?: otpsOrderByWithAggregationInput | otpsOrderByWithAggregationInput[]
    by: OtpsScalarFieldEnum[] | OtpsScalarFieldEnum
    having?: otpsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpsCountAggregateInputType | true
    _min?: OtpsMinAggregateInputType
    _max?: OtpsMaxAggregateInputType
  }

  export type OtpsGroupByOutputType = {
    id: string
    userId: string
    code: string
    type: string
    isUsed: boolean
    expiresAt: Date
    createdAt: Date
    _count: OtpsCountAggregateOutputType | null
    _min: OtpsMinAggregateOutputType | null
    _max: OtpsMaxAggregateOutputType | null
  }

  type GetOtpsGroupByPayload<T extends otpsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpsGroupByOutputType[P]>
            : GetScalarType<T[P], OtpsGroupByOutputType[P]>
        }
      >
    >


  export type otpsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    code?: boolean
    type?: boolean
    isUsed?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["otps"]>

  export type otpsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    code?: boolean
    type?: boolean
    isUsed?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["otps"]>

  export type otpsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    code?: boolean
    type?: boolean
    isUsed?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["otps"]>

  export type otpsSelectScalar = {
    id?: boolean
    userId?: boolean
    code?: boolean
    type?: boolean
    isUsed?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type otpsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "code" | "type" | "isUsed" | "expiresAt" | "createdAt", ExtArgs["result"]["otps"]>
  export type otpsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type otpsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type otpsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $otpsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "otps"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      code: string
      type: string
      isUsed: boolean
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["otps"]>
    composites: {}
  }

  type otpsGetPayload<S extends boolean | null | undefined | otpsDefaultArgs> = $Result.GetResult<Prisma.$otpsPayload, S>

  type otpsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<otpsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OtpsCountAggregateInputType | true
    }

  export interface otpsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['otps'], meta: { name: 'otps' } }
    /**
     * Find zero or one Otps that matches the filter.
     * @param {otpsFindUniqueArgs} args - Arguments to find a Otps
     * @example
     * // Get one Otps
     * const otps = await prisma.otps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends otpsFindUniqueArgs>(args: SelectSubset<T, otpsFindUniqueArgs<ExtArgs>>): Prisma__otpsClient<$Result.GetResult<Prisma.$otpsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Otps that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {otpsFindUniqueOrThrowArgs} args - Arguments to find a Otps
     * @example
     * // Get one Otps
     * const otps = await prisma.otps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends otpsFindUniqueOrThrowArgs>(args: SelectSubset<T, otpsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__otpsClient<$Result.GetResult<Prisma.$otpsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpsFindFirstArgs} args - Arguments to find a Otps
     * @example
     * // Get one Otps
     * const otps = await prisma.otps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends otpsFindFirstArgs>(args?: SelectSubset<T, otpsFindFirstArgs<ExtArgs>>): Prisma__otpsClient<$Result.GetResult<Prisma.$otpsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otps that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpsFindFirstOrThrowArgs} args - Arguments to find a Otps
     * @example
     * // Get one Otps
     * const otps = await prisma.otps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends otpsFindFirstOrThrowArgs>(args?: SelectSubset<T, otpsFindFirstOrThrowArgs<ExtArgs>>): Prisma__otpsClient<$Result.GetResult<Prisma.$otpsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Otps
     * const otps = await prisma.otps.findMany()
     * 
     * // Get first 10 Otps
     * const otps = await prisma.otps.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otpsWithIdOnly = await prisma.otps.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends otpsFindManyArgs>(args?: SelectSubset<T, otpsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$otpsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Otps.
     * @param {otpsCreateArgs} args - Arguments to create a Otps.
     * @example
     * // Create one Otps
     * const Otps = await prisma.otps.create({
     *   data: {
     *     // ... data to create a Otps
     *   }
     * })
     * 
     */
    create<T extends otpsCreateArgs>(args: SelectSubset<T, otpsCreateArgs<ExtArgs>>): Prisma__otpsClient<$Result.GetResult<Prisma.$otpsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Otps.
     * @param {otpsCreateManyArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otps = await prisma.otps.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends otpsCreateManyArgs>(args?: SelectSubset<T, otpsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Otps and returns the data saved in the database.
     * @param {otpsCreateManyAndReturnArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otps = await prisma.otps.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Otps and only return the `id`
     * const otpsWithIdOnly = await prisma.otps.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends otpsCreateManyAndReturnArgs>(args?: SelectSubset<T, otpsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$otpsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Otps.
     * @param {otpsDeleteArgs} args - Arguments to delete one Otps.
     * @example
     * // Delete one Otps
     * const Otps = await prisma.otps.delete({
     *   where: {
     *     // ... filter to delete one Otps
     *   }
     * })
     * 
     */
    delete<T extends otpsDeleteArgs>(args: SelectSubset<T, otpsDeleteArgs<ExtArgs>>): Prisma__otpsClient<$Result.GetResult<Prisma.$otpsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Otps.
     * @param {otpsUpdateArgs} args - Arguments to update one Otps.
     * @example
     * // Update one Otps
     * const otps = await prisma.otps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends otpsUpdateArgs>(args: SelectSubset<T, otpsUpdateArgs<ExtArgs>>): Prisma__otpsClient<$Result.GetResult<Prisma.$otpsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Otps.
     * @param {otpsDeleteManyArgs} args - Arguments to filter Otps to delete.
     * @example
     * // Delete a few Otps
     * const { count } = await prisma.otps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends otpsDeleteManyArgs>(args?: SelectSubset<T, otpsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Otps
     * const otps = await prisma.otps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends otpsUpdateManyArgs>(args: SelectSubset<T, otpsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps and returns the data updated in the database.
     * @param {otpsUpdateManyAndReturnArgs} args - Arguments to update many Otps.
     * @example
     * // Update many Otps
     * const otps = await prisma.otps.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Otps and only return the `id`
     * const otpsWithIdOnly = await prisma.otps.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends otpsUpdateManyAndReturnArgs>(args: SelectSubset<T, otpsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$otpsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Otps.
     * @param {otpsUpsertArgs} args - Arguments to update or create a Otps.
     * @example
     * // Update or create a Otps
     * const otps = await prisma.otps.upsert({
     *   create: {
     *     // ... data to create a Otps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Otps we want to update
     *   }
     * })
     */
    upsert<T extends otpsUpsertArgs>(args: SelectSubset<T, otpsUpsertArgs<ExtArgs>>): Prisma__otpsClient<$Result.GetResult<Prisma.$otpsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpsCountArgs} args - Arguments to filter Otps to count.
     * @example
     * // Count the number of Otps
     * const count = await prisma.otps.count({
     *   where: {
     *     // ... the filter for the Otps we want to count
     *   }
     * })
    **/
    count<T extends otpsCountArgs>(
      args?: Subset<T, otpsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpsAggregateArgs>(args: Subset<T, OtpsAggregateArgs>): Prisma.PrismaPromise<GetOtpsAggregateType<T>>

    /**
     * Group by Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends otpsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: otpsGroupByArgs['orderBy'] }
        : { orderBy?: otpsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, otpsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the otps model
   */
  readonly fields: otpsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for otps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__otpsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the otps model
   */
  interface otpsFieldRefs {
    readonly id: FieldRef<"otps", 'String'>
    readonly userId: FieldRef<"otps", 'String'>
    readonly code: FieldRef<"otps", 'String'>
    readonly type: FieldRef<"otps", 'String'>
    readonly isUsed: FieldRef<"otps", 'Boolean'>
    readonly expiresAt: FieldRef<"otps", 'DateTime'>
    readonly createdAt: FieldRef<"otps", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * otps findUnique
   */
  export type otpsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpsInclude<ExtArgs> | null
    /**
     * Filter, which otps to fetch.
     */
    where: otpsWhereUniqueInput
  }

  /**
   * otps findUniqueOrThrow
   */
  export type otpsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpsInclude<ExtArgs> | null
    /**
     * Filter, which otps to fetch.
     */
    where: otpsWhereUniqueInput
  }

  /**
   * otps findFirst
   */
  export type otpsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpsInclude<ExtArgs> | null
    /**
     * Filter, which otps to fetch.
     */
    where?: otpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otps to fetch.
     */
    orderBy?: otpsOrderByWithRelationInput | otpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for otps.
     */
    cursor?: otpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of otps.
     */
    distinct?: OtpsScalarFieldEnum | OtpsScalarFieldEnum[]
  }

  /**
   * otps findFirstOrThrow
   */
  export type otpsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpsInclude<ExtArgs> | null
    /**
     * Filter, which otps to fetch.
     */
    where?: otpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otps to fetch.
     */
    orderBy?: otpsOrderByWithRelationInput | otpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for otps.
     */
    cursor?: otpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of otps.
     */
    distinct?: OtpsScalarFieldEnum | OtpsScalarFieldEnum[]
  }

  /**
   * otps findMany
   */
  export type otpsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpsInclude<ExtArgs> | null
    /**
     * Filter, which otps to fetch.
     */
    where?: otpsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otps to fetch.
     */
    orderBy?: otpsOrderByWithRelationInput | otpsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing otps.
     */
    cursor?: otpsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otps.
     */
    skip?: number
    distinct?: OtpsScalarFieldEnum | OtpsScalarFieldEnum[]
  }

  /**
   * otps create
   */
  export type otpsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpsInclude<ExtArgs> | null
    /**
     * The data needed to create a otps.
     */
    data: XOR<otpsCreateInput, otpsUncheckedCreateInput>
  }

  /**
   * otps createMany
   */
  export type otpsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many otps.
     */
    data: otpsCreateManyInput | otpsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * otps createManyAndReturn
   */
  export type otpsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
    /**
     * The data used to create many otps.
     */
    data: otpsCreateManyInput | otpsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * otps update
   */
  export type otpsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpsInclude<ExtArgs> | null
    /**
     * The data needed to update a otps.
     */
    data: XOR<otpsUpdateInput, otpsUncheckedUpdateInput>
    /**
     * Choose, which otps to update.
     */
    where: otpsWhereUniqueInput
  }

  /**
   * otps updateMany
   */
  export type otpsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update otps.
     */
    data: XOR<otpsUpdateManyMutationInput, otpsUncheckedUpdateManyInput>
    /**
     * Filter which otps to update
     */
    where?: otpsWhereInput
    /**
     * Limit how many otps to update.
     */
    limit?: number
  }

  /**
   * otps updateManyAndReturn
   */
  export type otpsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
    /**
     * The data used to update otps.
     */
    data: XOR<otpsUpdateManyMutationInput, otpsUncheckedUpdateManyInput>
    /**
     * Filter which otps to update
     */
    where?: otpsWhereInput
    /**
     * Limit how many otps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * otps upsert
   */
  export type otpsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpsInclude<ExtArgs> | null
    /**
     * The filter to search for the otps to update in case it exists.
     */
    where: otpsWhereUniqueInput
    /**
     * In case the otps found by the `where` argument doesn't exist, create a new otps with this data.
     */
    create: XOR<otpsCreateInput, otpsUncheckedCreateInput>
    /**
     * In case the otps was found with the provided `where` argument, update it with this data.
     */
    update: XOR<otpsUpdateInput, otpsUncheckedUpdateInput>
  }

  /**
   * otps delete
   */
  export type otpsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpsInclude<ExtArgs> | null
    /**
     * Filter which otps to delete.
     */
    where: otpsWhereUniqueInput
  }

  /**
   * otps deleteMany
   */
  export type otpsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which otps to delete
     */
    where?: otpsWhereInput
    /**
     * Limit how many otps to delete.
     */
    limit?: number
  }

  /**
   * otps without action
   */
  export type otpsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpsInclude<ExtArgs> | null
  }


  /**
   * Model payment_orders
   */

  export type AggregatePayment_orders = {
    _count: Payment_ordersCountAggregateOutputType | null
    _avg: Payment_ordersAvgAggregateOutputType | null
    _sum: Payment_ordersSumAggregateOutputType | null
    _min: Payment_ordersMinAggregateOutputType | null
    _max: Payment_ordersMaxAggregateOutputType | null
  }

  export type Payment_ordersAvgAggregateOutputType = {
    amount: number | null
  }

  export type Payment_ordersSumAggregateOutputType = {
    amount: number | null
  }

  export type Payment_ordersMinAggregateOutputType = {
    id: string | null
    userId: string | null
    orderId: string | null
    paymentId: string | null
    amount: number | null
    currency: string | null
    paymentMethod: string | null
    status: string | null
    type: string | null
    signature: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Payment_ordersMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    orderId: string | null
    paymentId: string | null
    amount: number | null
    currency: string | null
    paymentMethod: string | null
    status: string | null
    type: string | null
    signature: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Payment_ordersCountAggregateOutputType = {
    id: number
    userId: number
    orderId: number
    paymentId: number
    amount: number
    currency: number
    paymentMethod: number
    status: number
    type: number
    signature: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Payment_ordersAvgAggregateInputType = {
    amount?: true
  }

  export type Payment_ordersSumAggregateInputType = {
    amount?: true
  }

  export type Payment_ordersMinAggregateInputType = {
    id?: true
    userId?: true
    orderId?: true
    paymentId?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    status?: true
    type?: true
    signature?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Payment_ordersMaxAggregateInputType = {
    id?: true
    userId?: true
    orderId?: true
    paymentId?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    status?: true
    type?: true
    signature?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Payment_ordersCountAggregateInputType = {
    id?: true
    userId?: true
    orderId?: true
    paymentId?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    status?: true
    type?: true
    signature?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Payment_ordersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_orders to aggregate.
     */
    where?: payment_ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_orders to fetch.
     */
    orderBy?: payment_ordersOrderByWithRelationInput | payment_ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: payment_ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payment_orders
    **/
    _count?: true | Payment_ordersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Payment_ordersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Payment_ordersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Payment_ordersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Payment_ordersMaxAggregateInputType
  }

  export type GetPayment_ordersAggregateType<T extends Payment_ordersAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment_orders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment_orders[P]>
      : GetScalarType<T[P], AggregatePayment_orders[P]>
  }




  export type payment_ordersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_ordersWhereInput
    orderBy?: payment_ordersOrderByWithAggregationInput | payment_ordersOrderByWithAggregationInput[]
    by: Payment_ordersScalarFieldEnum[] | Payment_ordersScalarFieldEnum
    having?: payment_ordersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Payment_ordersCountAggregateInputType | true
    _avg?: Payment_ordersAvgAggregateInputType
    _sum?: Payment_ordersSumAggregateInputType
    _min?: Payment_ordersMinAggregateInputType
    _max?: Payment_ordersMaxAggregateInputType
  }

  export type Payment_ordersGroupByOutputType = {
    id: string
    userId: string
    orderId: string
    paymentId: string | null
    amount: number
    currency: string
    paymentMethod: string
    status: string
    type: string
    signature: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: Payment_ordersCountAggregateOutputType | null
    _avg: Payment_ordersAvgAggregateOutputType | null
    _sum: Payment_ordersSumAggregateOutputType | null
    _min: Payment_ordersMinAggregateOutputType | null
    _max: Payment_ordersMaxAggregateOutputType | null
  }

  type GetPayment_ordersGroupByPayload<T extends payment_ordersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Payment_ordersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Payment_ordersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Payment_ordersGroupByOutputType[P]>
            : GetScalarType<T[P], Payment_ordersGroupByOutputType[P]>
        }
      >
    >


  export type payment_ordersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orderId?: boolean
    paymentId?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    status?: boolean
    type?: boolean
    signature?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment_orders"]>

  export type payment_ordersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orderId?: boolean
    paymentId?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    status?: boolean
    type?: boolean
    signature?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment_orders"]>

  export type payment_ordersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orderId?: boolean
    paymentId?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    status?: boolean
    type?: boolean
    signature?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment_orders"]>

  export type payment_ordersSelectScalar = {
    id?: boolean
    userId?: boolean
    orderId?: boolean
    paymentId?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    status?: boolean
    type?: boolean
    signature?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type payment_ordersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "orderId" | "paymentId" | "amount" | "currency" | "paymentMethod" | "status" | "type" | "signature" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["payment_orders"]>
  export type payment_ordersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type payment_ordersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type payment_ordersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $payment_ordersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment_orders"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      orderId: string
      paymentId: string | null
      amount: number
      currency: string
      paymentMethod: string
      status: string
      type: string
      signature: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment_orders"]>
    composites: {}
  }

  type payment_ordersGetPayload<S extends boolean | null | undefined | payment_ordersDefaultArgs> = $Result.GetResult<Prisma.$payment_ordersPayload, S>

  type payment_ordersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<payment_ordersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Payment_ordersCountAggregateInputType | true
    }

  export interface payment_ordersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment_orders'], meta: { name: 'payment_orders' } }
    /**
     * Find zero or one Payment_orders that matches the filter.
     * @param {payment_ordersFindUniqueArgs} args - Arguments to find a Payment_orders
     * @example
     * // Get one Payment_orders
     * const payment_orders = await prisma.payment_orders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends payment_ordersFindUniqueArgs>(args: SelectSubset<T, payment_ordersFindUniqueArgs<ExtArgs>>): Prisma__payment_ordersClient<$Result.GetResult<Prisma.$payment_ordersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment_orders that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {payment_ordersFindUniqueOrThrowArgs} args - Arguments to find a Payment_orders
     * @example
     * // Get one Payment_orders
     * const payment_orders = await prisma.payment_orders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends payment_ordersFindUniqueOrThrowArgs>(args: SelectSubset<T, payment_ordersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__payment_ordersClient<$Result.GetResult<Prisma.$payment_ordersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_ordersFindFirstArgs} args - Arguments to find a Payment_orders
     * @example
     * // Get one Payment_orders
     * const payment_orders = await prisma.payment_orders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends payment_ordersFindFirstArgs>(args?: SelectSubset<T, payment_ordersFindFirstArgs<ExtArgs>>): Prisma__payment_ordersClient<$Result.GetResult<Prisma.$payment_ordersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment_orders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_ordersFindFirstOrThrowArgs} args - Arguments to find a Payment_orders
     * @example
     * // Get one Payment_orders
     * const payment_orders = await prisma.payment_orders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends payment_ordersFindFirstOrThrowArgs>(args?: SelectSubset<T, payment_ordersFindFirstOrThrowArgs<ExtArgs>>): Prisma__payment_ordersClient<$Result.GetResult<Prisma.$payment_ordersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payment_orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_ordersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payment_orders
     * const payment_orders = await prisma.payment_orders.findMany()
     * 
     * // Get first 10 Payment_orders
     * const payment_orders = await prisma.payment_orders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payment_ordersWithIdOnly = await prisma.payment_orders.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends payment_ordersFindManyArgs>(args?: SelectSubset<T, payment_ordersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment_orders.
     * @param {payment_ordersCreateArgs} args - Arguments to create a Payment_orders.
     * @example
     * // Create one Payment_orders
     * const Payment_orders = await prisma.payment_orders.create({
     *   data: {
     *     // ... data to create a Payment_orders
     *   }
     * })
     * 
     */
    create<T extends payment_ordersCreateArgs>(args: SelectSubset<T, payment_ordersCreateArgs<ExtArgs>>): Prisma__payment_ordersClient<$Result.GetResult<Prisma.$payment_ordersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payment_orders.
     * @param {payment_ordersCreateManyArgs} args - Arguments to create many Payment_orders.
     * @example
     * // Create many Payment_orders
     * const payment_orders = await prisma.payment_orders.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends payment_ordersCreateManyArgs>(args?: SelectSubset<T, payment_ordersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payment_orders and returns the data saved in the database.
     * @param {payment_ordersCreateManyAndReturnArgs} args - Arguments to create many Payment_orders.
     * @example
     * // Create many Payment_orders
     * const payment_orders = await prisma.payment_orders.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payment_orders and only return the `id`
     * const payment_ordersWithIdOnly = await prisma.payment_orders.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends payment_ordersCreateManyAndReturnArgs>(args?: SelectSubset<T, payment_ordersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_ordersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment_orders.
     * @param {payment_ordersDeleteArgs} args - Arguments to delete one Payment_orders.
     * @example
     * // Delete one Payment_orders
     * const Payment_orders = await prisma.payment_orders.delete({
     *   where: {
     *     // ... filter to delete one Payment_orders
     *   }
     * })
     * 
     */
    delete<T extends payment_ordersDeleteArgs>(args: SelectSubset<T, payment_ordersDeleteArgs<ExtArgs>>): Prisma__payment_ordersClient<$Result.GetResult<Prisma.$payment_ordersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment_orders.
     * @param {payment_ordersUpdateArgs} args - Arguments to update one Payment_orders.
     * @example
     * // Update one Payment_orders
     * const payment_orders = await prisma.payment_orders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends payment_ordersUpdateArgs>(args: SelectSubset<T, payment_ordersUpdateArgs<ExtArgs>>): Prisma__payment_ordersClient<$Result.GetResult<Prisma.$payment_ordersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payment_orders.
     * @param {payment_ordersDeleteManyArgs} args - Arguments to filter Payment_orders to delete.
     * @example
     * // Delete a few Payment_orders
     * const { count } = await prisma.payment_orders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends payment_ordersDeleteManyArgs>(args?: SelectSubset<T, payment_ordersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_ordersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payment_orders
     * const payment_orders = await prisma.payment_orders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends payment_ordersUpdateManyArgs>(args: SelectSubset<T, payment_ordersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_orders and returns the data updated in the database.
     * @param {payment_ordersUpdateManyAndReturnArgs} args - Arguments to update many Payment_orders.
     * @example
     * // Update many Payment_orders
     * const payment_orders = await prisma.payment_orders.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payment_orders and only return the `id`
     * const payment_ordersWithIdOnly = await prisma.payment_orders.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends payment_ordersUpdateManyAndReturnArgs>(args: SelectSubset<T, payment_ordersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_ordersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment_orders.
     * @param {payment_ordersUpsertArgs} args - Arguments to update or create a Payment_orders.
     * @example
     * // Update or create a Payment_orders
     * const payment_orders = await prisma.payment_orders.upsert({
     *   create: {
     *     // ... data to create a Payment_orders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment_orders we want to update
     *   }
     * })
     */
    upsert<T extends payment_ordersUpsertArgs>(args: SelectSubset<T, payment_ordersUpsertArgs<ExtArgs>>): Prisma__payment_ordersClient<$Result.GetResult<Prisma.$payment_ordersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payment_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_ordersCountArgs} args - Arguments to filter Payment_orders to count.
     * @example
     * // Count the number of Payment_orders
     * const count = await prisma.payment_orders.count({
     *   where: {
     *     // ... the filter for the Payment_orders we want to count
     *   }
     * })
    **/
    count<T extends payment_ordersCountArgs>(
      args?: Subset<T, payment_ordersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Payment_ordersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_ordersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Payment_ordersAggregateArgs>(args: Subset<T, Payment_ordersAggregateArgs>): Prisma.PrismaPromise<GetPayment_ordersAggregateType<T>>

    /**
     * Group by Payment_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_ordersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends payment_ordersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payment_ordersGroupByArgs['orderBy'] }
        : { orderBy?: payment_ordersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, payment_ordersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayment_ordersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment_orders model
   */
  readonly fields: payment_ordersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment_orders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payment_ordersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment_orders model
   */
  interface payment_ordersFieldRefs {
    readonly id: FieldRef<"payment_orders", 'String'>
    readonly userId: FieldRef<"payment_orders", 'String'>
    readonly orderId: FieldRef<"payment_orders", 'String'>
    readonly paymentId: FieldRef<"payment_orders", 'String'>
    readonly amount: FieldRef<"payment_orders", 'Float'>
    readonly currency: FieldRef<"payment_orders", 'String'>
    readonly paymentMethod: FieldRef<"payment_orders", 'String'>
    readonly status: FieldRef<"payment_orders", 'String'>
    readonly type: FieldRef<"payment_orders", 'String'>
    readonly signature: FieldRef<"payment_orders", 'String'>
    readonly metadata: FieldRef<"payment_orders", 'Json'>
    readonly createdAt: FieldRef<"payment_orders", 'DateTime'>
    readonly updatedAt: FieldRef<"payment_orders", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * payment_orders findUnique
   */
  export type payment_ordersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_orders
     */
    select?: payment_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_orders
     */
    omit?: payment_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_ordersInclude<ExtArgs> | null
    /**
     * Filter, which payment_orders to fetch.
     */
    where: payment_ordersWhereUniqueInput
  }

  /**
   * payment_orders findUniqueOrThrow
   */
  export type payment_ordersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_orders
     */
    select?: payment_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_orders
     */
    omit?: payment_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_ordersInclude<ExtArgs> | null
    /**
     * Filter, which payment_orders to fetch.
     */
    where: payment_ordersWhereUniqueInput
  }

  /**
   * payment_orders findFirst
   */
  export type payment_ordersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_orders
     */
    select?: payment_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_orders
     */
    omit?: payment_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_ordersInclude<ExtArgs> | null
    /**
     * Filter, which payment_orders to fetch.
     */
    where?: payment_ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_orders to fetch.
     */
    orderBy?: payment_ordersOrderByWithRelationInput | payment_ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_orders.
     */
    cursor?: payment_ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_orders.
     */
    distinct?: Payment_ordersScalarFieldEnum | Payment_ordersScalarFieldEnum[]
  }

  /**
   * payment_orders findFirstOrThrow
   */
  export type payment_ordersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_orders
     */
    select?: payment_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_orders
     */
    omit?: payment_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_ordersInclude<ExtArgs> | null
    /**
     * Filter, which payment_orders to fetch.
     */
    where?: payment_ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_orders to fetch.
     */
    orderBy?: payment_ordersOrderByWithRelationInput | payment_ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_orders.
     */
    cursor?: payment_ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_orders.
     */
    distinct?: Payment_ordersScalarFieldEnum | Payment_ordersScalarFieldEnum[]
  }

  /**
   * payment_orders findMany
   */
  export type payment_ordersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_orders
     */
    select?: payment_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_orders
     */
    omit?: payment_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_ordersInclude<ExtArgs> | null
    /**
     * Filter, which payment_orders to fetch.
     */
    where?: payment_ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_orders to fetch.
     */
    orderBy?: payment_ordersOrderByWithRelationInput | payment_ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payment_orders.
     */
    cursor?: payment_ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_orders.
     */
    skip?: number
    distinct?: Payment_ordersScalarFieldEnum | Payment_ordersScalarFieldEnum[]
  }

  /**
   * payment_orders create
   */
  export type payment_ordersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_orders
     */
    select?: payment_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_orders
     */
    omit?: payment_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_ordersInclude<ExtArgs> | null
    /**
     * The data needed to create a payment_orders.
     */
    data: XOR<payment_ordersCreateInput, payment_ordersUncheckedCreateInput>
  }

  /**
   * payment_orders createMany
   */
  export type payment_ordersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payment_orders.
     */
    data: payment_ordersCreateManyInput | payment_ordersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment_orders createManyAndReturn
   */
  export type payment_ordersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_orders
     */
    select?: payment_ordersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_orders
     */
    omit?: payment_ordersOmit<ExtArgs> | null
    /**
     * The data used to create many payment_orders.
     */
    data: payment_ordersCreateManyInput | payment_ordersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_ordersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment_orders update
   */
  export type payment_ordersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_orders
     */
    select?: payment_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_orders
     */
    omit?: payment_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_ordersInclude<ExtArgs> | null
    /**
     * The data needed to update a payment_orders.
     */
    data: XOR<payment_ordersUpdateInput, payment_ordersUncheckedUpdateInput>
    /**
     * Choose, which payment_orders to update.
     */
    where: payment_ordersWhereUniqueInput
  }

  /**
   * payment_orders updateMany
   */
  export type payment_ordersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payment_orders.
     */
    data: XOR<payment_ordersUpdateManyMutationInput, payment_ordersUncheckedUpdateManyInput>
    /**
     * Filter which payment_orders to update
     */
    where?: payment_ordersWhereInput
    /**
     * Limit how many payment_orders to update.
     */
    limit?: number
  }

  /**
   * payment_orders updateManyAndReturn
   */
  export type payment_ordersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_orders
     */
    select?: payment_ordersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment_orders
     */
    omit?: payment_ordersOmit<ExtArgs> | null
    /**
     * The data used to update payment_orders.
     */
    data: XOR<payment_ordersUpdateManyMutationInput, payment_ordersUncheckedUpdateManyInput>
    /**
     * Filter which payment_orders to update
     */
    where?: payment_ordersWhereInput
    /**
     * Limit how many payment_orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_ordersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment_orders upsert
   */
  export type payment_ordersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_orders
     */
    select?: payment_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_orders
     */
    omit?: payment_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_ordersInclude<ExtArgs> | null
    /**
     * The filter to search for the payment_orders to update in case it exists.
     */
    where: payment_ordersWhereUniqueInput
    /**
     * In case the payment_orders found by the `where` argument doesn't exist, create a new payment_orders with this data.
     */
    create: XOR<payment_ordersCreateInput, payment_ordersUncheckedCreateInput>
    /**
     * In case the payment_orders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payment_ordersUpdateInput, payment_ordersUncheckedUpdateInput>
  }

  /**
   * payment_orders delete
   */
  export type payment_ordersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_orders
     */
    select?: payment_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_orders
     */
    omit?: payment_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_ordersInclude<ExtArgs> | null
    /**
     * Filter which payment_orders to delete.
     */
    where: payment_ordersWhereUniqueInput
  }

  /**
   * payment_orders deleteMany
   */
  export type payment_ordersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_orders to delete
     */
    where?: payment_ordersWhereInput
    /**
     * Limit how many payment_orders to delete.
     */
    limit?: number
  }

  /**
   * payment_orders without action
   */
  export type payment_ordersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_orders
     */
    select?: payment_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_orders
     */
    omit?: payment_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_ordersInclude<ExtArgs> | null
  }


  /**
   * Model profiles
   */

  export type AggregateProfiles = {
    _count: ProfilesCountAggregateOutputType | null
    _min: ProfilesMinAggregateOutputType | null
    _max: ProfilesMaxAggregateOutputType | null
  }

  export type ProfilesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    avatar: string | null
    address: string | null
    pincode: string | null
    city: string | null
    state: string | null
    country: string | null
    createdAt: Date | null
    updatedAt: Date | null
    passwordHash: string | null
    googleId: string | null
    googleVerified: boolean | null
  }

  export type ProfilesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    avatar: string | null
    address: string | null
    pincode: string | null
    city: string | null
    state: string | null
    country: string | null
    createdAt: Date | null
    updatedAt: Date | null
    passwordHash: string | null
    googleId: string | null
    googleVerified: boolean | null
  }

  export type ProfilesCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    lastName: number
    avatar: number
    address: number
    pincode: number
    city: number
    state: number
    country: number
    createdAt: number
    updatedAt: number
    passwordHash: number
    googleId: number
    googleVerified: number
    _all: number
  }


  export type ProfilesMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    avatar?: true
    address?: true
    pincode?: true
    city?: true
    state?: true
    country?: true
    createdAt?: true
    updatedAt?: true
    passwordHash?: true
    googleId?: true
    googleVerified?: true
  }

  export type ProfilesMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    avatar?: true
    address?: true
    pincode?: true
    city?: true
    state?: true
    country?: true
    createdAt?: true
    updatedAt?: true
    passwordHash?: true
    googleId?: true
    googleVerified?: true
  }

  export type ProfilesCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    avatar?: true
    address?: true
    pincode?: true
    city?: true
    state?: true
    country?: true
    createdAt?: true
    updatedAt?: true
    passwordHash?: true
    googleId?: true
    googleVerified?: true
    _all?: true
  }

  export type ProfilesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which profiles to aggregate.
     */
    where?: profilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profilesOrderByWithRelationInput | profilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: profilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned profiles
    **/
    _count?: true | ProfilesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfilesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfilesMaxAggregateInputType
  }

  export type GetProfilesAggregateType<T extends ProfilesAggregateArgs> = {
        [P in keyof T & keyof AggregateProfiles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfiles[P]>
      : GetScalarType<T[P], AggregateProfiles[P]>
  }




  export type profilesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: profilesWhereInput
    orderBy?: profilesOrderByWithAggregationInput | profilesOrderByWithAggregationInput[]
    by: ProfilesScalarFieldEnum[] | ProfilesScalarFieldEnum
    having?: profilesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfilesCountAggregateInputType | true
    _min?: ProfilesMinAggregateInputType
    _max?: ProfilesMaxAggregateInputType
  }

  export type ProfilesGroupByOutputType = {
    id: string
    userId: string
    firstName: string
    lastName: string
    avatar: string | null
    address: string | null
    pincode: string | null
    city: string | null
    state: string | null
    country: string
    createdAt: Date
    updatedAt: Date
    passwordHash: string | null
    googleId: string | null
    googleVerified: boolean
    _count: ProfilesCountAggregateOutputType | null
    _min: ProfilesMinAggregateOutputType | null
    _max: ProfilesMaxAggregateOutputType | null
  }

  type GetProfilesGroupByPayload<T extends profilesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfilesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfilesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfilesGroupByOutputType[P]>
            : GetScalarType<T[P], ProfilesGroupByOutputType[P]>
        }
      >
    >


  export type profilesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    avatar?: boolean
    address?: boolean
    pincode?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    passwordHash?: boolean
    googleId?: boolean
    googleVerified?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profiles"]>

  export type profilesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    avatar?: boolean
    address?: boolean
    pincode?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    passwordHash?: boolean
    googleId?: boolean
    googleVerified?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profiles"]>

  export type profilesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    avatar?: boolean
    address?: boolean
    pincode?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    passwordHash?: boolean
    googleId?: boolean
    googleVerified?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profiles"]>

  export type profilesSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    avatar?: boolean
    address?: boolean
    pincode?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    passwordHash?: boolean
    googleId?: boolean
    googleVerified?: boolean
  }

  export type profilesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "firstName" | "lastName" | "avatar" | "address" | "pincode" | "city" | "state" | "country" | "createdAt" | "updatedAt" | "passwordHash" | "googleId" | "googleVerified", ExtArgs["result"]["profiles"]>
  export type profilesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type profilesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type profilesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $profilesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "profiles"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      firstName: string
      lastName: string
      avatar: string | null
      address: string | null
      pincode: string | null
      city: string | null
      state: string | null
      country: string
      createdAt: Date
      updatedAt: Date
      passwordHash: string | null
      googleId: string | null
      googleVerified: boolean
    }, ExtArgs["result"]["profiles"]>
    composites: {}
  }

  type profilesGetPayload<S extends boolean | null | undefined | profilesDefaultArgs> = $Result.GetResult<Prisma.$profilesPayload, S>

  type profilesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<profilesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfilesCountAggregateInputType | true
    }

  export interface profilesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['profiles'], meta: { name: 'profiles' } }
    /**
     * Find zero or one Profiles that matches the filter.
     * @param {profilesFindUniqueArgs} args - Arguments to find a Profiles
     * @example
     * // Get one Profiles
     * const profiles = await prisma.profiles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends profilesFindUniqueArgs>(args: SelectSubset<T, profilesFindUniqueArgs<ExtArgs>>): Prisma__profilesClient<$Result.GetResult<Prisma.$profilesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Profiles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {profilesFindUniqueOrThrowArgs} args - Arguments to find a Profiles
     * @example
     * // Get one Profiles
     * const profiles = await prisma.profiles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends profilesFindUniqueOrThrowArgs>(args: SelectSubset<T, profilesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__profilesClient<$Result.GetResult<Prisma.$profilesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profilesFindFirstArgs} args - Arguments to find a Profiles
     * @example
     * // Get one Profiles
     * const profiles = await prisma.profiles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends profilesFindFirstArgs>(args?: SelectSubset<T, profilesFindFirstArgs<ExtArgs>>): Prisma__profilesClient<$Result.GetResult<Prisma.$profilesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profiles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profilesFindFirstOrThrowArgs} args - Arguments to find a Profiles
     * @example
     * // Get one Profiles
     * const profiles = await prisma.profiles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends profilesFindFirstOrThrowArgs>(args?: SelectSubset<T, profilesFindFirstOrThrowArgs<ExtArgs>>): Prisma__profilesClient<$Result.GetResult<Prisma.$profilesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profilesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profiles.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profiles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profilesWithIdOnly = await prisma.profiles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends profilesFindManyArgs>(args?: SelectSubset<T, profilesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Profiles.
     * @param {profilesCreateArgs} args - Arguments to create a Profiles.
     * @example
     * // Create one Profiles
     * const Profiles = await prisma.profiles.create({
     *   data: {
     *     // ... data to create a Profiles
     *   }
     * })
     * 
     */
    create<T extends profilesCreateArgs>(args: SelectSubset<T, profilesCreateArgs<ExtArgs>>): Prisma__profilesClient<$Result.GetResult<Prisma.$profilesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Profiles.
     * @param {profilesCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profiles = await prisma.profiles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends profilesCreateManyArgs>(args?: SelectSubset<T, profilesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {profilesCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profiles = await prisma.profiles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profilesWithIdOnly = await prisma.profiles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends profilesCreateManyAndReturnArgs>(args?: SelectSubset<T, profilesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Profiles.
     * @param {profilesDeleteArgs} args - Arguments to delete one Profiles.
     * @example
     * // Delete one Profiles
     * const Profiles = await prisma.profiles.delete({
     *   where: {
     *     // ... filter to delete one Profiles
     *   }
     * })
     * 
     */
    delete<T extends profilesDeleteArgs>(args: SelectSubset<T, profilesDeleteArgs<ExtArgs>>): Prisma__profilesClient<$Result.GetResult<Prisma.$profilesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Profiles.
     * @param {profilesUpdateArgs} args - Arguments to update one Profiles.
     * @example
     * // Update one Profiles
     * const profiles = await prisma.profiles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends profilesUpdateArgs>(args: SelectSubset<T, profilesUpdateArgs<ExtArgs>>): Prisma__profilesClient<$Result.GetResult<Prisma.$profilesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Profiles.
     * @param {profilesDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profiles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends profilesDeleteManyArgs>(args?: SelectSubset<T, profilesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profilesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profiles = await prisma.profiles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends profilesUpdateManyArgs>(args: SelectSubset<T, profilesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles and returns the data updated in the database.
     * @param {profilesUpdateManyAndReturnArgs} args - Arguments to update many Profiles.
     * @example
     * // Update many Profiles
     * const profiles = await prisma.profiles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Profiles and only return the `id`
     * const profilesWithIdOnly = await prisma.profiles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends profilesUpdateManyAndReturnArgs>(args: SelectSubset<T, profilesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Profiles.
     * @param {profilesUpsertArgs} args - Arguments to update or create a Profiles.
     * @example
     * // Update or create a Profiles
     * const profiles = await prisma.profiles.upsert({
     *   create: {
     *     // ... data to create a Profiles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profiles we want to update
     *   }
     * })
     */
    upsert<T extends profilesUpsertArgs>(args: SelectSubset<T, profilesUpsertArgs<ExtArgs>>): Prisma__profilesClient<$Result.GetResult<Prisma.$profilesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profilesCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profiles.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends profilesCountArgs>(
      args?: Subset<T, profilesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfilesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfilesAggregateArgs>(args: Subset<T, ProfilesAggregateArgs>): Prisma.PrismaPromise<GetProfilesAggregateType<T>>

    /**
     * Group by Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profilesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends profilesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: profilesGroupByArgs['orderBy'] }
        : { orderBy?: profilesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, profilesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfilesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the profiles model
   */
  readonly fields: profilesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for profiles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__profilesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the profiles model
   */
  interface profilesFieldRefs {
    readonly id: FieldRef<"profiles", 'String'>
    readonly userId: FieldRef<"profiles", 'String'>
    readonly firstName: FieldRef<"profiles", 'String'>
    readonly lastName: FieldRef<"profiles", 'String'>
    readonly avatar: FieldRef<"profiles", 'String'>
    readonly address: FieldRef<"profiles", 'String'>
    readonly pincode: FieldRef<"profiles", 'String'>
    readonly city: FieldRef<"profiles", 'String'>
    readonly state: FieldRef<"profiles", 'String'>
    readonly country: FieldRef<"profiles", 'String'>
    readonly createdAt: FieldRef<"profiles", 'DateTime'>
    readonly updatedAt: FieldRef<"profiles", 'DateTime'>
    readonly passwordHash: FieldRef<"profiles", 'String'>
    readonly googleId: FieldRef<"profiles", 'String'>
    readonly googleVerified: FieldRef<"profiles", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * profiles findUnique
   */
  export type profilesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesInclude<ExtArgs> | null
    /**
     * Filter, which profiles to fetch.
     */
    where: profilesWhereUniqueInput
  }

  /**
   * profiles findUniqueOrThrow
   */
  export type profilesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesInclude<ExtArgs> | null
    /**
     * Filter, which profiles to fetch.
     */
    where: profilesWhereUniqueInput
  }

  /**
   * profiles findFirst
   */
  export type profilesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesInclude<ExtArgs> | null
    /**
     * Filter, which profiles to fetch.
     */
    where?: profilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profilesOrderByWithRelationInput | profilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profiles.
     */
    cursor?: profilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profiles.
     */
    distinct?: ProfilesScalarFieldEnum | ProfilesScalarFieldEnum[]
  }

  /**
   * profiles findFirstOrThrow
   */
  export type profilesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesInclude<ExtArgs> | null
    /**
     * Filter, which profiles to fetch.
     */
    where?: profilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profilesOrderByWithRelationInput | profilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profiles.
     */
    cursor?: profilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profiles.
     */
    distinct?: ProfilesScalarFieldEnum | ProfilesScalarFieldEnum[]
  }

  /**
   * profiles findMany
   */
  export type profilesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesInclude<ExtArgs> | null
    /**
     * Filter, which profiles to fetch.
     */
    where?: profilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profilesOrderByWithRelationInput | profilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing profiles.
     */
    cursor?: profilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    distinct?: ProfilesScalarFieldEnum | ProfilesScalarFieldEnum[]
  }

  /**
   * profiles create
   */
  export type profilesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesInclude<ExtArgs> | null
    /**
     * The data needed to create a profiles.
     */
    data: XOR<profilesCreateInput, profilesUncheckedCreateInput>
  }

  /**
   * profiles createMany
   */
  export type profilesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many profiles.
     */
    data: profilesCreateManyInput | profilesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * profiles createManyAndReturn
   */
  export type profilesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
    /**
     * The data used to create many profiles.
     */
    data: profilesCreateManyInput | profilesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * profiles update
   */
  export type profilesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesInclude<ExtArgs> | null
    /**
     * The data needed to update a profiles.
     */
    data: XOR<profilesUpdateInput, profilesUncheckedUpdateInput>
    /**
     * Choose, which profiles to update.
     */
    where: profilesWhereUniqueInput
  }

  /**
   * profiles updateMany
   */
  export type profilesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update profiles.
     */
    data: XOR<profilesUpdateManyMutationInput, profilesUncheckedUpdateManyInput>
    /**
     * Filter which profiles to update
     */
    where?: profilesWhereInput
    /**
     * Limit how many profiles to update.
     */
    limit?: number
  }

  /**
   * profiles updateManyAndReturn
   */
  export type profilesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
    /**
     * The data used to update profiles.
     */
    data: XOR<profilesUpdateManyMutationInput, profilesUncheckedUpdateManyInput>
    /**
     * Filter which profiles to update
     */
    where?: profilesWhereInput
    /**
     * Limit how many profiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * profiles upsert
   */
  export type profilesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesInclude<ExtArgs> | null
    /**
     * The filter to search for the profiles to update in case it exists.
     */
    where: profilesWhereUniqueInput
    /**
     * In case the profiles found by the `where` argument doesn't exist, create a new profiles with this data.
     */
    create: XOR<profilesCreateInput, profilesUncheckedCreateInput>
    /**
     * In case the profiles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<profilesUpdateInput, profilesUncheckedUpdateInput>
  }

  /**
   * profiles delete
   */
  export type profilesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesInclude<ExtArgs> | null
    /**
     * Filter which profiles to delete.
     */
    where: profilesWhereUniqueInput
  }

  /**
   * profiles deleteMany
   */
  export type profilesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which profiles to delete
     */
    where?: profilesWhereInput
    /**
     * Limit how many profiles to delete.
     */
    limit?: number
  }

  /**
   * profiles without action
   */
  export type profilesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesInclude<ExtArgs> | null
  }


  /**
   * Model provider_locations
   */

  export type AggregateProvider_locations = {
    _count: Provider_locationsCountAggregateOutputType | null
    _avg: Provider_locationsAvgAggregateOutputType | null
    _sum: Provider_locationsSumAggregateOutputType | null
    _min: Provider_locationsMinAggregateOutputType | null
    _max: Provider_locationsMaxAggregateOutputType | null
  }

  export type Provider_locationsAvgAggregateOutputType = {
    lat: number | null
    lng: number | null
  }

  export type Provider_locationsSumAggregateOutputType = {
    lat: number | null
    lng: number | null
  }

  export type Provider_locationsMinAggregateOutputType = {
    id: string | null
    providerId: string | null
    lat: number | null
    lng: number | null
    address: string | null
    zoneId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Provider_locationsMaxAggregateOutputType = {
    id: string | null
    providerId: string | null
    lat: number | null
    lng: number | null
    address: string | null
    zoneId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Provider_locationsCountAggregateOutputType = {
    id: number
    providerId: number
    lat: number
    lng: number
    address: number
    zoneId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Provider_locationsAvgAggregateInputType = {
    lat?: true
    lng?: true
  }

  export type Provider_locationsSumAggregateInputType = {
    lat?: true
    lng?: true
  }

  export type Provider_locationsMinAggregateInputType = {
    id?: true
    providerId?: true
    lat?: true
    lng?: true
    address?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Provider_locationsMaxAggregateInputType = {
    id?: true
    providerId?: true
    lat?: true
    lng?: true
    address?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Provider_locationsCountAggregateInputType = {
    id?: true
    providerId?: true
    lat?: true
    lng?: true
    address?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Provider_locationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which provider_locations to aggregate.
     */
    where?: provider_locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_locations to fetch.
     */
    orderBy?: provider_locationsOrderByWithRelationInput | provider_locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: provider_locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned provider_locations
    **/
    _count?: true | Provider_locationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Provider_locationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Provider_locationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Provider_locationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Provider_locationsMaxAggregateInputType
  }

  export type GetProvider_locationsAggregateType<T extends Provider_locationsAggregateArgs> = {
        [P in keyof T & keyof AggregateProvider_locations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvider_locations[P]>
      : GetScalarType<T[P], AggregateProvider_locations[P]>
  }




  export type provider_locationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: provider_locationsWhereInput
    orderBy?: provider_locationsOrderByWithAggregationInput | provider_locationsOrderByWithAggregationInput[]
    by: Provider_locationsScalarFieldEnum[] | Provider_locationsScalarFieldEnum
    having?: provider_locationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Provider_locationsCountAggregateInputType | true
    _avg?: Provider_locationsAvgAggregateInputType
    _sum?: Provider_locationsSumAggregateInputType
    _min?: Provider_locationsMinAggregateInputType
    _max?: Provider_locationsMaxAggregateInputType
  }

  export type Provider_locationsGroupByOutputType = {
    id: string
    providerId: string
    lat: number
    lng: number
    address: string | null
    zoneId: string | null
    createdAt: Date
    updatedAt: Date
    _count: Provider_locationsCountAggregateOutputType | null
    _avg: Provider_locationsAvgAggregateOutputType | null
    _sum: Provider_locationsSumAggregateOutputType | null
    _min: Provider_locationsMinAggregateOutputType | null
    _max: Provider_locationsMaxAggregateOutputType | null
  }

  type GetProvider_locationsGroupByPayload<T extends provider_locationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Provider_locationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Provider_locationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Provider_locationsGroupByOutputType[P]>
            : GetScalarType<T[P], Provider_locationsGroupByOutputType[P]>
        }
      >
    >


  export type provider_locationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    lat?: boolean
    lng?: boolean
    address?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    providers?: boolean | providersDefaultArgs<ExtArgs>
    zones?: boolean | provider_locations$zonesArgs<ExtArgs>
  }, ExtArgs["result"]["provider_locations"]>

  export type provider_locationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    lat?: boolean
    lng?: boolean
    address?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    providers?: boolean | providersDefaultArgs<ExtArgs>
    zones?: boolean | provider_locations$zonesArgs<ExtArgs>
  }, ExtArgs["result"]["provider_locations"]>

  export type provider_locationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    lat?: boolean
    lng?: boolean
    address?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    providers?: boolean | providersDefaultArgs<ExtArgs>
    zones?: boolean | provider_locations$zonesArgs<ExtArgs>
  }, ExtArgs["result"]["provider_locations"]>

  export type provider_locationsSelectScalar = {
    id?: boolean
    providerId?: boolean
    lat?: boolean
    lng?: boolean
    address?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type provider_locationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "providerId" | "lat" | "lng" | "address" | "zoneId" | "createdAt" | "updatedAt", ExtArgs["result"]["provider_locations"]>
  export type provider_locationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | providersDefaultArgs<ExtArgs>
    zones?: boolean | provider_locations$zonesArgs<ExtArgs>
  }
  export type provider_locationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | providersDefaultArgs<ExtArgs>
    zones?: boolean | provider_locations$zonesArgs<ExtArgs>
  }
  export type provider_locationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | providersDefaultArgs<ExtArgs>
    zones?: boolean | provider_locations$zonesArgs<ExtArgs>
  }

  export type $provider_locationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "provider_locations"
    objects: {
      providers: Prisma.$providersPayload<ExtArgs>
      zones: Prisma.$zonesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      providerId: string
      lat: number
      lng: number
      address: string | null
      zoneId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["provider_locations"]>
    composites: {}
  }

  type provider_locationsGetPayload<S extends boolean | null | undefined | provider_locationsDefaultArgs> = $Result.GetResult<Prisma.$provider_locationsPayload, S>

  type provider_locationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<provider_locationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Provider_locationsCountAggregateInputType | true
    }

  export interface provider_locationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['provider_locations'], meta: { name: 'provider_locations' } }
    /**
     * Find zero or one Provider_locations that matches the filter.
     * @param {provider_locationsFindUniqueArgs} args - Arguments to find a Provider_locations
     * @example
     * // Get one Provider_locations
     * const provider_locations = await prisma.provider_locations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends provider_locationsFindUniqueArgs>(args: SelectSubset<T, provider_locationsFindUniqueArgs<ExtArgs>>): Prisma__provider_locationsClient<$Result.GetResult<Prisma.$provider_locationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Provider_locations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {provider_locationsFindUniqueOrThrowArgs} args - Arguments to find a Provider_locations
     * @example
     * // Get one Provider_locations
     * const provider_locations = await prisma.provider_locations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends provider_locationsFindUniqueOrThrowArgs>(args: SelectSubset<T, provider_locationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__provider_locationsClient<$Result.GetResult<Prisma.$provider_locationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider_locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_locationsFindFirstArgs} args - Arguments to find a Provider_locations
     * @example
     * // Get one Provider_locations
     * const provider_locations = await prisma.provider_locations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends provider_locationsFindFirstArgs>(args?: SelectSubset<T, provider_locationsFindFirstArgs<ExtArgs>>): Prisma__provider_locationsClient<$Result.GetResult<Prisma.$provider_locationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider_locations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_locationsFindFirstOrThrowArgs} args - Arguments to find a Provider_locations
     * @example
     * // Get one Provider_locations
     * const provider_locations = await prisma.provider_locations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends provider_locationsFindFirstOrThrowArgs>(args?: SelectSubset<T, provider_locationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__provider_locationsClient<$Result.GetResult<Prisma.$provider_locationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Provider_locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_locationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Provider_locations
     * const provider_locations = await prisma.provider_locations.findMany()
     * 
     * // Get first 10 Provider_locations
     * const provider_locations = await prisma.provider_locations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const provider_locationsWithIdOnly = await prisma.provider_locations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends provider_locationsFindManyArgs>(args?: SelectSubset<T, provider_locationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_locationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Provider_locations.
     * @param {provider_locationsCreateArgs} args - Arguments to create a Provider_locations.
     * @example
     * // Create one Provider_locations
     * const Provider_locations = await prisma.provider_locations.create({
     *   data: {
     *     // ... data to create a Provider_locations
     *   }
     * })
     * 
     */
    create<T extends provider_locationsCreateArgs>(args: SelectSubset<T, provider_locationsCreateArgs<ExtArgs>>): Prisma__provider_locationsClient<$Result.GetResult<Prisma.$provider_locationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Provider_locations.
     * @param {provider_locationsCreateManyArgs} args - Arguments to create many Provider_locations.
     * @example
     * // Create many Provider_locations
     * const provider_locations = await prisma.provider_locations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends provider_locationsCreateManyArgs>(args?: SelectSubset<T, provider_locationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Provider_locations and returns the data saved in the database.
     * @param {provider_locationsCreateManyAndReturnArgs} args - Arguments to create many Provider_locations.
     * @example
     * // Create many Provider_locations
     * const provider_locations = await prisma.provider_locations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Provider_locations and only return the `id`
     * const provider_locationsWithIdOnly = await prisma.provider_locations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends provider_locationsCreateManyAndReturnArgs>(args?: SelectSubset<T, provider_locationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_locationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Provider_locations.
     * @param {provider_locationsDeleteArgs} args - Arguments to delete one Provider_locations.
     * @example
     * // Delete one Provider_locations
     * const Provider_locations = await prisma.provider_locations.delete({
     *   where: {
     *     // ... filter to delete one Provider_locations
     *   }
     * })
     * 
     */
    delete<T extends provider_locationsDeleteArgs>(args: SelectSubset<T, provider_locationsDeleteArgs<ExtArgs>>): Prisma__provider_locationsClient<$Result.GetResult<Prisma.$provider_locationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Provider_locations.
     * @param {provider_locationsUpdateArgs} args - Arguments to update one Provider_locations.
     * @example
     * // Update one Provider_locations
     * const provider_locations = await prisma.provider_locations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends provider_locationsUpdateArgs>(args: SelectSubset<T, provider_locationsUpdateArgs<ExtArgs>>): Prisma__provider_locationsClient<$Result.GetResult<Prisma.$provider_locationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Provider_locations.
     * @param {provider_locationsDeleteManyArgs} args - Arguments to filter Provider_locations to delete.
     * @example
     * // Delete a few Provider_locations
     * const { count } = await prisma.provider_locations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends provider_locationsDeleteManyArgs>(args?: SelectSubset<T, provider_locationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provider_locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_locationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Provider_locations
     * const provider_locations = await prisma.provider_locations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends provider_locationsUpdateManyArgs>(args: SelectSubset<T, provider_locationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provider_locations and returns the data updated in the database.
     * @param {provider_locationsUpdateManyAndReturnArgs} args - Arguments to update many Provider_locations.
     * @example
     * // Update many Provider_locations
     * const provider_locations = await prisma.provider_locations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Provider_locations and only return the `id`
     * const provider_locationsWithIdOnly = await prisma.provider_locations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends provider_locationsUpdateManyAndReturnArgs>(args: SelectSubset<T, provider_locationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_locationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Provider_locations.
     * @param {provider_locationsUpsertArgs} args - Arguments to update or create a Provider_locations.
     * @example
     * // Update or create a Provider_locations
     * const provider_locations = await prisma.provider_locations.upsert({
     *   create: {
     *     // ... data to create a Provider_locations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provider_locations we want to update
     *   }
     * })
     */
    upsert<T extends provider_locationsUpsertArgs>(args: SelectSubset<T, provider_locationsUpsertArgs<ExtArgs>>): Prisma__provider_locationsClient<$Result.GetResult<Prisma.$provider_locationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Provider_locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_locationsCountArgs} args - Arguments to filter Provider_locations to count.
     * @example
     * // Count the number of Provider_locations
     * const count = await prisma.provider_locations.count({
     *   where: {
     *     // ... the filter for the Provider_locations we want to count
     *   }
     * })
    **/
    count<T extends provider_locationsCountArgs>(
      args?: Subset<T, provider_locationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Provider_locationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Provider_locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Provider_locationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Provider_locationsAggregateArgs>(args: Subset<T, Provider_locationsAggregateArgs>): Prisma.PrismaPromise<GetProvider_locationsAggregateType<T>>

    /**
     * Group by Provider_locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_locationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends provider_locationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: provider_locationsGroupByArgs['orderBy'] }
        : { orderBy?: provider_locationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, provider_locationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvider_locationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the provider_locations model
   */
  readonly fields: provider_locationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for provider_locations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__provider_locationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    providers<T extends providersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, providersDefaultArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    zones<T extends provider_locations$zonesArgs<ExtArgs> = {}>(args?: Subset<T, provider_locations$zonesArgs<ExtArgs>>): Prisma__zonesClient<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the provider_locations model
   */
  interface provider_locationsFieldRefs {
    readonly id: FieldRef<"provider_locations", 'String'>
    readonly providerId: FieldRef<"provider_locations", 'String'>
    readonly lat: FieldRef<"provider_locations", 'Float'>
    readonly lng: FieldRef<"provider_locations", 'Float'>
    readonly address: FieldRef<"provider_locations", 'String'>
    readonly zoneId: FieldRef<"provider_locations", 'String'>
    readonly createdAt: FieldRef<"provider_locations", 'DateTime'>
    readonly updatedAt: FieldRef<"provider_locations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * provider_locations findUnique
   */
  export type provider_locationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_locations
     */
    select?: provider_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_locations
     */
    omit?: provider_locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_locationsInclude<ExtArgs> | null
    /**
     * Filter, which provider_locations to fetch.
     */
    where: provider_locationsWhereUniqueInput
  }

  /**
   * provider_locations findUniqueOrThrow
   */
  export type provider_locationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_locations
     */
    select?: provider_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_locations
     */
    omit?: provider_locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_locationsInclude<ExtArgs> | null
    /**
     * Filter, which provider_locations to fetch.
     */
    where: provider_locationsWhereUniqueInput
  }

  /**
   * provider_locations findFirst
   */
  export type provider_locationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_locations
     */
    select?: provider_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_locations
     */
    omit?: provider_locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_locationsInclude<ExtArgs> | null
    /**
     * Filter, which provider_locations to fetch.
     */
    where?: provider_locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_locations to fetch.
     */
    orderBy?: provider_locationsOrderByWithRelationInput | provider_locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for provider_locations.
     */
    cursor?: provider_locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of provider_locations.
     */
    distinct?: Provider_locationsScalarFieldEnum | Provider_locationsScalarFieldEnum[]
  }

  /**
   * provider_locations findFirstOrThrow
   */
  export type provider_locationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_locations
     */
    select?: provider_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_locations
     */
    omit?: provider_locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_locationsInclude<ExtArgs> | null
    /**
     * Filter, which provider_locations to fetch.
     */
    where?: provider_locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_locations to fetch.
     */
    orderBy?: provider_locationsOrderByWithRelationInput | provider_locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for provider_locations.
     */
    cursor?: provider_locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of provider_locations.
     */
    distinct?: Provider_locationsScalarFieldEnum | Provider_locationsScalarFieldEnum[]
  }

  /**
   * provider_locations findMany
   */
  export type provider_locationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_locations
     */
    select?: provider_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_locations
     */
    omit?: provider_locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_locationsInclude<ExtArgs> | null
    /**
     * Filter, which provider_locations to fetch.
     */
    where?: provider_locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_locations to fetch.
     */
    orderBy?: provider_locationsOrderByWithRelationInput | provider_locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing provider_locations.
     */
    cursor?: provider_locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_locations.
     */
    skip?: number
    distinct?: Provider_locationsScalarFieldEnum | Provider_locationsScalarFieldEnum[]
  }

  /**
   * provider_locations create
   */
  export type provider_locationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_locations
     */
    select?: provider_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_locations
     */
    omit?: provider_locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_locationsInclude<ExtArgs> | null
    /**
     * The data needed to create a provider_locations.
     */
    data: XOR<provider_locationsCreateInput, provider_locationsUncheckedCreateInput>
  }

  /**
   * provider_locations createMany
   */
  export type provider_locationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many provider_locations.
     */
    data: provider_locationsCreateManyInput | provider_locationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * provider_locations createManyAndReturn
   */
  export type provider_locationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_locations
     */
    select?: provider_locationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the provider_locations
     */
    omit?: provider_locationsOmit<ExtArgs> | null
    /**
     * The data used to create many provider_locations.
     */
    data: provider_locationsCreateManyInput | provider_locationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_locationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * provider_locations update
   */
  export type provider_locationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_locations
     */
    select?: provider_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_locations
     */
    omit?: provider_locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_locationsInclude<ExtArgs> | null
    /**
     * The data needed to update a provider_locations.
     */
    data: XOR<provider_locationsUpdateInput, provider_locationsUncheckedUpdateInput>
    /**
     * Choose, which provider_locations to update.
     */
    where: provider_locationsWhereUniqueInput
  }

  /**
   * provider_locations updateMany
   */
  export type provider_locationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update provider_locations.
     */
    data: XOR<provider_locationsUpdateManyMutationInput, provider_locationsUncheckedUpdateManyInput>
    /**
     * Filter which provider_locations to update
     */
    where?: provider_locationsWhereInput
    /**
     * Limit how many provider_locations to update.
     */
    limit?: number
  }

  /**
   * provider_locations updateManyAndReturn
   */
  export type provider_locationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_locations
     */
    select?: provider_locationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the provider_locations
     */
    omit?: provider_locationsOmit<ExtArgs> | null
    /**
     * The data used to update provider_locations.
     */
    data: XOR<provider_locationsUpdateManyMutationInput, provider_locationsUncheckedUpdateManyInput>
    /**
     * Filter which provider_locations to update
     */
    where?: provider_locationsWhereInput
    /**
     * Limit how many provider_locations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_locationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * provider_locations upsert
   */
  export type provider_locationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_locations
     */
    select?: provider_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_locations
     */
    omit?: provider_locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_locationsInclude<ExtArgs> | null
    /**
     * The filter to search for the provider_locations to update in case it exists.
     */
    where: provider_locationsWhereUniqueInput
    /**
     * In case the provider_locations found by the `where` argument doesn't exist, create a new provider_locations with this data.
     */
    create: XOR<provider_locationsCreateInput, provider_locationsUncheckedCreateInput>
    /**
     * In case the provider_locations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<provider_locationsUpdateInput, provider_locationsUncheckedUpdateInput>
  }

  /**
   * provider_locations delete
   */
  export type provider_locationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_locations
     */
    select?: provider_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_locations
     */
    omit?: provider_locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_locationsInclude<ExtArgs> | null
    /**
     * Filter which provider_locations to delete.
     */
    where: provider_locationsWhereUniqueInput
  }

  /**
   * provider_locations deleteMany
   */
  export type provider_locationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which provider_locations to delete
     */
    where?: provider_locationsWhereInput
    /**
     * Limit how many provider_locations to delete.
     */
    limit?: number
  }

  /**
   * provider_locations.zones
   */
  export type provider_locations$zonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
    where?: zonesWhereInput
  }

  /**
   * provider_locations without action
   */
  export type provider_locationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_locations
     */
    select?: provider_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_locations
     */
    omit?: provider_locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_locationsInclude<ExtArgs> | null
  }


  /**
   * Model providers
   */

  export type AggregateProviders = {
    _count: ProvidersCountAggregateOutputType | null
    _avg: ProvidersAvgAggregateOutputType | null
    _sum: ProvidersSumAggregateOutputType | null
    _min: ProvidersMinAggregateOutputType | null
    _max: ProvidersMaxAggregateOutputType | null
  }

  export type ProvidersAvgAggregateOutputType = {
    rating: number | null
    totalOrders: number | null
  }

  export type ProvidersSumAggregateOutputType = {
    rating: number | null
    totalOrders: number | null
  }

  export type ProvidersMinAggregateOutputType = {
    id: string | null
    userId: string | null
    businessName: string | null
    providerType: $Enums.ProviderType | null
    category: string | null
    area: string | null
    address: string | null
    panNumber: string | null
    aadhaarNumber: string | null
    gstNumber: string | null
    bankAccount: string | null
    upiId: string | null
    isVerified: boolean | null
    isActive: boolean | null
    rating: number | null
    totalOrders: number | null
    isOnline: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProvidersMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    businessName: string | null
    providerType: $Enums.ProviderType | null
    category: string | null
    area: string | null
    address: string | null
    panNumber: string | null
    aadhaarNumber: string | null
    gstNumber: string | null
    bankAccount: string | null
    upiId: string | null
    isVerified: boolean | null
    isActive: boolean | null
    rating: number | null
    totalOrders: number | null
    isOnline: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProvidersCountAggregateOutputType = {
    id: number
    userId: number
    businessName: number
    providerType: number
    category: number
    area: number
    address: number
    panNumber: number
    aadhaarNumber: number
    gstNumber: number
    bankAccount: number
    upiId: number
    isVerified: number
    isActive: number
    rating: number
    totalOrders: number
    isOnline: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProvidersAvgAggregateInputType = {
    rating?: true
    totalOrders?: true
  }

  export type ProvidersSumAggregateInputType = {
    rating?: true
    totalOrders?: true
  }

  export type ProvidersMinAggregateInputType = {
    id?: true
    userId?: true
    businessName?: true
    providerType?: true
    category?: true
    area?: true
    address?: true
    panNumber?: true
    aadhaarNumber?: true
    gstNumber?: true
    bankAccount?: true
    upiId?: true
    isVerified?: true
    isActive?: true
    rating?: true
    totalOrders?: true
    isOnline?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProvidersMaxAggregateInputType = {
    id?: true
    userId?: true
    businessName?: true
    providerType?: true
    category?: true
    area?: true
    address?: true
    panNumber?: true
    aadhaarNumber?: true
    gstNumber?: true
    bankAccount?: true
    upiId?: true
    isVerified?: true
    isActive?: true
    rating?: true
    totalOrders?: true
    isOnline?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProvidersCountAggregateInputType = {
    id?: true
    userId?: true
    businessName?: true
    providerType?: true
    category?: true
    area?: true
    address?: true
    panNumber?: true
    aadhaarNumber?: true
    gstNumber?: true
    bankAccount?: true
    upiId?: true
    isVerified?: true
    isActive?: true
    rating?: true
    totalOrders?: true
    isOnline?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProvidersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which providers to aggregate.
     */
    where?: providersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of providers to fetch.
     */
    orderBy?: providersOrderByWithRelationInput | providersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: providersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned providers
    **/
    _count?: true | ProvidersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProvidersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProvidersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProvidersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProvidersMaxAggregateInputType
  }

  export type GetProvidersAggregateType<T extends ProvidersAggregateArgs> = {
        [P in keyof T & keyof AggregateProviders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProviders[P]>
      : GetScalarType<T[P], AggregateProviders[P]>
  }




  export type providersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: providersWhereInput
    orderBy?: providersOrderByWithAggregationInput | providersOrderByWithAggregationInput[]
    by: ProvidersScalarFieldEnum[] | ProvidersScalarFieldEnum
    having?: providersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProvidersCountAggregateInputType | true
    _avg?: ProvidersAvgAggregateInputType
    _sum?: ProvidersSumAggregateInputType
    _min?: ProvidersMinAggregateInputType
    _max?: ProvidersMaxAggregateInputType
  }

  export type ProvidersGroupByOutputType = {
    id: string
    userId: string
    businessName: string
    providerType: $Enums.ProviderType
    category: string
    area: string
    address: string
    panNumber: string
    aadhaarNumber: string
    gstNumber: string | null
    bankAccount: string | null
    upiId: string | null
    isVerified: boolean
    isActive: boolean
    rating: number
    totalOrders: number
    isOnline: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProvidersCountAggregateOutputType | null
    _avg: ProvidersAvgAggregateOutputType | null
    _sum: ProvidersSumAggregateOutputType | null
    _min: ProvidersMinAggregateOutputType | null
    _max: ProvidersMaxAggregateOutputType | null
  }

  type GetProvidersGroupByPayload<T extends providersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProvidersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProvidersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProvidersGroupByOutputType[P]>
            : GetScalarType<T[P], ProvidersGroupByOutputType[P]>
        }
      >
    >


  export type providersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    businessName?: boolean
    providerType?: boolean
    category?: boolean
    area?: boolean
    address?: boolean
    panNumber?: boolean
    aadhaarNumber?: boolean
    gstNumber?: boolean
    bankAccount?: boolean
    upiId?: boolean
    isVerified?: boolean
    isActive?: boolean
    rating?: boolean
    totalOrders?: boolean
    isOnline?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider_locations?: boolean | providers$provider_locationsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    reviews?: boolean | providers$reviewsArgs<ExtArgs>
    services?: boolean | providers$servicesArgs<ExtArgs>
    _count?: boolean | ProvidersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providers"]>

  export type providersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    businessName?: boolean
    providerType?: boolean
    category?: boolean
    area?: boolean
    address?: boolean
    panNumber?: boolean
    aadhaarNumber?: boolean
    gstNumber?: boolean
    bankAccount?: boolean
    upiId?: boolean
    isVerified?: boolean
    isActive?: boolean
    rating?: boolean
    totalOrders?: boolean
    isOnline?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providers"]>

  export type providersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    businessName?: boolean
    providerType?: boolean
    category?: boolean
    area?: boolean
    address?: boolean
    panNumber?: boolean
    aadhaarNumber?: boolean
    gstNumber?: boolean
    bankAccount?: boolean
    upiId?: boolean
    isVerified?: boolean
    isActive?: boolean
    rating?: boolean
    totalOrders?: boolean
    isOnline?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providers"]>

  export type providersSelectScalar = {
    id?: boolean
    userId?: boolean
    businessName?: boolean
    providerType?: boolean
    category?: boolean
    area?: boolean
    address?: boolean
    panNumber?: boolean
    aadhaarNumber?: boolean
    gstNumber?: boolean
    bankAccount?: boolean
    upiId?: boolean
    isVerified?: boolean
    isActive?: boolean
    rating?: boolean
    totalOrders?: boolean
    isOnline?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type providersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "businessName" | "providerType" | "category" | "area" | "address" | "panNumber" | "aadhaarNumber" | "gstNumber" | "bankAccount" | "upiId" | "isVerified" | "isActive" | "rating" | "totalOrders" | "isOnline" | "createdAt" | "updatedAt", ExtArgs["result"]["providers"]>
  export type providersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider_locations?: boolean | providers$provider_locationsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    reviews?: boolean | providers$reviewsArgs<ExtArgs>
    services?: boolean | providers$servicesArgs<ExtArgs>
    _count?: boolean | ProvidersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type providersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type providersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $providersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "providers"
    objects: {
      provider_locations: Prisma.$provider_locationsPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
      reviews: Prisma.$reviewsPayload<ExtArgs>[]
      services: Prisma.$servicesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      businessName: string
      providerType: $Enums.ProviderType
      category: string
      area: string
      address: string
      panNumber: string
      aadhaarNumber: string
      gstNumber: string | null
      bankAccount: string | null
      upiId: string | null
      isVerified: boolean
      isActive: boolean
      rating: number
      totalOrders: number
      isOnline: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["providers"]>
    composites: {}
  }

  type providersGetPayload<S extends boolean | null | undefined | providersDefaultArgs> = $Result.GetResult<Prisma.$providersPayload, S>

  type providersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<providersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProvidersCountAggregateInputType | true
    }

  export interface providersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['providers'], meta: { name: 'providers' } }
    /**
     * Find zero or one Providers that matches the filter.
     * @param {providersFindUniqueArgs} args - Arguments to find a Providers
     * @example
     * // Get one Providers
     * const providers = await prisma.providers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends providersFindUniqueArgs>(args: SelectSubset<T, providersFindUniqueArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Providers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {providersFindUniqueOrThrowArgs} args - Arguments to find a Providers
     * @example
     * // Get one Providers
     * const providers = await prisma.providers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends providersFindUniqueOrThrowArgs>(args: SelectSubset<T, providersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providersFindFirstArgs} args - Arguments to find a Providers
     * @example
     * // Get one Providers
     * const providers = await prisma.providers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends providersFindFirstArgs>(args?: SelectSubset<T, providersFindFirstArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Providers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providersFindFirstOrThrowArgs} args - Arguments to find a Providers
     * @example
     * // Get one Providers
     * const providers = await prisma.providers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends providersFindFirstOrThrowArgs>(args?: SelectSubset<T, providersFindFirstOrThrowArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Providers
     * const providers = await prisma.providers.findMany()
     * 
     * // Get first 10 Providers
     * const providers = await prisma.providers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providersWithIdOnly = await prisma.providers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends providersFindManyArgs>(args?: SelectSubset<T, providersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Providers.
     * @param {providersCreateArgs} args - Arguments to create a Providers.
     * @example
     * // Create one Providers
     * const Providers = await prisma.providers.create({
     *   data: {
     *     // ... data to create a Providers
     *   }
     * })
     * 
     */
    create<T extends providersCreateArgs>(args: SelectSubset<T, providersCreateArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Providers.
     * @param {providersCreateManyArgs} args - Arguments to create many Providers.
     * @example
     * // Create many Providers
     * const providers = await prisma.providers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends providersCreateManyArgs>(args?: SelectSubset<T, providersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Providers and returns the data saved in the database.
     * @param {providersCreateManyAndReturnArgs} args - Arguments to create many Providers.
     * @example
     * // Create many Providers
     * const providers = await prisma.providers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Providers and only return the `id`
     * const providersWithIdOnly = await prisma.providers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends providersCreateManyAndReturnArgs>(args?: SelectSubset<T, providersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Providers.
     * @param {providersDeleteArgs} args - Arguments to delete one Providers.
     * @example
     * // Delete one Providers
     * const Providers = await prisma.providers.delete({
     *   where: {
     *     // ... filter to delete one Providers
     *   }
     * })
     * 
     */
    delete<T extends providersDeleteArgs>(args: SelectSubset<T, providersDeleteArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Providers.
     * @param {providersUpdateArgs} args - Arguments to update one Providers.
     * @example
     * // Update one Providers
     * const providers = await prisma.providers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends providersUpdateArgs>(args: SelectSubset<T, providersUpdateArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Providers.
     * @param {providersDeleteManyArgs} args - Arguments to filter Providers to delete.
     * @example
     * // Delete a few Providers
     * const { count } = await prisma.providers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends providersDeleteManyArgs>(args?: SelectSubset<T, providersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Providers
     * const providers = await prisma.providers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends providersUpdateManyArgs>(args: SelectSubset<T, providersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers and returns the data updated in the database.
     * @param {providersUpdateManyAndReturnArgs} args - Arguments to update many Providers.
     * @example
     * // Update many Providers
     * const providers = await prisma.providers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Providers and only return the `id`
     * const providersWithIdOnly = await prisma.providers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends providersUpdateManyAndReturnArgs>(args: SelectSubset<T, providersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Providers.
     * @param {providersUpsertArgs} args - Arguments to update or create a Providers.
     * @example
     * // Update or create a Providers
     * const providers = await prisma.providers.upsert({
     *   create: {
     *     // ... data to create a Providers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Providers we want to update
     *   }
     * })
     */
    upsert<T extends providersUpsertArgs>(args: SelectSubset<T, providersUpsertArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providersCountArgs} args - Arguments to filter Providers to count.
     * @example
     * // Count the number of Providers
     * const count = await prisma.providers.count({
     *   where: {
     *     // ... the filter for the Providers we want to count
     *   }
     * })
    **/
    count<T extends providersCountArgs>(
      args?: Subset<T, providersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProvidersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvidersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProvidersAggregateArgs>(args: Subset<T, ProvidersAggregateArgs>): Prisma.PrismaPromise<GetProvidersAggregateType<T>>

    /**
     * Group by Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends providersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: providersGroupByArgs['orderBy'] }
        : { orderBy?: providersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, providersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvidersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the providers model
   */
  readonly fields: providersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for providers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__providersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider_locations<T extends providers$provider_locationsArgs<ExtArgs> = {}>(args?: Subset<T, providers$provider_locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_locationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviews<T extends providers$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, providers$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    services<T extends providers$servicesArgs<ExtArgs> = {}>(args?: Subset<T, providers$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the providers model
   */
  interface providersFieldRefs {
    readonly id: FieldRef<"providers", 'String'>
    readonly userId: FieldRef<"providers", 'String'>
    readonly businessName: FieldRef<"providers", 'String'>
    readonly providerType: FieldRef<"providers", 'ProviderType'>
    readonly category: FieldRef<"providers", 'String'>
    readonly area: FieldRef<"providers", 'String'>
    readonly address: FieldRef<"providers", 'String'>
    readonly panNumber: FieldRef<"providers", 'String'>
    readonly aadhaarNumber: FieldRef<"providers", 'String'>
    readonly gstNumber: FieldRef<"providers", 'String'>
    readonly bankAccount: FieldRef<"providers", 'String'>
    readonly upiId: FieldRef<"providers", 'String'>
    readonly isVerified: FieldRef<"providers", 'Boolean'>
    readonly isActive: FieldRef<"providers", 'Boolean'>
    readonly rating: FieldRef<"providers", 'Float'>
    readonly totalOrders: FieldRef<"providers", 'Int'>
    readonly isOnline: FieldRef<"providers", 'Boolean'>
    readonly createdAt: FieldRef<"providers", 'DateTime'>
    readonly updatedAt: FieldRef<"providers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * providers findUnique
   */
  export type providersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * Filter, which providers to fetch.
     */
    where: providersWhereUniqueInput
  }

  /**
   * providers findUniqueOrThrow
   */
  export type providersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * Filter, which providers to fetch.
     */
    where: providersWhereUniqueInput
  }

  /**
   * providers findFirst
   */
  export type providersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * Filter, which providers to fetch.
     */
    where?: providersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of providers to fetch.
     */
    orderBy?: providersOrderByWithRelationInput | providersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for providers.
     */
    cursor?: providersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of providers.
     */
    distinct?: ProvidersScalarFieldEnum | ProvidersScalarFieldEnum[]
  }

  /**
   * providers findFirstOrThrow
   */
  export type providersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * Filter, which providers to fetch.
     */
    where?: providersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of providers to fetch.
     */
    orderBy?: providersOrderByWithRelationInput | providersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for providers.
     */
    cursor?: providersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of providers.
     */
    distinct?: ProvidersScalarFieldEnum | ProvidersScalarFieldEnum[]
  }

  /**
   * providers findMany
   */
  export type providersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * Filter, which providers to fetch.
     */
    where?: providersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of providers to fetch.
     */
    orderBy?: providersOrderByWithRelationInput | providersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing providers.
     */
    cursor?: providersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` providers.
     */
    skip?: number
    distinct?: ProvidersScalarFieldEnum | ProvidersScalarFieldEnum[]
  }

  /**
   * providers create
   */
  export type providersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * The data needed to create a providers.
     */
    data: XOR<providersCreateInput, providersUncheckedCreateInput>
  }

  /**
   * providers createMany
   */
  export type providersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many providers.
     */
    data: providersCreateManyInput | providersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * providers createManyAndReturn
   */
  export type providersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * The data used to create many providers.
     */
    data: providersCreateManyInput | providersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * providers update
   */
  export type providersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * The data needed to update a providers.
     */
    data: XOR<providersUpdateInput, providersUncheckedUpdateInput>
    /**
     * Choose, which providers to update.
     */
    where: providersWhereUniqueInput
  }

  /**
   * providers updateMany
   */
  export type providersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update providers.
     */
    data: XOR<providersUpdateManyMutationInput, providersUncheckedUpdateManyInput>
    /**
     * Filter which providers to update
     */
    where?: providersWhereInput
    /**
     * Limit how many providers to update.
     */
    limit?: number
  }

  /**
   * providers updateManyAndReturn
   */
  export type providersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * The data used to update providers.
     */
    data: XOR<providersUpdateManyMutationInput, providersUncheckedUpdateManyInput>
    /**
     * Filter which providers to update
     */
    where?: providersWhereInput
    /**
     * Limit how many providers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * providers upsert
   */
  export type providersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * The filter to search for the providers to update in case it exists.
     */
    where: providersWhereUniqueInput
    /**
     * In case the providers found by the `where` argument doesn't exist, create a new providers with this data.
     */
    create: XOR<providersCreateInput, providersUncheckedCreateInput>
    /**
     * In case the providers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<providersUpdateInput, providersUncheckedUpdateInput>
  }

  /**
   * providers delete
   */
  export type providersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * Filter which providers to delete.
     */
    where: providersWhereUniqueInput
  }

  /**
   * providers deleteMany
   */
  export type providersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which providers to delete
     */
    where?: providersWhereInput
    /**
     * Limit how many providers to delete.
     */
    limit?: number
  }

  /**
   * providers.provider_locations
   */
  export type providers$provider_locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_locations
     */
    select?: provider_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_locations
     */
    omit?: provider_locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_locationsInclude<ExtArgs> | null
    where?: provider_locationsWhereInput
    orderBy?: provider_locationsOrderByWithRelationInput | provider_locationsOrderByWithRelationInput[]
    cursor?: provider_locationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Provider_locationsScalarFieldEnum | Provider_locationsScalarFieldEnum[]
  }

  /**
   * providers.reviews
   */
  export type providers$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    where?: reviewsWhereInput
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    cursor?: reviewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * providers.services
   */
  export type providers$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesInclude<ExtArgs> | null
    where?: servicesWhereInput
    orderBy?: servicesOrderByWithRelationInput | servicesOrderByWithRelationInput[]
    cursor?: servicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicesScalarFieldEnum | ServicesScalarFieldEnum[]
  }

  /**
   * providers without action
   */
  export type providersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
  }


  /**
   * Model report_schedules
   */

  export type AggregateReport_schedules = {
    _count: Report_schedulesCountAggregateOutputType | null
    _min: Report_schedulesMinAggregateOutputType | null
    _max: Report_schedulesMaxAggregateOutputType | null
  }

  export type Report_schedulesMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    reportType: string | null
    frequency: string | null
    email: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Report_schedulesMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    reportType: string | null
    frequency: string | null
    email: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Report_schedulesCountAggregateOutputType = {
    id: number
    adminId: number
    reportType: number
    frequency: number
    email: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Report_schedulesMinAggregateInputType = {
    id?: true
    adminId?: true
    reportType?: true
    frequency?: true
    email?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Report_schedulesMaxAggregateInputType = {
    id?: true
    adminId?: true
    reportType?: true
    frequency?: true
    email?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Report_schedulesCountAggregateInputType = {
    id?: true
    adminId?: true
    reportType?: true
    frequency?: true
    email?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Report_schedulesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which report_schedules to aggregate.
     */
    where?: report_schedulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of report_schedules to fetch.
     */
    orderBy?: report_schedulesOrderByWithRelationInput | report_schedulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: report_schedulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` report_schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` report_schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned report_schedules
    **/
    _count?: true | Report_schedulesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Report_schedulesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Report_schedulesMaxAggregateInputType
  }

  export type GetReport_schedulesAggregateType<T extends Report_schedulesAggregateArgs> = {
        [P in keyof T & keyof AggregateReport_schedules]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport_schedules[P]>
      : GetScalarType<T[P], AggregateReport_schedules[P]>
  }




  export type report_schedulesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: report_schedulesWhereInput
    orderBy?: report_schedulesOrderByWithAggregationInput | report_schedulesOrderByWithAggregationInput[]
    by: Report_schedulesScalarFieldEnum[] | Report_schedulesScalarFieldEnum
    having?: report_schedulesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Report_schedulesCountAggregateInputType | true
    _min?: Report_schedulesMinAggregateInputType
    _max?: Report_schedulesMaxAggregateInputType
  }

  export type Report_schedulesGroupByOutputType = {
    id: string
    adminId: string
    reportType: string
    frequency: string
    email: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: Report_schedulesCountAggregateOutputType | null
    _min: Report_schedulesMinAggregateOutputType | null
    _max: Report_schedulesMaxAggregateOutputType | null
  }

  type GetReport_schedulesGroupByPayload<T extends report_schedulesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Report_schedulesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Report_schedulesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Report_schedulesGroupByOutputType[P]>
            : GetScalarType<T[P], Report_schedulesGroupByOutputType[P]>
        }
      >
    >


  export type report_schedulesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    reportType?: boolean
    frequency?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report_schedules"]>

  export type report_schedulesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    reportType?: boolean
    frequency?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report_schedules"]>

  export type report_schedulesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    reportType?: boolean
    frequency?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report_schedules"]>

  export type report_schedulesSelectScalar = {
    id?: boolean
    adminId?: boolean
    reportType?: boolean
    frequency?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type report_schedulesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "reportType" | "frequency" | "email" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["report_schedules"]>
  export type report_schedulesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type report_schedulesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type report_schedulesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $report_schedulesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "report_schedules"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      reportType: string
      frequency: string
      email: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["report_schedules"]>
    composites: {}
  }

  type report_schedulesGetPayload<S extends boolean | null | undefined | report_schedulesDefaultArgs> = $Result.GetResult<Prisma.$report_schedulesPayload, S>

  type report_schedulesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<report_schedulesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Report_schedulesCountAggregateInputType | true
    }

  export interface report_schedulesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['report_schedules'], meta: { name: 'report_schedules' } }
    /**
     * Find zero or one Report_schedules that matches the filter.
     * @param {report_schedulesFindUniqueArgs} args - Arguments to find a Report_schedules
     * @example
     * // Get one Report_schedules
     * const report_schedules = await prisma.report_schedules.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends report_schedulesFindUniqueArgs>(args: SelectSubset<T, report_schedulesFindUniqueArgs<ExtArgs>>): Prisma__report_schedulesClient<$Result.GetResult<Prisma.$report_schedulesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Report_schedules that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {report_schedulesFindUniqueOrThrowArgs} args - Arguments to find a Report_schedules
     * @example
     * // Get one Report_schedules
     * const report_schedules = await prisma.report_schedules.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends report_schedulesFindUniqueOrThrowArgs>(args: SelectSubset<T, report_schedulesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__report_schedulesClient<$Result.GetResult<Prisma.$report_schedulesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report_schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_schedulesFindFirstArgs} args - Arguments to find a Report_schedules
     * @example
     * // Get one Report_schedules
     * const report_schedules = await prisma.report_schedules.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends report_schedulesFindFirstArgs>(args?: SelectSubset<T, report_schedulesFindFirstArgs<ExtArgs>>): Prisma__report_schedulesClient<$Result.GetResult<Prisma.$report_schedulesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report_schedules that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_schedulesFindFirstOrThrowArgs} args - Arguments to find a Report_schedules
     * @example
     * // Get one Report_schedules
     * const report_schedules = await prisma.report_schedules.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends report_schedulesFindFirstOrThrowArgs>(args?: SelectSubset<T, report_schedulesFindFirstOrThrowArgs<ExtArgs>>): Prisma__report_schedulesClient<$Result.GetResult<Prisma.$report_schedulesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Report_schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_schedulesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Report_schedules
     * const report_schedules = await prisma.report_schedules.findMany()
     * 
     * // Get first 10 Report_schedules
     * const report_schedules = await prisma.report_schedules.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const report_schedulesWithIdOnly = await prisma.report_schedules.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends report_schedulesFindManyArgs>(args?: SelectSubset<T, report_schedulesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$report_schedulesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Report_schedules.
     * @param {report_schedulesCreateArgs} args - Arguments to create a Report_schedules.
     * @example
     * // Create one Report_schedules
     * const Report_schedules = await prisma.report_schedules.create({
     *   data: {
     *     // ... data to create a Report_schedules
     *   }
     * })
     * 
     */
    create<T extends report_schedulesCreateArgs>(args: SelectSubset<T, report_schedulesCreateArgs<ExtArgs>>): Prisma__report_schedulesClient<$Result.GetResult<Prisma.$report_schedulesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Report_schedules.
     * @param {report_schedulesCreateManyArgs} args - Arguments to create many Report_schedules.
     * @example
     * // Create many Report_schedules
     * const report_schedules = await prisma.report_schedules.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends report_schedulesCreateManyArgs>(args?: SelectSubset<T, report_schedulesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Report_schedules and returns the data saved in the database.
     * @param {report_schedulesCreateManyAndReturnArgs} args - Arguments to create many Report_schedules.
     * @example
     * // Create many Report_schedules
     * const report_schedules = await prisma.report_schedules.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Report_schedules and only return the `id`
     * const report_schedulesWithIdOnly = await prisma.report_schedules.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends report_schedulesCreateManyAndReturnArgs>(args?: SelectSubset<T, report_schedulesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$report_schedulesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Report_schedules.
     * @param {report_schedulesDeleteArgs} args - Arguments to delete one Report_schedules.
     * @example
     * // Delete one Report_schedules
     * const Report_schedules = await prisma.report_schedules.delete({
     *   where: {
     *     // ... filter to delete one Report_schedules
     *   }
     * })
     * 
     */
    delete<T extends report_schedulesDeleteArgs>(args: SelectSubset<T, report_schedulesDeleteArgs<ExtArgs>>): Prisma__report_schedulesClient<$Result.GetResult<Prisma.$report_schedulesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Report_schedules.
     * @param {report_schedulesUpdateArgs} args - Arguments to update one Report_schedules.
     * @example
     * // Update one Report_schedules
     * const report_schedules = await prisma.report_schedules.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends report_schedulesUpdateArgs>(args: SelectSubset<T, report_schedulesUpdateArgs<ExtArgs>>): Prisma__report_schedulesClient<$Result.GetResult<Prisma.$report_schedulesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Report_schedules.
     * @param {report_schedulesDeleteManyArgs} args - Arguments to filter Report_schedules to delete.
     * @example
     * // Delete a few Report_schedules
     * const { count } = await prisma.report_schedules.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends report_schedulesDeleteManyArgs>(args?: SelectSubset<T, report_schedulesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Report_schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_schedulesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Report_schedules
     * const report_schedules = await prisma.report_schedules.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends report_schedulesUpdateManyArgs>(args: SelectSubset<T, report_schedulesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Report_schedules and returns the data updated in the database.
     * @param {report_schedulesUpdateManyAndReturnArgs} args - Arguments to update many Report_schedules.
     * @example
     * // Update many Report_schedules
     * const report_schedules = await prisma.report_schedules.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Report_schedules and only return the `id`
     * const report_schedulesWithIdOnly = await prisma.report_schedules.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends report_schedulesUpdateManyAndReturnArgs>(args: SelectSubset<T, report_schedulesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$report_schedulesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Report_schedules.
     * @param {report_schedulesUpsertArgs} args - Arguments to update or create a Report_schedules.
     * @example
     * // Update or create a Report_schedules
     * const report_schedules = await prisma.report_schedules.upsert({
     *   create: {
     *     // ... data to create a Report_schedules
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report_schedules we want to update
     *   }
     * })
     */
    upsert<T extends report_schedulesUpsertArgs>(args: SelectSubset<T, report_schedulesUpsertArgs<ExtArgs>>): Prisma__report_schedulesClient<$Result.GetResult<Prisma.$report_schedulesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Report_schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_schedulesCountArgs} args - Arguments to filter Report_schedules to count.
     * @example
     * // Count the number of Report_schedules
     * const count = await prisma.report_schedules.count({
     *   where: {
     *     // ... the filter for the Report_schedules we want to count
     *   }
     * })
    **/
    count<T extends report_schedulesCountArgs>(
      args?: Subset<T, report_schedulesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Report_schedulesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report_schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Report_schedulesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Report_schedulesAggregateArgs>(args: Subset<T, Report_schedulesAggregateArgs>): Prisma.PrismaPromise<GetReport_schedulesAggregateType<T>>

    /**
     * Group by Report_schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_schedulesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends report_schedulesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: report_schedulesGroupByArgs['orderBy'] }
        : { orderBy?: report_schedulesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, report_schedulesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReport_schedulesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the report_schedules model
   */
  readonly fields: report_schedulesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for report_schedules.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__report_schedulesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the report_schedules model
   */
  interface report_schedulesFieldRefs {
    readonly id: FieldRef<"report_schedules", 'String'>
    readonly adminId: FieldRef<"report_schedules", 'String'>
    readonly reportType: FieldRef<"report_schedules", 'String'>
    readonly frequency: FieldRef<"report_schedules", 'String'>
    readonly email: FieldRef<"report_schedules", 'String'>
    readonly isActive: FieldRef<"report_schedules", 'Boolean'>
    readonly createdAt: FieldRef<"report_schedules", 'DateTime'>
    readonly updatedAt: FieldRef<"report_schedules", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * report_schedules findUnique
   */
  export type report_schedulesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_schedules
     */
    select?: report_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_schedules
     */
    omit?: report_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_schedulesInclude<ExtArgs> | null
    /**
     * Filter, which report_schedules to fetch.
     */
    where: report_schedulesWhereUniqueInput
  }

  /**
   * report_schedules findUniqueOrThrow
   */
  export type report_schedulesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_schedules
     */
    select?: report_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_schedules
     */
    omit?: report_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_schedulesInclude<ExtArgs> | null
    /**
     * Filter, which report_schedules to fetch.
     */
    where: report_schedulesWhereUniqueInput
  }

  /**
   * report_schedules findFirst
   */
  export type report_schedulesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_schedules
     */
    select?: report_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_schedules
     */
    omit?: report_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_schedulesInclude<ExtArgs> | null
    /**
     * Filter, which report_schedules to fetch.
     */
    where?: report_schedulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of report_schedules to fetch.
     */
    orderBy?: report_schedulesOrderByWithRelationInput | report_schedulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for report_schedules.
     */
    cursor?: report_schedulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` report_schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` report_schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of report_schedules.
     */
    distinct?: Report_schedulesScalarFieldEnum | Report_schedulesScalarFieldEnum[]
  }

  /**
   * report_schedules findFirstOrThrow
   */
  export type report_schedulesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_schedules
     */
    select?: report_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_schedules
     */
    omit?: report_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_schedulesInclude<ExtArgs> | null
    /**
     * Filter, which report_schedules to fetch.
     */
    where?: report_schedulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of report_schedules to fetch.
     */
    orderBy?: report_schedulesOrderByWithRelationInput | report_schedulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for report_schedules.
     */
    cursor?: report_schedulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` report_schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` report_schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of report_schedules.
     */
    distinct?: Report_schedulesScalarFieldEnum | Report_schedulesScalarFieldEnum[]
  }

  /**
   * report_schedules findMany
   */
  export type report_schedulesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_schedules
     */
    select?: report_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_schedules
     */
    omit?: report_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_schedulesInclude<ExtArgs> | null
    /**
     * Filter, which report_schedules to fetch.
     */
    where?: report_schedulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of report_schedules to fetch.
     */
    orderBy?: report_schedulesOrderByWithRelationInput | report_schedulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing report_schedules.
     */
    cursor?: report_schedulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` report_schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` report_schedules.
     */
    skip?: number
    distinct?: Report_schedulesScalarFieldEnum | Report_schedulesScalarFieldEnum[]
  }

  /**
   * report_schedules create
   */
  export type report_schedulesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_schedules
     */
    select?: report_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_schedules
     */
    omit?: report_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_schedulesInclude<ExtArgs> | null
    /**
     * The data needed to create a report_schedules.
     */
    data: XOR<report_schedulesCreateInput, report_schedulesUncheckedCreateInput>
  }

  /**
   * report_schedules createMany
   */
  export type report_schedulesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many report_schedules.
     */
    data: report_schedulesCreateManyInput | report_schedulesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * report_schedules createManyAndReturn
   */
  export type report_schedulesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_schedules
     */
    select?: report_schedulesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the report_schedules
     */
    omit?: report_schedulesOmit<ExtArgs> | null
    /**
     * The data used to create many report_schedules.
     */
    data: report_schedulesCreateManyInput | report_schedulesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_schedulesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * report_schedules update
   */
  export type report_schedulesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_schedules
     */
    select?: report_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_schedules
     */
    omit?: report_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_schedulesInclude<ExtArgs> | null
    /**
     * The data needed to update a report_schedules.
     */
    data: XOR<report_schedulesUpdateInput, report_schedulesUncheckedUpdateInput>
    /**
     * Choose, which report_schedules to update.
     */
    where: report_schedulesWhereUniqueInput
  }

  /**
   * report_schedules updateMany
   */
  export type report_schedulesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update report_schedules.
     */
    data: XOR<report_schedulesUpdateManyMutationInput, report_schedulesUncheckedUpdateManyInput>
    /**
     * Filter which report_schedules to update
     */
    where?: report_schedulesWhereInput
    /**
     * Limit how many report_schedules to update.
     */
    limit?: number
  }

  /**
   * report_schedules updateManyAndReturn
   */
  export type report_schedulesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_schedules
     */
    select?: report_schedulesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the report_schedules
     */
    omit?: report_schedulesOmit<ExtArgs> | null
    /**
     * The data used to update report_schedules.
     */
    data: XOR<report_schedulesUpdateManyMutationInput, report_schedulesUncheckedUpdateManyInput>
    /**
     * Filter which report_schedules to update
     */
    where?: report_schedulesWhereInput
    /**
     * Limit how many report_schedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_schedulesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * report_schedules upsert
   */
  export type report_schedulesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_schedules
     */
    select?: report_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_schedules
     */
    omit?: report_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_schedulesInclude<ExtArgs> | null
    /**
     * The filter to search for the report_schedules to update in case it exists.
     */
    where: report_schedulesWhereUniqueInput
    /**
     * In case the report_schedules found by the `where` argument doesn't exist, create a new report_schedules with this data.
     */
    create: XOR<report_schedulesCreateInput, report_schedulesUncheckedCreateInput>
    /**
     * In case the report_schedules was found with the provided `where` argument, update it with this data.
     */
    update: XOR<report_schedulesUpdateInput, report_schedulesUncheckedUpdateInput>
  }

  /**
   * report_schedules delete
   */
  export type report_schedulesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_schedules
     */
    select?: report_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_schedules
     */
    omit?: report_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_schedulesInclude<ExtArgs> | null
    /**
     * Filter which report_schedules to delete.
     */
    where: report_schedulesWhereUniqueInput
  }

  /**
   * report_schedules deleteMany
   */
  export type report_schedulesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which report_schedules to delete
     */
    where?: report_schedulesWhereInput
    /**
     * Limit how many report_schedules to delete.
     */
    limit?: number
  }

  /**
   * report_schedules without action
   */
  export type report_schedulesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_schedules
     */
    select?: report_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_schedules
     */
    omit?: report_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_schedulesInclude<ExtArgs> | null
  }


  /**
   * Model reviews
   */

  export type AggregateReviews = {
    _count: ReviewsCountAggregateOutputType | null
    _avg: ReviewsAvgAggregateOutputType | null
    _sum: ReviewsSumAggregateOutputType | null
    _min: ReviewsMinAggregateOutputType | null
    _max: ReviewsMaxAggregateOutputType | null
  }

  export type ReviewsAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewsSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewsMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    reviewerId: string | null
    revieweeId: string | null
    providerId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type ReviewsMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    reviewerId: string | null
    revieweeId: string | null
    providerId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type ReviewsCountAggregateOutputType = {
    id: number
    orderId: number
    reviewerId: number
    revieweeId: number
    providerId: number
    rating: number
    comment: number
    createdAt: number
    _all: number
  }


  export type ReviewsAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewsSumAggregateInputType = {
    rating?: true
  }

  export type ReviewsMinAggregateInputType = {
    id?: true
    orderId?: true
    reviewerId?: true
    revieweeId?: true
    providerId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type ReviewsMaxAggregateInputType = {
    id?: true
    orderId?: true
    reviewerId?: true
    revieweeId?: true
    providerId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type ReviewsCountAggregateInputType = {
    id?: true
    orderId?: true
    reviewerId?: true
    revieweeId?: true
    providerId?: true
    rating?: true
    comment?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reviews to aggregate.
     */
    where?: reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reviews
    **/
    _count?: true | ReviewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewsMaxAggregateInputType
  }

  export type GetReviewsAggregateType<T extends ReviewsAggregateArgs> = {
        [P in keyof T & keyof AggregateReviews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviews[P]>
      : GetScalarType<T[P], AggregateReviews[P]>
  }




  export type reviewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewsWhereInput
    orderBy?: reviewsOrderByWithAggregationInput | reviewsOrderByWithAggregationInput[]
    by: ReviewsScalarFieldEnum[] | ReviewsScalarFieldEnum
    having?: reviewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewsCountAggregateInputType | true
    _avg?: ReviewsAvgAggregateInputType
    _sum?: ReviewsSumAggregateInputType
    _min?: ReviewsMinAggregateInputType
    _max?: ReviewsMaxAggregateInputType
  }

  export type ReviewsGroupByOutputType = {
    id: string
    orderId: string
    reviewerId: string
    revieweeId: string
    providerId: string | null
    rating: number
    comment: string | null
    createdAt: Date
    _count: ReviewsCountAggregateOutputType | null
    _avg: ReviewsAvgAggregateOutputType | null
    _sum: ReviewsSumAggregateOutputType | null
    _min: ReviewsMinAggregateOutputType | null
    _max: ReviewsMaxAggregateOutputType | null
  }

  type GetReviewsGroupByPayload<T extends reviewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewsGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewsGroupByOutputType[P]>
        }
      >
    >


  export type reviewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    reviewerId?: boolean
    revieweeId?: boolean
    providerId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    orders?: boolean | ordersDefaultArgs<ExtArgs>
    providers?: boolean | reviews$providersArgs<ExtArgs>
    users_reviews_revieweeIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_reviews_reviewerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviews"]>

  export type reviewsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    reviewerId?: boolean
    revieweeId?: boolean
    providerId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    orders?: boolean | ordersDefaultArgs<ExtArgs>
    providers?: boolean | reviews$providersArgs<ExtArgs>
    users_reviews_revieweeIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_reviews_reviewerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviews"]>

  export type reviewsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    reviewerId?: boolean
    revieweeId?: boolean
    providerId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    orders?: boolean | ordersDefaultArgs<ExtArgs>
    providers?: boolean | reviews$providersArgs<ExtArgs>
    users_reviews_revieweeIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_reviews_reviewerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviews"]>

  export type reviewsSelectScalar = {
    id?: boolean
    orderId?: boolean
    reviewerId?: boolean
    revieweeId?: boolean
    providerId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
  }

  export type reviewsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "reviewerId" | "revieweeId" | "providerId" | "rating" | "comment" | "createdAt", ExtArgs["result"]["reviews"]>
  export type reviewsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | ordersDefaultArgs<ExtArgs>
    providers?: boolean | reviews$providersArgs<ExtArgs>
    users_reviews_revieweeIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_reviews_reviewerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type reviewsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | ordersDefaultArgs<ExtArgs>
    providers?: boolean | reviews$providersArgs<ExtArgs>
    users_reviews_revieweeIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_reviews_reviewerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type reviewsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | ordersDefaultArgs<ExtArgs>
    providers?: boolean | reviews$providersArgs<ExtArgs>
    users_reviews_revieweeIdTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_reviews_reviewerIdTousers?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $reviewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reviews"
    objects: {
      orders: Prisma.$ordersPayload<ExtArgs>
      providers: Prisma.$providersPayload<ExtArgs> | null
      users_reviews_revieweeIdTousers: Prisma.$usersPayload<ExtArgs>
      users_reviews_reviewerIdTousers: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      reviewerId: string
      revieweeId: string
      providerId: string | null
      rating: number
      comment: string | null
      createdAt: Date
    }, ExtArgs["result"]["reviews"]>
    composites: {}
  }

  type reviewsGetPayload<S extends boolean | null | undefined | reviewsDefaultArgs> = $Result.GetResult<Prisma.$reviewsPayload, S>

  type reviewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reviewsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewsCountAggregateInputType | true
    }

  export interface reviewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reviews'], meta: { name: 'reviews' } }
    /**
     * Find zero or one Reviews that matches the filter.
     * @param {reviewsFindUniqueArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reviewsFindUniqueArgs>(args: SelectSubset<T, reviewsFindUniqueArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reviews that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reviewsFindUniqueOrThrowArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reviewsFindUniqueOrThrowArgs>(args: SelectSubset<T, reviewsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsFindFirstArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reviewsFindFirstArgs>(args?: SelectSubset<T, reviewsFindFirstArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reviews that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsFindFirstOrThrowArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reviewsFindFirstOrThrowArgs>(args?: SelectSubset<T, reviewsFindFirstOrThrowArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.reviews.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.reviews.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewsWithIdOnly = await prisma.reviews.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends reviewsFindManyArgs>(args?: SelectSubset<T, reviewsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reviews.
     * @param {reviewsCreateArgs} args - Arguments to create a Reviews.
     * @example
     * // Create one Reviews
     * const Reviews = await prisma.reviews.create({
     *   data: {
     *     // ... data to create a Reviews
     *   }
     * })
     * 
     */
    create<T extends reviewsCreateArgs>(args: SelectSubset<T, reviewsCreateArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {reviewsCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const reviews = await prisma.reviews.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reviewsCreateManyArgs>(args?: SelectSubset<T, reviewsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {reviewsCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const reviews = await prisma.reviews.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewsWithIdOnly = await prisma.reviews.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends reviewsCreateManyAndReturnArgs>(args?: SelectSubset<T, reviewsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reviews.
     * @param {reviewsDeleteArgs} args - Arguments to delete one Reviews.
     * @example
     * // Delete one Reviews
     * const Reviews = await prisma.reviews.delete({
     *   where: {
     *     // ... filter to delete one Reviews
     *   }
     * })
     * 
     */
    delete<T extends reviewsDeleteArgs>(args: SelectSubset<T, reviewsDeleteArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reviews.
     * @param {reviewsUpdateArgs} args - Arguments to update one Reviews.
     * @example
     * // Update one Reviews
     * const reviews = await prisma.reviews.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reviewsUpdateArgs>(args: SelectSubset<T, reviewsUpdateArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {reviewsDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.reviews.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reviewsDeleteManyArgs>(args?: SelectSubset<T, reviewsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const reviews = await prisma.reviews.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reviewsUpdateManyArgs>(args: SelectSubset<T, reviewsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {reviewsUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const reviews = await prisma.reviews.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewsWithIdOnly = await prisma.reviews.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends reviewsUpdateManyAndReturnArgs>(args: SelectSubset<T, reviewsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reviews.
     * @param {reviewsUpsertArgs} args - Arguments to update or create a Reviews.
     * @example
     * // Update or create a Reviews
     * const reviews = await prisma.reviews.upsert({
     *   create: {
     *     // ... data to create a Reviews
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reviews we want to update
     *   }
     * })
     */
    upsert<T extends reviewsUpsertArgs>(args: SelectSubset<T, reviewsUpsertArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.reviews.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends reviewsCountArgs>(
      args?: Subset<T, reviewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewsAggregateArgs>(args: Subset<T, ReviewsAggregateArgs>): Prisma.PrismaPromise<GetReviewsAggregateType<T>>

    /**
     * Group by Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reviewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reviewsGroupByArgs['orderBy'] }
        : { orderBy?: reviewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reviewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reviews model
   */
  readonly fields: reviewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reviews.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reviewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends ordersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ordersDefaultArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    providers<T extends reviews$providersArgs<ExtArgs> = {}>(args?: Subset<T, reviews$providersArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users_reviews_revieweeIdTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users_reviews_reviewerIdTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reviews model
   */
  interface reviewsFieldRefs {
    readonly id: FieldRef<"reviews", 'String'>
    readonly orderId: FieldRef<"reviews", 'String'>
    readonly reviewerId: FieldRef<"reviews", 'String'>
    readonly revieweeId: FieldRef<"reviews", 'String'>
    readonly providerId: FieldRef<"reviews", 'String'>
    readonly rating: FieldRef<"reviews", 'Int'>
    readonly comment: FieldRef<"reviews", 'String'>
    readonly createdAt: FieldRef<"reviews", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * reviews findUnique
   */
  export type reviewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where: reviewsWhereUniqueInput
  }

  /**
   * reviews findUniqueOrThrow
   */
  export type reviewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where: reviewsWhereUniqueInput
  }

  /**
   * reviews findFirst
   */
  export type reviewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where?: reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviews.
     */
    cursor?: reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviews.
     */
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * reviews findFirstOrThrow
   */
  export type reviewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where?: reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviews.
     */
    cursor?: reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviews.
     */
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * reviews findMany
   */
  export type reviewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where?: reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reviews.
     */
    cursor?: reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * reviews create
   */
  export type reviewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * The data needed to create a reviews.
     */
    data: XOR<reviewsCreateInput, reviewsUncheckedCreateInput>
  }

  /**
   * reviews createMany
   */
  export type reviewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reviews.
     */
    data: reviewsCreateManyInput | reviewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reviews createManyAndReturn
   */
  export type reviewsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * The data used to create many reviews.
     */
    data: reviewsCreateManyInput | reviewsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * reviews update
   */
  export type reviewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * The data needed to update a reviews.
     */
    data: XOR<reviewsUpdateInput, reviewsUncheckedUpdateInput>
    /**
     * Choose, which reviews to update.
     */
    where: reviewsWhereUniqueInput
  }

  /**
   * reviews updateMany
   */
  export type reviewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reviews.
     */
    data: XOR<reviewsUpdateManyMutationInput, reviewsUncheckedUpdateManyInput>
    /**
     * Filter which reviews to update
     */
    where?: reviewsWhereInput
    /**
     * Limit how many reviews to update.
     */
    limit?: number
  }

  /**
   * reviews updateManyAndReturn
   */
  export type reviewsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * The data used to update reviews.
     */
    data: XOR<reviewsUpdateManyMutationInput, reviewsUncheckedUpdateManyInput>
    /**
     * Filter which reviews to update
     */
    where?: reviewsWhereInput
    /**
     * Limit how many reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * reviews upsert
   */
  export type reviewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * The filter to search for the reviews to update in case it exists.
     */
    where: reviewsWhereUniqueInput
    /**
     * In case the reviews found by the `where` argument doesn't exist, create a new reviews with this data.
     */
    create: XOR<reviewsCreateInput, reviewsUncheckedCreateInput>
    /**
     * In case the reviews was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reviewsUpdateInput, reviewsUncheckedUpdateInput>
  }

  /**
   * reviews delete
   */
  export type reviewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter which reviews to delete.
     */
    where: reviewsWhereUniqueInput
  }

  /**
   * reviews deleteMany
   */
  export type reviewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reviews to delete
     */
    where?: reviewsWhereInput
    /**
     * Limit how many reviews to delete.
     */
    limit?: number
  }

  /**
   * reviews.providers
   */
  export type reviews$providersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    where?: providersWhereInput
  }

  /**
   * reviews without action
   */
  export type reviewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
  }


  /**
   * Model services
   */

  export type AggregateServices = {
    _count: ServicesCountAggregateOutputType | null
    _avg: ServicesAvgAggregateOutputType | null
    _sum: ServicesSumAggregateOutputType | null
    _min: ServicesMinAggregateOutputType | null
    _max: ServicesMaxAggregateOutputType | null
  }

  export type ServicesAvgAggregateOutputType = {
    price: number | null
    basePrice: number | null
    offerPercent: number | null
    estimatedTime: number | null
    warrantyMonths: number | null
    duration: number | null
  }

  export type ServicesSumAggregateOutputType = {
    price: number | null
    basePrice: number | null
    offerPercent: number | null
    estimatedTime: number | null
    warrantyMonths: number | null
    duration: number | null
  }

  export type ServicesMinAggregateOutputType = {
    id: string | null
    providerId: string | null
    name: string | null
    description: string | null
    category: string | null
    price: number | null
    basePrice: number | null
    offerPercent: number | null
    estimatedTime: number | null
    warrantyMonths: number | null
    duration: number | null
    status: string | null
    isActive: boolean | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServicesMaxAggregateOutputType = {
    id: string | null
    providerId: string | null
    name: string | null
    description: string | null
    category: string | null
    price: number | null
    basePrice: number | null
    offerPercent: number | null
    estimatedTime: number | null
    warrantyMonths: number | null
    duration: number | null
    status: string | null
    isActive: boolean | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServicesCountAggregateOutputType = {
    id: number
    providerId: number
    name: number
    description: number
    category: number
    price: number
    basePrice: number
    offerPercent: number
    estimatedTime: number
    warrantyMonths: number
    duration: number
    status: number
    isActive: number
    rejectionReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServicesAvgAggregateInputType = {
    price?: true
    basePrice?: true
    offerPercent?: true
    estimatedTime?: true
    warrantyMonths?: true
    duration?: true
  }

  export type ServicesSumAggregateInputType = {
    price?: true
    basePrice?: true
    offerPercent?: true
    estimatedTime?: true
    warrantyMonths?: true
    duration?: true
  }

  export type ServicesMinAggregateInputType = {
    id?: true
    providerId?: true
    name?: true
    description?: true
    category?: true
    price?: true
    basePrice?: true
    offerPercent?: true
    estimatedTime?: true
    warrantyMonths?: true
    duration?: true
    status?: true
    isActive?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServicesMaxAggregateInputType = {
    id?: true
    providerId?: true
    name?: true
    description?: true
    category?: true
    price?: true
    basePrice?: true
    offerPercent?: true
    estimatedTime?: true
    warrantyMonths?: true
    duration?: true
    status?: true
    isActive?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServicesCountAggregateInputType = {
    id?: true
    providerId?: true
    name?: true
    description?: true
    category?: true
    price?: true
    basePrice?: true
    offerPercent?: true
    estimatedTime?: true
    warrantyMonths?: true
    duration?: true
    status?: true
    isActive?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which services to aggregate.
     */
    where?: servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: servicesOrderByWithRelationInput | servicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned services
    **/
    _count?: true | ServicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicesMaxAggregateInputType
  }

  export type GetServicesAggregateType<T extends ServicesAggregateArgs> = {
        [P in keyof T & keyof AggregateServices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServices[P]>
      : GetScalarType<T[P], AggregateServices[P]>
  }




  export type servicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: servicesWhereInput
    orderBy?: servicesOrderByWithAggregationInput | servicesOrderByWithAggregationInput[]
    by: ServicesScalarFieldEnum[] | ServicesScalarFieldEnum
    having?: servicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicesCountAggregateInputType | true
    _avg?: ServicesAvgAggregateInputType
    _sum?: ServicesSumAggregateInputType
    _min?: ServicesMinAggregateInputType
    _max?: ServicesMaxAggregateInputType
  }

  export type ServicesGroupByOutputType = {
    id: string
    providerId: string
    name: string
    description: string
    category: string
    price: number
    basePrice: number | null
    offerPercent: number | null
    estimatedTime: number | null
    warrantyMonths: number | null
    duration: number
    status: string
    isActive: boolean
    rejectionReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: ServicesCountAggregateOutputType | null
    _avg: ServicesAvgAggregateOutputType | null
    _sum: ServicesSumAggregateOutputType | null
    _min: ServicesMinAggregateOutputType | null
    _max: ServicesMaxAggregateOutputType | null
  }

  type GetServicesGroupByPayload<T extends servicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicesGroupByOutputType[P]>
            : GetScalarType<T[P], ServicesGroupByOutputType[P]>
        }
      >
    >


  export type servicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    price?: boolean
    basePrice?: boolean
    offerPercent?: boolean
    estimatedTime?: boolean
    warrantyMonths?: boolean
    duration?: boolean
    status?: boolean
    isActive?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orders?: boolean | services$ordersArgs<ExtArgs>
    providers?: boolean | providersDefaultArgs<ExtArgs>
    _count?: boolean | ServicesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["services"]>

  export type servicesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    price?: boolean
    basePrice?: boolean
    offerPercent?: boolean
    estimatedTime?: boolean
    warrantyMonths?: boolean
    duration?: boolean
    status?: boolean
    isActive?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    providers?: boolean | providersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["services"]>

  export type servicesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    price?: boolean
    basePrice?: boolean
    offerPercent?: boolean
    estimatedTime?: boolean
    warrantyMonths?: boolean
    duration?: boolean
    status?: boolean
    isActive?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    providers?: boolean | providersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["services"]>

  export type servicesSelectScalar = {
    id?: boolean
    providerId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    price?: boolean
    basePrice?: boolean
    offerPercent?: boolean
    estimatedTime?: boolean
    warrantyMonths?: boolean
    duration?: boolean
    status?: boolean
    isActive?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type servicesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "providerId" | "name" | "description" | "category" | "price" | "basePrice" | "offerPercent" | "estimatedTime" | "warrantyMonths" | "duration" | "status" | "isActive" | "rejectionReason" | "createdAt" | "updatedAt", ExtArgs["result"]["services"]>
  export type servicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | services$ordersArgs<ExtArgs>
    providers?: boolean | providersDefaultArgs<ExtArgs>
    _count?: boolean | ServicesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type servicesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | providersDefaultArgs<ExtArgs>
  }
  export type servicesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | providersDefaultArgs<ExtArgs>
  }

  export type $servicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "services"
    objects: {
      orders: Prisma.$ordersPayload<ExtArgs>[]
      providers: Prisma.$providersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      providerId: string
      name: string
      description: string
      category: string
      price: number
      basePrice: number | null
      offerPercent: number | null
      estimatedTime: number | null
      warrantyMonths: number | null
      duration: number
      status: string
      isActive: boolean
      rejectionReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["services"]>
    composites: {}
  }

  type servicesGetPayload<S extends boolean | null | undefined | servicesDefaultArgs> = $Result.GetResult<Prisma.$servicesPayload, S>

  type servicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<servicesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServicesCountAggregateInputType | true
    }

  export interface servicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['services'], meta: { name: 'services' } }
    /**
     * Find zero or one Services that matches the filter.
     * @param {servicesFindUniqueArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends servicesFindUniqueArgs>(args: SelectSubset<T, servicesFindUniqueArgs<ExtArgs>>): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Services that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {servicesFindUniqueOrThrowArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends servicesFindUniqueOrThrowArgs>(args: SelectSubset<T, servicesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesFindFirstArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends servicesFindFirstArgs>(args?: SelectSubset<T, servicesFindFirstArgs<ExtArgs>>): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Services that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesFindFirstOrThrowArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends servicesFindFirstOrThrowArgs>(args?: SelectSubset<T, servicesFindFirstOrThrowArgs<ExtArgs>>): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.services.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.services.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicesWithIdOnly = await prisma.services.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends servicesFindManyArgs>(args?: SelectSubset<T, servicesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Services.
     * @param {servicesCreateArgs} args - Arguments to create a Services.
     * @example
     * // Create one Services
     * const Services = await prisma.services.create({
     *   data: {
     *     // ... data to create a Services
     *   }
     * })
     * 
     */
    create<T extends servicesCreateArgs>(args: SelectSubset<T, servicesCreateArgs<ExtArgs>>): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {servicesCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const services = await prisma.services.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends servicesCreateManyArgs>(args?: SelectSubset<T, servicesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {servicesCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const services = await prisma.services.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const servicesWithIdOnly = await prisma.services.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends servicesCreateManyAndReturnArgs>(args?: SelectSubset<T, servicesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Services.
     * @param {servicesDeleteArgs} args - Arguments to delete one Services.
     * @example
     * // Delete one Services
     * const Services = await prisma.services.delete({
     *   where: {
     *     // ... filter to delete one Services
     *   }
     * })
     * 
     */
    delete<T extends servicesDeleteArgs>(args: SelectSubset<T, servicesDeleteArgs<ExtArgs>>): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Services.
     * @param {servicesUpdateArgs} args - Arguments to update one Services.
     * @example
     * // Update one Services
     * const services = await prisma.services.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends servicesUpdateArgs>(args: SelectSubset<T, servicesUpdateArgs<ExtArgs>>): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {servicesDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.services.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends servicesDeleteManyArgs>(args?: SelectSubset<T, servicesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const services = await prisma.services.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends servicesUpdateManyArgs>(args: SelectSubset<T, servicesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {servicesUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const services = await prisma.services.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const servicesWithIdOnly = await prisma.services.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends servicesUpdateManyAndReturnArgs>(args: SelectSubset<T, servicesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Services.
     * @param {servicesUpsertArgs} args - Arguments to update or create a Services.
     * @example
     * // Update or create a Services
     * const services = await prisma.services.upsert({
     *   create: {
     *     // ... data to create a Services
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Services we want to update
     *   }
     * })
     */
    upsert<T extends servicesUpsertArgs>(args: SelectSubset<T, servicesUpsertArgs<ExtArgs>>): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.services.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends servicesCountArgs>(
      args?: Subset<T, servicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicesAggregateArgs>(args: Subset<T, ServicesAggregateArgs>): Prisma.PrismaPromise<GetServicesAggregateType<T>>

    /**
     * Group by Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends servicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: servicesGroupByArgs['orderBy'] }
        : { orderBy?: servicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, servicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the services model
   */
  readonly fields: servicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for services.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__servicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends services$ordersArgs<ExtArgs> = {}>(args?: Subset<T, services$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    providers<T extends providersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, providersDefaultArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the services model
   */
  interface servicesFieldRefs {
    readonly id: FieldRef<"services", 'String'>
    readonly providerId: FieldRef<"services", 'String'>
    readonly name: FieldRef<"services", 'String'>
    readonly description: FieldRef<"services", 'String'>
    readonly category: FieldRef<"services", 'String'>
    readonly price: FieldRef<"services", 'Float'>
    readonly basePrice: FieldRef<"services", 'Float'>
    readonly offerPercent: FieldRef<"services", 'Int'>
    readonly estimatedTime: FieldRef<"services", 'Int'>
    readonly warrantyMonths: FieldRef<"services", 'Int'>
    readonly duration: FieldRef<"services", 'Int'>
    readonly status: FieldRef<"services", 'String'>
    readonly isActive: FieldRef<"services", 'Boolean'>
    readonly rejectionReason: FieldRef<"services", 'String'>
    readonly createdAt: FieldRef<"services", 'DateTime'>
    readonly updatedAt: FieldRef<"services", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * services findUnique
   */
  export type servicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * Filter, which services to fetch.
     */
    where: servicesWhereUniqueInput
  }

  /**
   * services findUniqueOrThrow
   */
  export type servicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * Filter, which services to fetch.
     */
    where: servicesWhereUniqueInput
  }

  /**
   * services findFirst
   */
  export type servicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * Filter, which services to fetch.
     */
    where?: servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: servicesOrderByWithRelationInput | servicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for services.
     */
    cursor?: servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of services.
     */
    distinct?: ServicesScalarFieldEnum | ServicesScalarFieldEnum[]
  }

  /**
   * services findFirstOrThrow
   */
  export type servicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * Filter, which services to fetch.
     */
    where?: servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: servicesOrderByWithRelationInput | servicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for services.
     */
    cursor?: servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of services.
     */
    distinct?: ServicesScalarFieldEnum | ServicesScalarFieldEnum[]
  }

  /**
   * services findMany
   */
  export type servicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * Filter, which services to fetch.
     */
    where?: servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: servicesOrderByWithRelationInput | servicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing services.
     */
    cursor?: servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    distinct?: ServicesScalarFieldEnum | ServicesScalarFieldEnum[]
  }

  /**
   * services create
   */
  export type servicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * The data needed to create a services.
     */
    data: XOR<servicesCreateInput, servicesUncheckedCreateInput>
  }

  /**
   * services createMany
   */
  export type servicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many services.
     */
    data: servicesCreateManyInput | servicesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * services createManyAndReturn
   */
  export type servicesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * The data used to create many services.
     */
    data: servicesCreateManyInput | servicesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * services update
   */
  export type servicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * The data needed to update a services.
     */
    data: XOR<servicesUpdateInput, servicesUncheckedUpdateInput>
    /**
     * Choose, which services to update.
     */
    where: servicesWhereUniqueInput
  }

  /**
   * services updateMany
   */
  export type servicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update services.
     */
    data: XOR<servicesUpdateManyMutationInput, servicesUncheckedUpdateManyInput>
    /**
     * Filter which services to update
     */
    where?: servicesWhereInput
    /**
     * Limit how many services to update.
     */
    limit?: number
  }

  /**
   * services updateManyAndReturn
   */
  export type servicesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * The data used to update services.
     */
    data: XOR<servicesUpdateManyMutationInput, servicesUncheckedUpdateManyInput>
    /**
     * Filter which services to update
     */
    where?: servicesWhereInput
    /**
     * Limit how many services to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * services upsert
   */
  export type servicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * The filter to search for the services to update in case it exists.
     */
    where: servicesWhereUniqueInput
    /**
     * In case the services found by the `where` argument doesn't exist, create a new services with this data.
     */
    create: XOR<servicesCreateInput, servicesUncheckedCreateInput>
    /**
     * In case the services was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicesUpdateInput, servicesUncheckedUpdateInput>
  }

  /**
   * services delete
   */
  export type servicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * Filter which services to delete.
     */
    where: servicesWhereUniqueInput
  }

  /**
   * services deleteMany
   */
  export type servicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which services to delete
     */
    where?: servicesWhereInput
    /**
     * Limit how many services to delete.
     */
    limit?: number
  }

  /**
   * services.orders
   */
  export type services$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    where?: ordersWhereInput
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    cursor?: ordersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * services without action
   */
  export type servicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesInclude<ExtArgs> | null
  }


  /**
   * Model tickets
   */

  export type AggregateTickets = {
    _count: TicketsCountAggregateOutputType | null
    _min: TicketsMinAggregateOutputType | null
    _max: TicketsMaxAggregateOutputType | null
  }

  export type TicketsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    subject: string | null
    description: string | null
    status: string | null
    priority: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    subject: string | null
    description: string | null
    status: string | null
    priority: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketsCountAggregateOutputType = {
    id: number
    userId: number
    subject: number
    description: number
    status: number
    priority: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TicketsMinAggregateInputType = {
    id?: true
    userId?: true
    subject?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketsMaxAggregateInputType = {
    id?: true
    userId?: true
    subject?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketsCountAggregateInputType = {
    id?: true
    userId?: true
    subject?: true
    description?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TicketsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tickets to aggregate.
     */
    where?: ticketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tickets to fetch.
     */
    orderBy?: ticketsOrderByWithRelationInput | ticketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ticketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tickets
    **/
    _count?: true | TicketsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketsMaxAggregateInputType
  }

  export type GetTicketsAggregateType<T extends TicketsAggregateArgs> = {
        [P in keyof T & keyof AggregateTickets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTickets[P]>
      : GetScalarType<T[P], AggregateTickets[P]>
  }




  export type ticketsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ticketsWhereInput
    orderBy?: ticketsOrderByWithAggregationInput | ticketsOrderByWithAggregationInput[]
    by: TicketsScalarFieldEnum[] | TicketsScalarFieldEnum
    having?: ticketsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketsCountAggregateInputType | true
    _min?: TicketsMinAggregateInputType
    _max?: TicketsMaxAggregateInputType
  }

  export type TicketsGroupByOutputType = {
    id: string
    userId: string
    subject: string
    description: string
    status: string
    priority: string
    createdAt: Date
    updatedAt: Date
    _count: TicketsCountAggregateOutputType | null
    _min: TicketsMinAggregateOutputType | null
    _max: TicketsMaxAggregateOutputType | null
  }

  type GetTicketsGroupByPayload<T extends ticketsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketsGroupByOutputType[P]>
            : GetScalarType<T[P], TicketsGroupByOutputType[P]>
        }
      >
    >


  export type ticketsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subject?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tickets"]>

  export type ticketsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subject?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tickets"]>

  export type ticketsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subject?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tickets"]>

  export type ticketsSelectScalar = {
    id?: boolean
    userId?: boolean
    subject?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ticketsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "subject" | "description" | "status" | "priority" | "createdAt" | "updatedAt", ExtArgs["result"]["tickets"]>
  export type ticketsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type ticketsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type ticketsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $ticketsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tickets"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      subject: string
      description: string
      status: string
      priority: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tickets"]>
    composites: {}
  }

  type ticketsGetPayload<S extends boolean | null | undefined | ticketsDefaultArgs> = $Result.GetResult<Prisma.$ticketsPayload, S>

  type ticketsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ticketsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketsCountAggregateInputType | true
    }

  export interface ticketsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tickets'], meta: { name: 'tickets' } }
    /**
     * Find zero or one Tickets that matches the filter.
     * @param {ticketsFindUniqueArgs} args - Arguments to find a Tickets
     * @example
     * // Get one Tickets
     * const tickets = await prisma.tickets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ticketsFindUniqueArgs>(args: SelectSubset<T, ticketsFindUniqueArgs<ExtArgs>>): Prisma__ticketsClient<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tickets that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ticketsFindUniqueOrThrowArgs} args - Arguments to find a Tickets
     * @example
     * // Get one Tickets
     * const tickets = await prisma.tickets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ticketsFindUniqueOrThrowArgs>(args: SelectSubset<T, ticketsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ticketsClient<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ticketsFindFirstArgs} args - Arguments to find a Tickets
     * @example
     * // Get one Tickets
     * const tickets = await prisma.tickets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ticketsFindFirstArgs>(args?: SelectSubset<T, ticketsFindFirstArgs<ExtArgs>>): Prisma__ticketsClient<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tickets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ticketsFindFirstOrThrowArgs} args - Arguments to find a Tickets
     * @example
     * // Get one Tickets
     * const tickets = await prisma.tickets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ticketsFindFirstOrThrowArgs>(args?: SelectSubset<T, ticketsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ticketsClient<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ticketsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.tickets.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.tickets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketsWithIdOnly = await prisma.tickets.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ticketsFindManyArgs>(args?: SelectSubset<T, ticketsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tickets.
     * @param {ticketsCreateArgs} args - Arguments to create a Tickets.
     * @example
     * // Create one Tickets
     * const Tickets = await prisma.tickets.create({
     *   data: {
     *     // ... data to create a Tickets
     *   }
     * })
     * 
     */
    create<T extends ticketsCreateArgs>(args: SelectSubset<T, ticketsCreateArgs<ExtArgs>>): Prisma__ticketsClient<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tickets.
     * @param {ticketsCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const tickets = await prisma.tickets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ticketsCreateManyArgs>(args?: SelectSubset<T, ticketsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tickets and returns the data saved in the database.
     * @param {ticketsCreateManyAndReturnArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const tickets = await prisma.tickets.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tickets and only return the `id`
     * const ticketsWithIdOnly = await prisma.tickets.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ticketsCreateManyAndReturnArgs>(args?: SelectSubset<T, ticketsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tickets.
     * @param {ticketsDeleteArgs} args - Arguments to delete one Tickets.
     * @example
     * // Delete one Tickets
     * const Tickets = await prisma.tickets.delete({
     *   where: {
     *     // ... filter to delete one Tickets
     *   }
     * })
     * 
     */
    delete<T extends ticketsDeleteArgs>(args: SelectSubset<T, ticketsDeleteArgs<ExtArgs>>): Prisma__ticketsClient<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tickets.
     * @param {ticketsUpdateArgs} args - Arguments to update one Tickets.
     * @example
     * // Update one Tickets
     * const tickets = await prisma.tickets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ticketsUpdateArgs>(args: SelectSubset<T, ticketsUpdateArgs<ExtArgs>>): Prisma__ticketsClient<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tickets.
     * @param {ticketsDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.tickets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ticketsDeleteManyArgs>(args?: SelectSubset<T, ticketsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ticketsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const tickets = await prisma.tickets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ticketsUpdateManyArgs>(args: SelectSubset<T, ticketsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets and returns the data updated in the database.
     * @param {ticketsUpdateManyAndReturnArgs} args - Arguments to update many Tickets.
     * @example
     * // Update many Tickets
     * const tickets = await prisma.tickets.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tickets and only return the `id`
     * const ticketsWithIdOnly = await prisma.tickets.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ticketsUpdateManyAndReturnArgs>(args: SelectSubset<T, ticketsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tickets.
     * @param {ticketsUpsertArgs} args - Arguments to update or create a Tickets.
     * @example
     * // Update or create a Tickets
     * const tickets = await prisma.tickets.upsert({
     *   create: {
     *     // ... data to create a Tickets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tickets we want to update
     *   }
     * })
     */
    upsert<T extends ticketsUpsertArgs>(args: SelectSubset<T, ticketsUpsertArgs<ExtArgs>>): Prisma__ticketsClient<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ticketsCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.tickets.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends ticketsCountArgs>(
      args?: Subset<T, ticketsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketsAggregateArgs>(args: Subset<T, TicketsAggregateArgs>): Prisma.PrismaPromise<GetTicketsAggregateType<T>>

    /**
     * Group by Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ticketsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ticketsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ticketsGroupByArgs['orderBy'] }
        : { orderBy?: ticketsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ticketsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tickets model
   */
  readonly fields: ticketsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tickets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ticketsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tickets model
   */
  interface ticketsFieldRefs {
    readonly id: FieldRef<"tickets", 'String'>
    readonly userId: FieldRef<"tickets", 'String'>
    readonly subject: FieldRef<"tickets", 'String'>
    readonly description: FieldRef<"tickets", 'String'>
    readonly status: FieldRef<"tickets", 'String'>
    readonly priority: FieldRef<"tickets", 'String'>
    readonly createdAt: FieldRef<"tickets", 'DateTime'>
    readonly updatedAt: FieldRef<"tickets", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tickets findUnique
   */
  export type ticketsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tickets
     */
    omit?: ticketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsInclude<ExtArgs> | null
    /**
     * Filter, which tickets to fetch.
     */
    where: ticketsWhereUniqueInput
  }

  /**
   * tickets findUniqueOrThrow
   */
  export type ticketsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tickets
     */
    omit?: ticketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsInclude<ExtArgs> | null
    /**
     * Filter, which tickets to fetch.
     */
    where: ticketsWhereUniqueInput
  }

  /**
   * tickets findFirst
   */
  export type ticketsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tickets
     */
    omit?: ticketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsInclude<ExtArgs> | null
    /**
     * Filter, which tickets to fetch.
     */
    where?: ticketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tickets to fetch.
     */
    orderBy?: ticketsOrderByWithRelationInput | ticketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tickets.
     */
    cursor?: ticketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tickets.
     */
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * tickets findFirstOrThrow
   */
  export type ticketsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tickets
     */
    omit?: ticketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsInclude<ExtArgs> | null
    /**
     * Filter, which tickets to fetch.
     */
    where?: ticketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tickets to fetch.
     */
    orderBy?: ticketsOrderByWithRelationInput | ticketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tickets.
     */
    cursor?: ticketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tickets.
     */
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * tickets findMany
   */
  export type ticketsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tickets
     */
    omit?: ticketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsInclude<ExtArgs> | null
    /**
     * Filter, which tickets to fetch.
     */
    where?: ticketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tickets to fetch.
     */
    orderBy?: ticketsOrderByWithRelationInput | ticketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tickets.
     */
    cursor?: ticketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tickets.
     */
    skip?: number
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * tickets create
   */
  export type ticketsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tickets
     */
    omit?: ticketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsInclude<ExtArgs> | null
    /**
     * The data needed to create a tickets.
     */
    data: XOR<ticketsCreateInput, ticketsUncheckedCreateInput>
  }

  /**
   * tickets createMany
   */
  export type ticketsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tickets.
     */
    data: ticketsCreateManyInput | ticketsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tickets createManyAndReturn
   */
  export type ticketsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tickets
     */
    omit?: ticketsOmit<ExtArgs> | null
    /**
     * The data used to create many tickets.
     */
    data: ticketsCreateManyInput | ticketsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tickets update
   */
  export type ticketsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tickets
     */
    omit?: ticketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsInclude<ExtArgs> | null
    /**
     * The data needed to update a tickets.
     */
    data: XOR<ticketsUpdateInput, ticketsUncheckedUpdateInput>
    /**
     * Choose, which tickets to update.
     */
    where: ticketsWhereUniqueInput
  }

  /**
   * tickets updateMany
   */
  export type ticketsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tickets.
     */
    data: XOR<ticketsUpdateManyMutationInput, ticketsUncheckedUpdateManyInput>
    /**
     * Filter which tickets to update
     */
    where?: ticketsWhereInput
    /**
     * Limit how many tickets to update.
     */
    limit?: number
  }

  /**
   * tickets updateManyAndReturn
   */
  export type ticketsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tickets
     */
    omit?: ticketsOmit<ExtArgs> | null
    /**
     * The data used to update tickets.
     */
    data: XOR<ticketsUpdateManyMutationInput, ticketsUncheckedUpdateManyInput>
    /**
     * Filter which tickets to update
     */
    where?: ticketsWhereInput
    /**
     * Limit how many tickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * tickets upsert
   */
  export type ticketsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tickets
     */
    omit?: ticketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsInclude<ExtArgs> | null
    /**
     * The filter to search for the tickets to update in case it exists.
     */
    where: ticketsWhereUniqueInput
    /**
     * In case the tickets found by the `where` argument doesn't exist, create a new tickets with this data.
     */
    create: XOR<ticketsCreateInput, ticketsUncheckedCreateInput>
    /**
     * In case the tickets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ticketsUpdateInput, ticketsUncheckedUpdateInput>
  }

  /**
   * tickets delete
   */
  export type ticketsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tickets
     */
    omit?: ticketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsInclude<ExtArgs> | null
    /**
     * Filter which tickets to delete.
     */
    where: ticketsWhereUniqueInput
  }

  /**
   * tickets deleteMany
   */
  export type ticketsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tickets to delete
     */
    where?: ticketsWhereInput
    /**
     * Limit how many tickets to delete.
     */
    limit?: number
  }

  /**
   * tickets without action
   */
  export type ticketsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tickets
     */
    omit?: ticketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsInclude<ExtArgs> | null
  }


  /**
   * Model transactions
   */

  export type AggregateTransactions = {
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  export type TransactionsAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransactionsSumAggregateOutputType = {
    amount: number | null
  }

  export type TransactionsMinAggregateOutputType = {
    id: string | null
    walletId: string | null
    amount: number | null
    type: $Enums.TransactionType | null
    description: string | null
    paymentMethod: $Enums.PaymentMethod | null
    orderId: string | null
    createdAt: Date | null
  }

  export type TransactionsMaxAggregateOutputType = {
    id: string | null
    walletId: string | null
    amount: number | null
    type: $Enums.TransactionType | null
    description: string | null
    paymentMethod: $Enums.PaymentMethod | null
    orderId: string | null
    createdAt: Date | null
  }

  export type TransactionsCountAggregateOutputType = {
    id: number
    walletId: number
    amount: number
    type: number
    description: number
    paymentMethod: number
    orderId: number
    createdAt: number
    _all: number
  }


  export type TransactionsAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionsSumAggregateInputType = {
    amount?: true
  }

  export type TransactionsMinAggregateInputType = {
    id?: true
    walletId?: true
    amount?: true
    type?: true
    description?: true
    paymentMethod?: true
    orderId?: true
    createdAt?: true
  }

  export type TransactionsMaxAggregateInputType = {
    id?: true
    walletId?: true
    amount?: true
    type?: true
    description?: true
    paymentMethod?: true
    orderId?: true
    createdAt?: true
  }

  export type TransactionsCountAggregateInputType = {
    id?: true
    walletId?: true
    amount?: true
    type?: true
    description?: true
    paymentMethod?: true
    orderId?: true
    createdAt?: true
    _all?: true
  }

  export type TransactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactions to aggregate.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transactions
    **/
    _count?: true | TransactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionsMaxAggregateInputType
  }

  export type GetTransactionsAggregateType<T extends TransactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactions[P]>
      : GetScalarType<T[P], AggregateTransactions[P]>
  }




  export type transactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionsWhereInput
    orderBy?: transactionsOrderByWithAggregationInput | transactionsOrderByWithAggregationInput[]
    by: TransactionsScalarFieldEnum[] | TransactionsScalarFieldEnum
    having?: transactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionsCountAggregateInputType | true
    _avg?: TransactionsAvgAggregateInputType
    _sum?: TransactionsSumAggregateInputType
    _min?: TransactionsMinAggregateInputType
    _max?: TransactionsMaxAggregateInputType
  }

  export type TransactionsGroupByOutputType = {
    id: string
    walletId: string
    amount: number
    type: $Enums.TransactionType
    description: string
    paymentMethod: $Enums.PaymentMethod | null
    orderId: string | null
    createdAt: Date
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  type GetTransactionsGroupByPayload<T extends transactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
        }
      >
    >


  export type transactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    amount?: boolean
    type?: boolean
    description?: boolean
    paymentMethod?: boolean
    orderId?: boolean
    createdAt?: boolean
    wallets?: boolean | walletsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>

  export type transactionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    amount?: boolean
    type?: boolean
    description?: boolean
    paymentMethod?: boolean
    orderId?: boolean
    createdAt?: boolean
    wallets?: boolean | walletsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>

  export type transactionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    amount?: boolean
    type?: boolean
    description?: boolean
    paymentMethod?: boolean
    orderId?: boolean
    createdAt?: boolean
    wallets?: boolean | walletsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>

  export type transactionsSelectScalar = {
    id?: boolean
    walletId?: boolean
    amount?: boolean
    type?: boolean
    description?: boolean
    paymentMethod?: boolean
    orderId?: boolean
    createdAt?: boolean
  }

  export type transactionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "walletId" | "amount" | "type" | "description" | "paymentMethod" | "orderId" | "createdAt", ExtArgs["result"]["transactions"]>
  export type transactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallets?: boolean | walletsDefaultArgs<ExtArgs>
  }
  export type transactionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallets?: boolean | walletsDefaultArgs<ExtArgs>
  }
  export type transactionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallets?: boolean | walletsDefaultArgs<ExtArgs>
  }

  export type $transactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transactions"
    objects: {
      wallets: Prisma.$walletsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      walletId: string
      amount: number
      type: $Enums.TransactionType
      description: string
      paymentMethod: $Enums.PaymentMethod | null
      orderId: string | null
      createdAt: Date
    }, ExtArgs["result"]["transactions"]>
    composites: {}
  }

  type transactionsGetPayload<S extends boolean | null | undefined | transactionsDefaultArgs> = $Result.GetResult<Prisma.$transactionsPayload, S>

  type transactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<transactionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionsCountAggregateInputType | true
    }

  export interface transactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transactions'], meta: { name: 'transactions' } }
    /**
     * Find zero or one Transactions that matches the filter.
     * @param {transactionsFindUniqueArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transactionsFindUniqueArgs>(args: SelectSubset<T, transactionsFindUniqueArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transactions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {transactionsFindUniqueOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, transactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsFindFirstArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transactionsFindFirstArgs>(args?: SelectSubset<T, transactionsFindFirstArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsFindFirstOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, transactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transactions.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionsWithIdOnly = await prisma.transactions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends transactionsFindManyArgs>(args?: SelectSubset<T, transactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transactions.
     * @param {transactionsCreateArgs} args - Arguments to create a Transactions.
     * @example
     * // Create one Transactions
     * const Transactions = await prisma.transactions.create({
     *   data: {
     *     // ... data to create a Transactions
     *   }
     * })
     * 
     */
    create<T extends transactionsCreateArgs>(args: SelectSubset<T, transactionsCreateArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {transactionsCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transactions = await prisma.transactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transactionsCreateManyArgs>(args?: SelectSubset<T, transactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {transactionsCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transactions = await prisma.transactions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionsWithIdOnly = await prisma.transactions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends transactionsCreateManyAndReturnArgs>(args?: SelectSubset<T, transactionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transactions.
     * @param {transactionsDeleteArgs} args - Arguments to delete one Transactions.
     * @example
     * // Delete one Transactions
     * const Transactions = await prisma.transactions.delete({
     *   where: {
     *     // ... filter to delete one Transactions
     *   }
     * })
     * 
     */
    delete<T extends transactionsDeleteArgs>(args: SelectSubset<T, transactionsDeleteArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transactions.
     * @param {transactionsUpdateArgs} args - Arguments to update one Transactions.
     * @example
     * // Update one Transactions
     * const transactions = await prisma.transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transactionsUpdateArgs>(args: SelectSubset<T, transactionsUpdateArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {transactionsDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transactionsDeleteManyArgs>(args?: SelectSubset<T, transactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transactions = await prisma.transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transactionsUpdateManyArgs>(args: SelectSubset<T, transactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {transactionsUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transactions = await prisma.transactions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionsWithIdOnly = await prisma.transactions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends transactionsUpdateManyAndReturnArgs>(args: SelectSubset<T, transactionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transactions.
     * @param {transactionsUpsertArgs} args - Arguments to update or create a Transactions.
     * @example
     * // Update or create a Transactions
     * const transactions = await prisma.transactions.upsert({
     *   create: {
     *     // ... data to create a Transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transactions we want to update
     *   }
     * })
     */
    upsert<T extends transactionsUpsertArgs>(args: SelectSubset<T, transactionsUpsertArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transactions.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends transactionsCountArgs>(
      args?: Subset<T, transactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionsAggregateArgs>(args: Subset<T, TransactionsAggregateArgs>): Prisma.PrismaPromise<GetTransactionsAggregateType<T>>

    /**
     * Group by Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transactionsGroupByArgs['orderBy'] }
        : { orderBy?: transactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transactions model
   */
  readonly fields: transactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wallets<T extends walletsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, walletsDefaultArgs<ExtArgs>>): Prisma__walletsClient<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transactions model
   */
  interface transactionsFieldRefs {
    readonly id: FieldRef<"transactions", 'String'>
    readonly walletId: FieldRef<"transactions", 'String'>
    readonly amount: FieldRef<"transactions", 'Float'>
    readonly type: FieldRef<"transactions", 'TransactionType'>
    readonly description: FieldRef<"transactions", 'String'>
    readonly paymentMethod: FieldRef<"transactions", 'PaymentMethod'>
    readonly orderId: FieldRef<"transactions", 'String'>
    readonly createdAt: FieldRef<"transactions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * transactions findUnique
   */
  export type transactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions findUniqueOrThrow
   */
  export type transactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions findFirst
   */
  export type transactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * transactions findFirstOrThrow
   */
  export type transactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * transactions findMany
   */
  export type transactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transactions.
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * transactions create
   */
  export type transactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a transactions.
     */
    data: XOR<transactionsCreateInput, transactionsUncheckedCreateInput>
  }

  /**
   * transactions createMany
   */
  export type transactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transactions.
     */
    data: transactionsCreateManyInput | transactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transactions createManyAndReturn
   */
  export type transactionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * The data used to create many transactions.
     */
    data: transactionsCreateManyInput | transactionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * transactions update
   */
  export type transactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a transactions.
     */
    data: XOR<transactionsUpdateInput, transactionsUncheckedUpdateInput>
    /**
     * Choose, which transactions to update.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions updateMany
   */
  export type transactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transactions.
     */
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyInput>
    /**
     * Filter which transactions to update
     */
    where?: transactionsWhereInput
    /**
     * Limit how many transactions to update.
     */
    limit?: number
  }

  /**
   * transactions updateManyAndReturn
   */
  export type transactionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * The data used to update transactions.
     */
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyInput>
    /**
     * Filter which transactions to update
     */
    where?: transactionsWhereInput
    /**
     * Limit how many transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * transactions upsert
   */
  export type transactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the transactions to update in case it exists.
     */
    where: transactionsWhereUniqueInput
    /**
     * In case the transactions found by the `where` argument doesn't exist, create a new transactions with this data.
     */
    create: XOR<transactionsCreateInput, transactionsUncheckedCreateInput>
    /**
     * In case the transactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transactionsUpdateInput, transactionsUncheckedUpdateInput>
  }

  /**
   * transactions delete
   */
  export type transactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter which transactions to delete.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions deleteMany
   */
  export type transactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactions to delete
     */
    where?: transactionsWhereInput
    /**
     * Limit how many transactions to delete.
     */
    limit?: number
  }

  /**
   * transactions without action
   */
  export type transactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
  }


  /**
   * Model user_payment_methods
   */

  export type AggregateUser_payment_methods = {
    _count: User_payment_methodsCountAggregateOutputType | null
    _min: User_payment_methodsMinAggregateOutputType | null
    _max: User_payment_methodsMaxAggregateOutputType | null
  }

  export type User_payment_methodsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    upiId: string | null
    cardNumber: string | null
    cardName: string | null
    expiryMonth: string | null
    expiryYear: string | null
    last4: string | null
    isDefault: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type User_payment_methodsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    upiId: string | null
    cardNumber: string | null
    cardName: string | null
    expiryMonth: string | null
    expiryYear: string | null
    last4: string | null
    isDefault: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type User_payment_methodsCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    upiId: number
    cardNumber: number
    cardName: number
    expiryMonth: number
    expiryYear: number
    last4: number
    isDefault: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type User_payment_methodsMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    upiId?: true
    cardNumber?: true
    cardName?: true
    expiryMonth?: true
    expiryYear?: true
    last4?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type User_payment_methodsMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    upiId?: true
    cardNumber?: true
    cardName?: true
    expiryMonth?: true
    expiryYear?: true
    last4?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type User_payment_methodsCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    upiId?: true
    cardNumber?: true
    cardName?: true
    expiryMonth?: true
    expiryYear?: true
    last4?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type User_payment_methodsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_payment_methods to aggregate.
     */
    where?: user_payment_methodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_payment_methods to fetch.
     */
    orderBy?: user_payment_methodsOrderByWithRelationInput | user_payment_methodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_payment_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_payment_methods
    **/
    _count?: true | User_payment_methodsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_payment_methodsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_payment_methodsMaxAggregateInputType
  }

  export type GetUser_payment_methodsAggregateType<T extends User_payment_methodsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_payment_methods]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_payment_methods[P]>
      : GetScalarType<T[P], AggregateUser_payment_methods[P]>
  }




  export type user_payment_methodsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_payment_methodsWhereInput
    orderBy?: user_payment_methodsOrderByWithAggregationInput | user_payment_methodsOrderByWithAggregationInput[]
    by: User_payment_methodsScalarFieldEnum[] | User_payment_methodsScalarFieldEnum
    having?: user_payment_methodsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_payment_methodsCountAggregateInputType | true
    _min?: User_payment_methodsMinAggregateInputType
    _max?: User_payment_methodsMaxAggregateInputType
  }

  export type User_payment_methodsGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string | null
    upiId: string | null
    cardNumber: string | null
    cardName: string | null
    expiryMonth: string | null
    expiryYear: string | null
    last4: string | null
    isDefault: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: User_payment_methodsCountAggregateOutputType | null
    _min: User_payment_methodsMinAggregateOutputType | null
    _max: User_payment_methodsMaxAggregateOutputType | null
  }

  type GetUser_payment_methodsGroupByPayload<T extends user_payment_methodsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_payment_methodsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_payment_methodsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_payment_methodsGroupByOutputType[P]>
            : GetScalarType<T[P], User_payment_methodsGroupByOutputType[P]>
        }
      >
    >


  export type user_payment_methodsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    upiId?: boolean
    cardNumber?: boolean
    cardName?: boolean
    expiryMonth?: boolean
    expiryYear?: boolean
    last4?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_payment_methods"]>

  export type user_payment_methodsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    upiId?: boolean
    cardNumber?: boolean
    cardName?: boolean
    expiryMonth?: boolean
    expiryYear?: boolean
    last4?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_payment_methods"]>

  export type user_payment_methodsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    upiId?: boolean
    cardNumber?: boolean
    cardName?: boolean
    expiryMonth?: boolean
    expiryYear?: boolean
    last4?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_payment_methods"]>

  export type user_payment_methodsSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    upiId?: boolean
    cardNumber?: boolean
    cardName?: boolean
    expiryMonth?: boolean
    expiryYear?: boolean
    last4?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type user_payment_methodsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "upiId" | "cardNumber" | "cardName" | "expiryMonth" | "expiryYear" | "last4" | "isDefault" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["user_payment_methods"]>
  export type user_payment_methodsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_payment_methodsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_payment_methodsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $user_payment_methodsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_payment_methods"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string | null
      upiId: string | null
      cardNumber: string | null
      cardName: string | null
      expiryMonth: string | null
      expiryYear: string | null
      last4: string | null
      isDefault: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user_payment_methods"]>
    composites: {}
  }

  type user_payment_methodsGetPayload<S extends boolean | null | undefined | user_payment_methodsDefaultArgs> = $Result.GetResult<Prisma.$user_payment_methodsPayload, S>

  type user_payment_methodsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_payment_methodsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_payment_methodsCountAggregateInputType | true
    }

  export interface user_payment_methodsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_payment_methods'], meta: { name: 'user_payment_methods' } }
    /**
     * Find zero or one User_payment_methods that matches the filter.
     * @param {user_payment_methodsFindUniqueArgs} args - Arguments to find a User_payment_methods
     * @example
     * // Get one User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_payment_methodsFindUniqueArgs>(args: SelectSubset<T, user_payment_methodsFindUniqueArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_payment_methods that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_payment_methodsFindUniqueOrThrowArgs} args - Arguments to find a User_payment_methods
     * @example
     * // Get one User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_payment_methodsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_payment_methodsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_payment_methods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_payment_methodsFindFirstArgs} args - Arguments to find a User_payment_methods
     * @example
     * // Get one User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_payment_methodsFindFirstArgs>(args?: SelectSubset<T, user_payment_methodsFindFirstArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_payment_methods that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_payment_methodsFindFirstOrThrowArgs} args - Arguments to find a User_payment_methods
     * @example
     * // Get one User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_payment_methodsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_payment_methodsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_payment_methods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_payment_methodsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.findMany()
     * 
     * // Get first 10 User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_payment_methodsWithIdOnly = await prisma.user_payment_methods.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_payment_methodsFindManyArgs>(args?: SelectSubset<T, user_payment_methodsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_payment_methods.
     * @param {user_payment_methodsCreateArgs} args - Arguments to create a User_payment_methods.
     * @example
     * // Create one User_payment_methods
     * const User_payment_methods = await prisma.user_payment_methods.create({
     *   data: {
     *     // ... data to create a User_payment_methods
     *   }
     * })
     * 
     */
    create<T extends user_payment_methodsCreateArgs>(args: SelectSubset<T, user_payment_methodsCreateArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_payment_methods.
     * @param {user_payment_methodsCreateManyArgs} args - Arguments to create many User_payment_methods.
     * @example
     * // Create many User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_payment_methodsCreateManyArgs>(args?: SelectSubset<T, user_payment_methodsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_payment_methods and returns the data saved in the database.
     * @param {user_payment_methodsCreateManyAndReturnArgs} args - Arguments to create many User_payment_methods.
     * @example
     * // Create many User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_payment_methods and only return the `id`
     * const user_payment_methodsWithIdOnly = await prisma.user_payment_methods.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_payment_methodsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_payment_methodsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_payment_methods.
     * @param {user_payment_methodsDeleteArgs} args - Arguments to delete one User_payment_methods.
     * @example
     * // Delete one User_payment_methods
     * const User_payment_methods = await prisma.user_payment_methods.delete({
     *   where: {
     *     // ... filter to delete one User_payment_methods
     *   }
     * })
     * 
     */
    delete<T extends user_payment_methodsDeleteArgs>(args: SelectSubset<T, user_payment_methodsDeleteArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_payment_methods.
     * @param {user_payment_methodsUpdateArgs} args - Arguments to update one User_payment_methods.
     * @example
     * // Update one User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_payment_methodsUpdateArgs>(args: SelectSubset<T, user_payment_methodsUpdateArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_payment_methods.
     * @param {user_payment_methodsDeleteManyArgs} args - Arguments to filter User_payment_methods to delete.
     * @example
     * // Delete a few User_payment_methods
     * const { count } = await prisma.user_payment_methods.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_payment_methodsDeleteManyArgs>(args?: SelectSubset<T, user_payment_methodsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_payment_methodsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_payment_methodsUpdateManyArgs>(args: SelectSubset<T, user_payment_methodsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_payment_methods and returns the data updated in the database.
     * @param {user_payment_methodsUpdateManyAndReturnArgs} args - Arguments to update many User_payment_methods.
     * @example
     * // Update many User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_payment_methods and only return the `id`
     * const user_payment_methodsWithIdOnly = await prisma.user_payment_methods.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_payment_methodsUpdateManyAndReturnArgs>(args: SelectSubset<T, user_payment_methodsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_payment_methods.
     * @param {user_payment_methodsUpsertArgs} args - Arguments to update or create a User_payment_methods.
     * @example
     * // Update or create a User_payment_methods
     * const user_payment_methods = await prisma.user_payment_methods.upsert({
     *   create: {
     *     // ... data to create a User_payment_methods
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_payment_methods we want to update
     *   }
     * })
     */
    upsert<T extends user_payment_methodsUpsertArgs>(args: SelectSubset<T, user_payment_methodsUpsertArgs<ExtArgs>>): Prisma__user_payment_methodsClient<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_payment_methodsCountArgs} args - Arguments to filter User_payment_methods to count.
     * @example
     * // Count the number of User_payment_methods
     * const count = await prisma.user_payment_methods.count({
     *   where: {
     *     // ... the filter for the User_payment_methods we want to count
     *   }
     * })
    **/
    count<T extends user_payment_methodsCountArgs>(
      args?: Subset<T, user_payment_methodsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_payment_methodsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_payment_methodsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_payment_methodsAggregateArgs>(args: Subset<T, User_payment_methodsAggregateArgs>): Prisma.PrismaPromise<GetUser_payment_methodsAggregateType<T>>

    /**
     * Group by User_payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_payment_methodsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_payment_methodsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_payment_methodsGroupByArgs['orderBy'] }
        : { orderBy?: user_payment_methodsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_payment_methodsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_payment_methodsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_payment_methods model
   */
  readonly fields: user_payment_methodsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_payment_methods.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_payment_methodsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_payment_methods model
   */
  interface user_payment_methodsFieldRefs {
    readonly id: FieldRef<"user_payment_methods", 'String'>
    readonly userId: FieldRef<"user_payment_methods", 'String'>
    readonly type: FieldRef<"user_payment_methods", 'String'>
    readonly provider: FieldRef<"user_payment_methods", 'String'>
    readonly upiId: FieldRef<"user_payment_methods", 'String'>
    readonly cardNumber: FieldRef<"user_payment_methods", 'String'>
    readonly cardName: FieldRef<"user_payment_methods", 'String'>
    readonly expiryMonth: FieldRef<"user_payment_methods", 'String'>
    readonly expiryYear: FieldRef<"user_payment_methods", 'String'>
    readonly last4: FieldRef<"user_payment_methods", 'String'>
    readonly isDefault: FieldRef<"user_payment_methods", 'Boolean'>
    readonly isActive: FieldRef<"user_payment_methods", 'Boolean'>
    readonly createdAt: FieldRef<"user_payment_methods", 'DateTime'>
    readonly updatedAt: FieldRef<"user_payment_methods", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_payment_methods findUnique
   */
  export type user_payment_methodsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which user_payment_methods to fetch.
     */
    where: user_payment_methodsWhereUniqueInput
  }

  /**
   * user_payment_methods findUniqueOrThrow
   */
  export type user_payment_methodsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which user_payment_methods to fetch.
     */
    where: user_payment_methodsWhereUniqueInput
  }

  /**
   * user_payment_methods findFirst
   */
  export type user_payment_methodsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which user_payment_methods to fetch.
     */
    where?: user_payment_methodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_payment_methods to fetch.
     */
    orderBy?: user_payment_methodsOrderByWithRelationInput | user_payment_methodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_payment_methods.
     */
    cursor?: user_payment_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_payment_methods.
     */
    distinct?: User_payment_methodsScalarFieldEnum | User_payment_methodsScalarFieldEnum[]
  }

  /**
   * user_payment_methods findFirstOrThrow
   */
  export type user_payment_methodsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which user_payment_methods to fetch.
     */
    where?: user_payment_methodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_payment_methods to fetch.
     */
    orderBy?: user_payment_methodsOrderByWithRelationInput | user_payment_methodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_payment_methods.
     */
    cursor?: user_payment_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_payment_methods.
     */
    distinct?: User_payment_methodsScalarFieldEnum | User_payment_methodsScalarFieldEnum[]
  }

  /**
   * user_payment_methods findMany
   */
  export type user_payment_methodsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which user_payment_methods to fetch.
     */
    where?: user_payment_methodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_payment_methods to fetch.
     */
    orderBy?: user_payment_methodsOrderByWithRelationInput | user_payment_methodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_payment_methods.
     */
    cursor?: user_payment_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_payment_methods.
     */
    skip?: number
    distinct?: User_payment_methodsScalarFieldEnum | User_payment_methodsScalarFieldEnum[]
  }

  /**
   * user_payment_methods create
   */
  export type user_payment_methodsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * The data needed to create a user_payment_methods.
     */
    data: XOR<user_payment_methodsCreateInput, user_payment_methodsUncheckedCreateInput>
  }

  /**
   * user_payment_methods createMany
   */
  export type user_payment_methodsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_payment_methods.
     */
    data: user_payment_methodsCreateManyInput | user_payment_methodsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_payment_methods createManyAndReturn
   */
  export type user_payment_methodsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * The data used to create many user_payment_methods.
     */
    data: user_payment_methodsCreateManyInput | user_payment_methodsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_payment_methods update
   */
  export type user_payment_methodsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * The data needed to update a user_payment_methods.
     */
    data: XOR<user_payment_methodsUpdateInput, user_payment_methodsUncheckedUpdateInput>
    /**
     * Choose, which user_payment_methods to update.
     */
    where: user_payment_methodsWhereUniqueInput
  }

  /**
   * user_payment_methods updateMany
   */
  export type user_payment_methodsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_payment_methods.
     */
    data: XOR<user_payment_methodsUpdateManyMutationInput, user_payment_methodsUncheckedUpdateManyInput>
    /**
     * Filter which user_payment_methods to update
     */
    where?: user_payment_methodsWhereInput
    /**
     * Limit how many user_payment_methods to update.
     */
    limit?: number
  }

  /**
   * user_payment_methods updateManyAndReturn
   */
  export type user_payment_methodsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * The data used to update user_payment_methods.
     */
    data: XOR<user_payment_methodsUpdateManyMutationInput, user_payment_methodsUncheckedUpdateManyInput>
    /**
     * Filter which user_payment_methods to update
     */
    where?: user_payment_methodsWhereInput
    /**
     * Limit how many user_payment_methods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_payment_methods upsert
   */
  export type user_payment_methodsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * The filter to search for the user_payment_methods to update in case it exists.
     */
    where: user_payment_methodsWhereUniqueInput
    /**
     * In case the user_payment_methods found by the `where` argument doesn't exist, create a new user_payment_methods with this data.
     */
    create: XOR<user_payment_methodsCreateInput, user_payment_methodsUncheckedCreateInput>
    /**
     * In case the user_payment_methods was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_payment_methodsUpdateInput, user_payment_methodsUncheckedUpdateInput>
  }

  /**
   * user_payment_methods delete
   */
  export type user_payment_methodsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    /**
     * Filter which user_payment_methods to delete.
     */
    where: user_payment_methodsWhereUniqueInput
  }

  /**
   * user_payment_methods deleteMany
   */
  export type user_payment_methodsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_payment_methods to delete
     */
    where?: user_payment_methodsWhereInput
    /**
     * Limit how many user_payment_methods to delete.
     */
    limit?: number
  }

  /**
   * user_payment_methods without action
   */
  export type user_payment_methodsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
  }


  /**
   * Model user_verifications
   */

  export type AggregateUser_verifications = {
    _count: User_verificationsCountAggregateOutputType | null
    _min: User_verificationsMinAggregateOutputType | null
    _max: User_verificationsMaxAggregateOutputType | null
  }

  export type User_verificationsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    idType: string | null
    idNumber: string | null
    idFrontImage: string | null
    idBackImage: string | null
    addressProofType: string | null
    addressProofNumber: string | null
    addressProofImage: string | null
    verificationStatus: string | null
    verifiedAt: Date | null
    verifiedBy: string | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type User_verificationsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    idType: string | null
    idNumber: string | null
    idFrontImage: string | null
    idBackImage: string | null
    addressProofType: string | null
    addressProofNumber: string | null
    addressProofImage: string | null
    verificationStatus: string | null
    verifiedAt: Date | null
    verifiedBy: string | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type User_verificationsCountAggregateOutputType = {
    id: number
    userId: number
    idType: number
    idNumber: number
    idFrontImage: number
    idBackImage: number
    addressProofType: number
    addressProofNumber: number
    addressProofImage: number
    verificationStatus: number
    verifiedAt: number
    verifiedBy: number
    rejectionReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type User_verificationsMinAggregateInputType = {
    id?: true
    userId?: true
    idType?: true
    idNumber?: true
    idFrontImage?: true
    idBackImage?: true
    addressProofType?: true
    addressProofNumber?: true
    addressProofImage?: true
    verificationStatus?: true
    verifiedAt?: true
    verifiedBy?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type User_verificationsMaxAggregateInputType = {
    id?: true
    userId?: true
    idType?: true
    idNumber?: true
    idFrontImage?: true
    idBackImage?: true
    addressProofType?: true
    addressProofNumber?: true
    addressProofImage?: true
    verificationStatus?: true
    verifiedAt?: true
    verifiedBy?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type User_verificationsCountAggregateInputType = {
    id?: true
    userId?: true
    idType?: true
    idNumber?: true
    idFrontImage?: true
    idBackImage?: true
    addressProofType?: true
    addressProofNumber?: true
    addressProofImage?: true
    verificationStatus?: true
    verifiedAt?: true
    verifiedBy?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type User_verificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_verifications to aggregate.
     */
    where?: user_verificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_verifications to fetch.
     */
    orderBy?: user_verificationsOrderByWithRelationInput | user_verificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_verificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_verifications
    **/
    _count?: true | User_verificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_verificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_verificationsMaxAggregateInputType
  }

  export type GetUser_verificationsAggregateType<T extends User_verificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_verifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_verifications[P]>
      : GetScalarType<T[P], AggregateUser_verifications[P]>
  }




  export type user_verificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_verificationsWhereInput
    orderBy?: user_verificationsOrderByWithAggregationInput | user_verificationsOrderByWithAggregationInput[]
    by: User_verificationsScalarFieldEnum[] | User_verificationsScalarFieldEnum
    having?: user_verificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_verificationsCountAggregateInputType | true
    _min?: User_verificationsMinAggregateInputType
    _max?: User_verificationsMaxAggregateInputType
  }

  export type User_verificationsGroupByOutputType = {
    id: string
    userId: string
    idType: string
    idNumber: string
    idFrontImage: string
    idBackImage: string | null
    addressProofType: string
    addressProofNumber: string
    addressProofImage: string
    verificationStatus: string
    verifiedAt: Date | null
    verifiedBy: string | null
    rejectionReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: User_verificationsCountAggregateOutputType | null
    _min: User_verificationsMinAggregateOutputType | null
    _max: User_verificationsMaxAggregateOutputType | null
  }

  type GetUser_verificationsGroupByPayload<T extends user_verificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_verificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_verificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_verificationsGroupByOutputType[P]>
            : GetScalarType<T[P], User_verificationsGroupByOutputType[P]>
        }
      >
    >


  export type user_verificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    idType?: boolean
    idNumber?: boolean
    idFrontImage?: boolean
    idBackImage?: boolean
    addressProofType?: boolean
    addressProofNumber?: boolean
    addressProofImage?: boolean
    verificationStatus?: boolean
    verifiedAt?: boolean
    verifiedBy?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_verifications"]>

  export type user_verificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    idType?: boolean
    idNumber?: boolean
    idFrontImage?: boolean
    idBackImage?: boolean
    addressProofType?: boolean
    addressProofNumber?: boolean
    addressProofImage?: boolean
    verificationStatus?: boolean
    verifiedAt?: boolean
    verifiedBy?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_verifications"]>

  export type user_verificationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    idType?: boolean
    idNumber?: boolean
    idFrontImage?: boolean
    idBackImage?: boolean
    addressProofType?: boolean
    addressProofNumber?: boolean
    addressProofImage?: boolean
    verificationStatus?: boolean
    verifiedAt?: boolean
    verifiedBy?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_verifications"]>

  export type user_verificationsSelectScalar = {
    id?: boolean
    userId?: boolean
    idType?: boolean
    idNumber?: boolean
    idFrontImage?: boolean
    idBackImage?: boolean
    addressProofType?: boolean
    addressProofNumber?: boolean
    addressProofImage?: boolean
    verificationStatus?: boolean
    verifiedAt?: boolean
    verifiedBy?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type user_verificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "idType" | "idNumber" | "idFrontImage" | "idBackImage" | "addressProofType" | "addressProofNumber" | "addressProofImage" | "verificationStatus" | "verifiedAt" | "verifiedBy" | "rejectionReason" | "createdAt" | "updatedAt", ExtArgs["result"]["user_verifications"]>
  export type user_verificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_verificationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_verificationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $user_verificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_verifications"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      idType: string
      idNumber: string
      idFrontImage: string
      idBackImage: string | null
      addressProofType: string
      addressProofNumber: string
      addressProofImage: string
      verificationStatus: string
      verifiedAt: Date | null
      verifiedBy: string | null
      rejectionReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user_verifications"]>
    composites: {}
  }

  type user_verificationsGetPayload<S extends boolean | null | undefined | user_verificationsDefaultArgs> = $Result.GetResult<Prisma.$user_verificationsPayload, S>

  type user_verificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_verificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_verificationsCountAggregateInputType | true
    }

  export interface user_verificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_verifications'], meta: { name: 'user_verifications' } }
    /**
     * Find zero or one User_verifications that matches the filter.
     * @param {user_verificationsFindUniqueArgs} args - Arguments to find a User_verifications
     * @example
     * // Get one User_verifications
     * const user_verifications = await prisma.user_verifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_verificationsFindUniqueArgs>(args: SelectSubset<T, user_verificationsFindUniqueArgs<ExtArgs>>): Prisma__user_verificationsClient<$Result.GetResult<Prisma.$user_verificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_verifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_verificationsFindUniqueOrThrowArgs} args - Arguments to find a User_verifications
     * @example
     * // Get one User_verifications
     * const user_verifications = await prisma.user_verifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_verificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_verificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_verificationsClient<$Result.GetResult<Prisma.$user_verificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_verificationsFindFirstArgs} args - Arguments to find a User_verifications
     * @example
     * // Get one User_verifications
     * const user_verifications = await prisma.user_verifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_verificationsFindFirstArgs>(args?: SelectSubset<T, user_verificationsFindFirstArgs<ExtArgs>>): Prisma__user_verificationsClient<$Result.GetResult<Prisma.$user_verificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_verifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_verificationsFindFirstOrThrowArgs} args - Arguments to find a User_verifications
     * @example
     * // Get one User_verifications
     * const user_verifications = await prisma.user_verifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_verificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_verificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_verificationsClient<$Result.GetResult<Prisma.$user_verificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_verificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_verifications
     * const user_verifications = await prisma.user_verifications.findMany()
     * 
     * // Get first 10 User_verifications
     * const user_verifications = await prisma.user_verifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_verificationsWithIdOnly = await prisma.user_verifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_verificationsFindManyArgs>(args?: SelectSubset<T, user_verificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_verificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_verifications.
     * @param {user_verificationsCreateArgs} args - Arguments to create a User_verifications.
     * @example
     * // Create one User_verifications
     * const User_verifications = await prisma.user_verifications.create({
     *   data: {
     *     // ... data to create a User_verifications
     *   }
     * })
     * 
     */
    create<T extends user_verificationsCreateArgs>(args: SelectSubset<T, user_verificationsCreateArgs<ExtArgs>>): Prisma__user_verificationsClient<$Result.GetResult<Prisma.$user_verificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_verifications.
     * @param {user_verificationsCreateManyArgs} args - Arguments to create many User_verifications.
     * @example
     * // Create many User_verifications
     * const user_verifications = await prisma.user_verifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_verificationsCreateManyArgs>(args?: SelectSubset<T, user_verificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_verifications and returns the data saved in the database.
     * @param {user_verificationsCreateManyAndReturnArgs} args - Arguments to create many User_verifications.
     * @example
     * // Create many User_verifications
     * const user_verifications = await prisma.user_verifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_verifications and only return the `id`
     * const user_verificationsWithIdOnly = await prisma.user_verifications.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_verificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_verificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_verificationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_verifications.
     * @param {user_verificationsDeleteArgs} args - Arguments to delete one User_verifications.
     * @example
     * // Delete one User_verifications
     * const User_verifications = await prisma.user_verifications.delete({
     *   where: {
     *     // ... filter to delete one User_verifications
     *   }
     * })
     * 
     */
    delete<T extends user_verificationsDeleteArgs>(args: SelectSubset<T, user_verificationsDeleteArgs<ExtArgs>>): Prisma__user_verificationsClient<$Result.GetResult<Prisma.$user_verificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_verifications.
     * @param {user_verificationsUpdateArgs} args - Arguments to update one User_verifications.
     * @example
     * // Update one User_verifications
     * const user_verifications = await prisma.user_verifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_verificationsUpdateArgs>(args: SelectSubset<T, user_verificationsUpdateArgs<ExtArgs>>): Prisma__user_verificationsClient<$Result.GetResult<Prisma.$user_verificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_verifications.
     * @param {user_verificationsDeleteManyArgs} args - Arguments to filter User_verifications to delete.
     * @example
     * // Delete a few User_verifications
     * const { count } = await prisma.user_verifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_verificationsDeleteManyArgs>(args?: SelectSubset<T, user_verificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_verificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_verifications
     * const user_verifications = await prisma.user_verifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_verificationsUpdateManyArgs>(args: SelectSubset<T, user_verificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_verifications and returns the data updated in the database.
     * @param {user_verificationsUpdateManyAndReturnArgs} args - Arguments to update many User_verifications.
     * @example
     * // Update many User_verifications
     * const user_verifications = await prisma.user_verifications.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_verifications and only return the `id`
     * const user_verificationsWithIdOnly = await prisma.user_verifications.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_verificationsUpdateManyAndReturnArgs>(args: SelectSubset<T, user_verificationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_verificationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_verifications.
     * @param {user_verificationsUpsertArgs} args - Arguments to update or create a User_verifications.
     * @example
     * // Update or create a User_verifications
     * const user_verifications = await prisma.user_verifications.upsert({
     *   create: {
     *     // ... data to create a User_verifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_verifications we want to update
     *   }
     * })
     */
    upsert<T extends user_verificationsUpsertArgs>(args: SelectSubset<T, user_verificationsUpsertArgs<ExtArgs>>): Prisma__user_verificationsClient<$Result.GetResult<Prisma.$user_verificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_verificationsCountArgs} args - Arguments to filter User_verifications to count.
     * @example
     * // Count the number of User_verifications
     * const count = await prisma.user_verifications.count({
     *   where: {
     *     // ... the filter for the User_verifications we want to count
     *   }
     * })
    **/
    count<T extends user_verificationsCountArgs>(
      args?: Subset<T, user_verificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_verificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_verificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_verificationsAggregateArgs>(args: Subset<T, User_verificationsAggregateArgs>): Prisma.PrismaPromise<GetUser_verificationsAggregateType<T>>

    /**
     * Group by User_verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_verificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_verificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_verificationsGroupByArgs['orderBy'] }
        : { orderBy?: user_verificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_verificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_verificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_verifications model
   */
  readonly fields: user_verificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_verifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_verificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_verifications model
   */
  interface user_verificationsFieldRefs {
    readonly id: FieldRef<"user_verifications", 'String'>
    readonly userId: FieldRef<"user_verifications", 'String'>
    readonly idType: FieldRef<"user_verifications", 'String'>
    readonly idNumber: FieldRef<"user_verifications", 'String'>
    readonly idFrontImage: FieldRef<"user_verifications", 'String'>
    readonly idBackImage: FieldRef<"user_verifications", 'String'>
    readonly addressProofType: FieldRef<"user_verifications", 'String'>
    readonly addressProofNumber: FieldRef<"user_verifications", 'String'>
    readonly addressProofImage: FieldRef<"user_verifications", 'String'>
    readonly verificationStatus: FieldRef<"user_verifications", 'String'>
    readonly verifiedAt: FieldRef<"user_verifications", 'DateTime'>
    readonly verifiedBy: FieldRef<"user_verifications", 'String'>
    readonly rejectionReason: FieldRef<"user_verifications", 'String'>
    readonly createdAt: FieldRef<"user_verifications", 'DateTime'>
    readonly updatedAt: FieldRef<"user_verifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_verifications findUnique
   */
  export type user_verificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_verifications
     */
    select?: user_verificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_verifications
     */
    omit?: user_verificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_verificationsInclude<ExtArgs> | null
    /**
     * Filter, which user_verifications to fetch.
     */
    where: user_verificationsWhereUniqueInput
  }

  /**
   * user_verifications findUniqueOrThrow
   */
  export type user_verificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_verifications
     */
    select?: user_verificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_verifications
     */
    omit?: user_verificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_verificationsInclude<ExtArgs> | null
    /**
     * Filter, which user_verifications to fetch.
     */
    where: user_verificationsWhereUniqueInput
  }

  /**
   * user_verifications findFirst
   */
  export type user_verificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_verifications
     */
    select?: user_verificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_verifications
     */
    omit?: user_verificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_verificationsInclude<ExtArgs> | null
    /**
     * Filter, which user_verifications to fetch.
     */
    where?: user_verificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_verifications to fetch.
     */
    orderBy?: user_verificationsOrderByWithRelationInput | user_verificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_verifications.
     */
    cursor?: user_verificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_verifications.
     */
    distinct?: User_verificationsScalarFieldEnum | User_verificationsScalarFieldEnum[]
  }

  /**
   * user_verifications findFirstOrThrow
   */
  export type user_verificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_verifications
     */
    select?: user_verificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_verifications
     */
    omit?: user_verificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_verificationsInclude<ExtArgs> | null
    /**
     * Filter, which user_verifications to fetch.
     */
    where?: user_verificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_verifications to fetch.
     */
    orderBy?: user_verificationsOrderByWithRelationInput | user_verificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_verifications.
     */
    cursor?: user_verificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_verifications.
     */
    distinct?: User_verificationsScalarFieldEnum | User_verificationsScalarFieldEnum[]
  }

  /**
   * user_verifications findMany
   */
  export type user_verificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_verifications
     */
    select?: user_verificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_verifications
     */
    omit?: user_verificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_verificationsInclude<ExtArgs> | null
    /**
     * Filter, which user_verifications to fetch.
     */
    where?: user_verificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_verifications to fetch.
     */
    orderBy?: user_verificationsOrderByWithRelationInput | user_verificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_verifications.
     */
    cursor?: user_verificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_verifications.
     */
    skip?: number
    distinct?: User_verificationsScalarFieldEnum | User_verificationsScalarFieldEnum[]
  }

  /**
   * user_verifications create
   */
  export type user_verificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_verifications
     */
    select?: user_verificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_verifications
     */
    omit?: user_verificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_verificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a user_verifications.
     */
    data: XOR<user_verificationsCreateInput, user_verificationsUncheckedCreateInput>
  }

  /**
   * user_verifications createMany
   */
  export type user_verificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_verifications.
     */
    data: user_verificationsCreateManyInput | user_verificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_verifications createManyAndReturn
   */
  export type user_verificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_verifications
     */
    select?: user_verificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_verifications
     */
    omit?: user_verificationsOmit<ExtArgs> | null
    /**
     * The data used to create many user_verifications.
     */
    data: user_verificationsCreateManyInput | user_verificationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_verificationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_verifications update
   */
  export type user_verificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_verifications
     */
    select?: user_verificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_verifications
     */
    omit?: user_verificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_verificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a user_verifications.
     */
    data: XOR<user_verificationsUpdateInput, user_verificationsUncheckedUpdateInput>
    /**
     * Choose, which user_verifications to update.
     */
    where: user_verificationsWhereUniqueInput
  }

  /**
   * user_verifications updateMany
   */
  export type user_verificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_verifications.
     */
    data: XOR<user_verificationsUpdateManyMutationInput, user_verificationsUncheckedUpdateManyInput>
    /**
     * Filter which user_verifications to update
     */
    where?: user_verificationsWhereInput
    /**
     * Limit how many user_verifications to update.
     */
    limit?: number
  }

  /**
   * user_verifications updateManyAndReturn
   */
  export type user_verificationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_verifications
     */
    select?: user_verificationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_verifications
     */
    omit?: user_verificationsOmit<ExtArgs> | null
    /**
     * The data used to update user_verifications.
     */
    data: XOR<user_verificationsUpdateManyMutationInput, user_verificationsUncheckedUpdateManyInput>
    /**
     * Filter which user_verifications to update
     */
    where?: user_verificationsWhereInput
    /**
     * Limit how many user_verifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_verificationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_verifications upsert
   */
  export type user_verificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_verifications
     */
    select?: user_verificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_verifications
     */
    omit?: user_verificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_verificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the user_verifications to update in case it exists.
     */
    where: user_verificationsWhereUniqueInput
    /**
     * In case the user_verifications found by the `where` argument doesn't exist, create a new user_verifications with this data.
     */
    create: XOR<user_verificationsCreateInput, user_verificationsUncheckedCreateInput>
    /**
     * In case the user_verifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_verificationsUpdateInput, user_verificationsUncheckedUpdateInput>
  }

  /**
   * user_verifications delete
   */
  export type user_verificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_verifications
     */
    select?: user_verificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_verifications
     */
    omit?: user_verificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_verificationsInclude<ExtArgs> | null
    /**
     * Filter which user_verifications to delete.
     */
    where: user_verificationsWhereUniqueInput
  }

  /**
   * user_verifications deleteMany
   */
  export type user_verificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_verifications to delete
     */
    where?: user_verificationsWhereInput
    /**
     * Limit how many user_verifications to delete.
     */
    limit?: number
  }

  /**
   * user_verifications without action
   */
  export type user_verificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_verifications
     */
    select?: user_verificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_verifications
     */
    omit?: user_verificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_verificationsInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    cancellationsCount: number | null
  }

  export type UsersSumAggregateOutputType = {
    cancellationsCount: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    email: string | null
    phone: string | null
    userType: $Enums.UserType | null
    isVerified: boolean | null
    isActive: boolean | null
    isBlocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    cancellationsCount: number | null
    isSuspect: boolean | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    email: string | null
    phone: string | null
    userType: $Enums.UserType | null
    isVerified: boolean | null
    isActive: boolean | null
    isBlocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    cancellationsCount: number | null
    isSuspect: boolean | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    email: number
    phone: number
    userType: number
    isVerified: number
    isActive: number
    isBlocked: number
    createdAt: number
    updatedAt: number
    cancellationsCount: number
    isSuspect: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    cancellationsCount?: true
  }

  export type UsersSumAggregateInputType = {
    cancellationsCount?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    userType?: true
    isVerified?: true
    isActive?: true
    isBlocked?: true
    createdAt?: true
    updatedAt?: true
    cancellationsCount?: true
    isSuspect?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    userType?: true
    isVerified?: true
    isActive?: true
    isBlocked?: true
    createdAt?: true
    updatedAt?: true
    cancellationsCount?: true
    isSuspect?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    userType?: true
    isVerified?: true
    isActive?: true
    isBlocked?: true
    createdAt?: true
    updatedAt?: true
    cancellationsCount?: true
    isSuspect?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    email: string | null
    phone: string | null
    userType: $Enums.UserType
    isVerified: boolean
    isActive: boolean
    isBlocked: boolean
    createdAt: Date
    updatedAt: Date
    cancellationsCount: number
    isSuspect: boolean
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    userType?: boolean
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cancellationsCount?: boolean
    isSuspect?: boolean
    admin_actions?: boolean | users$admin_actionsArgs<ExtArgs>
    call_sessions_call_sessions_customerIdTousers?: boolean | users$call_sessions_call_sessions_customerIdTousersArgs<ExtArgs>
    call_sessions_call_sessions_providerIdTousers?: boolean | users$call_sessions_call_sessions_providerIdTousersArgs<ExtArgs>
    messages_messages_receiverIdTousers?: boolean | users$messages_messages_receiverIdTousersArgs<ExtArgs>
    messages_messages_senderIdTousers?: boolean | users$messages_messages_senderIdTousersArgs<ExtArgs>
    notification_preferences?: boolean | users$notification_preferencesArgs<ExtArgs>
    notification_tokens?: boolean | users$notification_tokensArgs<ExtArgs>
    notifications?: boolean | users$notificationsArgs<ExtArgs>
    orders_orders_customerIdTousers?: boolean | users$orders_orders_customerIdTousersArgs<ExtArgs>
    orders_orders_providerIdTousers?: boolean | users$orders_orders_providerIdTousersArgs<ExtArgs>
    otps?: boolean | users$otpsArgs<ExtArgs>
    payment_orders?: boolean | users$payment_ordersArgs<ExtArgs>
    profiles?: boolean | users$profilesArgs<ExtArgs>
    providers?: boolean | users$providersArgs<ExtArgs>
    report_schedules?: boolean | users$report_schedulesArgs<ExtArgs>
    reviews_reviews_revieweeIdTousers?: boolean | users$reviews_reviews_revieweeIdTousersArgs<ExtArgs>
    reviews_reviews_reviewerIdTousers?: boolean | users$reviews_reviews_reviewerIdTousersArgs<ExtArgs>
    tickets?: boolean | users$ticketsArgs<ExtArgs>
    user_payment_methods?: boolean | users$user_payment_methodsArgs<ExtArgs>
    user_verifications?: boolean | users$user_verificationsArgs<ExtArgs>
    wallets?: boolean | users$walletsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    userType?: boolean
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cancellationsCount?: boolean
    isSuspect?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    userType?: boolean
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cancellationsCount?: boolean
    isSuspect?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    email?: boolean
    phone?: boolean
    userType?: boolean
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cancellationsCount?: boolean
    isSuspect?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "phone" | "userType" | "isVerified" | "isActive" | "isBlocked" | "createdAt" | "updatedAt" | "cancellationsCount" | "isSuspect", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_actions?: boolean | users$admin_actionsArgs<ExtArgs>
    call_sessions_call_sessions_customerIdTousers?: boolean | users$call_sessions_call_sessions_customerIdTousersArgs<ExtArgs>
    call_sessions_call_sessions_providerIdTousers?: boolean | users$call_sessions_call_sessions_providerIdTousersArgs<ExtArgs>
    messages_messages_receiverIdTousers?: boolean | users$messages_messages_receiverIdTousersArgs<ExtArgs>
    messages_messages_senderIdTousers?: boolean | users$messages_messages_senderIdTousersArgs<ExtArgs>
    notification_preferences?: boolean | users$notification_preferencesArgs<ExtArgs>
    notification_tokens?: boolean | users$notification_tokensArgs<ExtArgs>
    notifications?: boolean | users$notificationsArgs<ExtArgs>
    orders_orders_customerIdTousers?: boolean | users$orders_orders_customerIdTousersArgs<ExtArgs>
    orders_orders_providerIdTousers?: boolean | users$orders_orders_providerIdTousersArgs<ExtArgs>
    otps?: boolean | users$otpsArgs<ExtArgs>
    payment_orders?: boolean | users$payment_ordersArgs<ExtArgs>
    profiles?: boolean | users$profilesArgs<ExtArgs>
    providers?: boolean | users$providersArgs<ExtArgs>
    report_schedules?: boolean | users$report_schedulesArgs<ExtArgs>
    reviews_reviews_revieweeIdTousers?: boolean | users$reviews_reviews_revieweeIdTousersArgs<ExtArgs>
    reviews_reviews_reviewerIdTousers?: boolean | users$reviews_reviews_reviewerIdTousersArgs<ExtArgs>
    tickets?: boolean | users$ticketsArgs<ExtArgs>
    user_payment_methods?: boolean | users$user_payment_methodsArgs<ExtArgs>
    user_verifications?: boolean | users$user_verificationsArgs<ExtArgs>
    wallets?: boolean | users$walletsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      admin_actions: Prisma.$admin_actionsPayload<ExtArgs>[]
      call_sessions_call_sessions_customerIdTousers: Prisma.$call_sessionsPayload<ExtArgs>[]
      call_sessions_call_sessions_providerIdTousers: Prisma.$call_sessionsPayload<ExtArgs>[]
      messages_messages_receiverIdTousers: Prisma.$messagesPayload<ExtArgs>[]
      messages_messages_senderIdTousers: Prisma.$messagesPayload<ExtArgs>[]
      notification_preferences: Prisma.$notification_preferencesPayload<ExtArgs> | null
      notification_tokens: Prisma.$notification_tokensPayload<ExtArgs>[]
      notifications: Prisma.$notificationsPayload<ExtArgs>[]
      orders_orders_customerIdTousers: Prisma.$ordersPayload<ExtArgs>[]
      orders_orders_providerIdTousers: Prisma.$ordersPayload<ExtArgs>[]
      otps: Prisma.$otpsPayload<ExtArgs>[]
      payment_orders: Prisma.$payment_ordersPayload<ExtArgs>[]
      profiles: Prisma.$profilesPayload<ExtArgs> | null
      providers: Prisma.$providersPayload<ExtArgs> | null
      report_schedules: Prisma.$report_schedulesPayload<ExtArgs>[]
      reviews_reviews_revieweeIdTousers: Prisma.$reviewsPayload<ExtArgs>[]
      reviews_reviews_reviewerIdTousers: Prisma.$reviewsPayload<ExtArgs>[]
      tickets: Prisma.$ticketsPayload<ExtArgs>[]
      user_payment_methods: Prisma.$user_payment_methodsPayload<ExtArgs>[]
      user_verifications: Prisma.$user_verificationsPayload<ExtArgs> | null
      wallets: Prisma.$walletsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string | null
      phone: string | null
      userType: $Enums.UserType
      isVerified: boolean
      isActive: boolean
      isBlocked: boolean
      createdAt: Date
      updatedAt: Date
      cancellationsCount: number
      isSuspect: boolean
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin_actions<T extends users$admin_actionsArgs<ExtArgs> = {}>(args?: Subset<T, users$admin_actionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_actionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    call_sessions_call_sessions_customerIdTousers<T extends users$call_sessions_call_sessions_customerIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$call_sessions_call_sessions_customerIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$call_sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    call_sessions_call_sessions_providerIdTousers<T extends users$call_sessions_call_sessions_providerIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$call_sessions_call_sessions_providerIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$call_sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages_messages_receiverIdTousers<T extends users$messages_messages_receiverIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$messages_messages_receiverIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages_messages_senderIdTousers<T extends users$messages_messages_senderIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$messages_messages_senderIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notification_preferences<T extends users$notification_preferencesArgs<ExtArgs> = {}>(args?: Subset<T, users$notification_preferencesArgs<ExtArgs>>): Prisma__notification_preferencesClient<$Result.GetResult<Prisma.$notification_preferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notification_tokens<T extends users$notification_tokensArgs<ExtArgs> = {}>(args?: Subset<T, users$notification_tokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notification_tokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends users$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, users$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders_orders_customerIdTousers<T extends users$orders_orders_customerIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$orders_orders_customerIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders_orders_providerIdTousers<T extends users$orders_orders_providerIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$orders_orders_providerIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    otps<T extends users$otpsArgs<ExtArgs> = {}>(args?: Subset<T, users$otpsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$otpsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payment_orders<T extends users$payment_ordersArgs<ExtArgs> = {}>(args?: Subset<T, users$payment_ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    profiles<T extends users$profilesArgs<ExtArgs> = {}>(args?: Subset<T, users$profilesArgs<ExtArgs>>): Prisma__profilesClient<$Result.GetResult<Prisma.$profilesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    providers<T extends users$providersArgs<ExtArgs> = {}>(args?: Subset<T, users$providersArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    report_schedules<T extends users$report_schedulesArgs<ExtArgs> = {}>(args?: Subset<T, users$report_schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$report_schedulesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews_reviews_revieweeIdTousers<T extends users$reviews_reviews_revieweeIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$reviews_reviews_revieweeIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews_reviews_reviewerIdTousers<T extends users$reviews_reviews_reviewerIdTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$reviews_reviews_reviewerIdTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tickets<T extends users$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, users$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ticketsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_payment_methods<T extends users$user_payment_methodsArgs<ExtArgs> = {}>(args?: Subset<T, users$user_payment_methodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_payment_methodsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_verifications<T extends users$user_verificationsArgs<ExtArgs> = {}>(args?: Subset<T, users$user_verificationsArgs<ExtArgs>>): Prisma__user_verificationsClient<$Result.GetResult<Prisma.$user_verificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    wallets<T extends users$walletsArgs<ExtArgs> = {}>(args?: Subset<T, users$walletsArgs<ExtArgs>>): Prisma__walletsClient<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly phone: FieldRef<"users", 'String'>
    readonly userType: FieldRef<"users", 'UserType'>
    readonly isVerified: FieldRef<"users", 'Boolean'>
    readonly isActive: FieldRef<"users", 'Boolean'>
    readonly isBlocked: FieldRef<"users", 'Boolean'>
    readonly createdAt: FieldRef<"users", 'DateTime'>
    readonly updatedAt: FieldRef<"users", 'DateTime'>
    readonly cancellationsCount: FieldRef<"users", 'Int'>
    readonly isSuspect: FieldRef<"users", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.admin_actions
   */
  export type users$admin_actionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_actions
     */
    select?: admin_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_actions
     */
    omit?: admin_actionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_actionsInclude<ExtArgs> | null
    where?: admin_actionsWhereInput
    orderBy?: admin_actionsOrderByWithRelationInput | admin_actionsOrderByWithRelationInput[]
    cursor?: admin_actionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Admin_actionsScalarFieldEnum | Admin_actionsScalarFieldEnum[]
  }

  /**
   * users.call_sessions_call_sessions_customerIdTousers
   */
  export type users$call_sessions_call_sessions_customerIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_sessions
     */
    select?: call_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the call_sessions
     */
    omit?: call_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_sessionsInclude<ExtArgs> | null
    where?: call_sessionsWhereInput
    orderBy?: call_sessionsOrderByWithRelationInput | call_sessionsOrderByWithRelationInput[]
    cursor?: call_sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Call_sessionsScalarFieldEnum | Call_sessionsScalarFieldEnum[]
  }

  /**
   * users.call_sessions_call_sessions_providerIdTousers
   */
  export type users$call_sessions_call_sessions_providerIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the call_sessions
     */
    select?: call_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the call_sessions
     */
    omit?: call_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: call_sessionsInclude<ExtArgs> | null
    where?: call_sessionsWhereInput
    orderBy?: call_sessionsOrderByWithRelationInput | call_sessionsOrderByWithRelationInput[]
    cursor?: call_sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Call_sessionsScalarFieldEnum | Call_sessionsScalarFieldEnum[]
  }

  /**
   * users.messages_messages_receiverIdTousers
   */
  export type users$messages_messages_receiverIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    where?: messagesWhereInput
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    cursor?: messagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * users.messages_messages_senderIdTousers
   */
  export type users$messages_messages_senderIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    where?: messagesWhereInput
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    cursor?: messagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * users.notification_preferences
   */
  export type users$notification_preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_preferences
     */
    select?: notification_preferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_preferences
     */
    omit?: notification_preferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_preferencesInclude<ExtArgs> | null
    where?: notification_preferencesWhereInput
  }

  /**
   * users.notification_tokens
   */
  export type users$notification_tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_tokens
     */
    select?: notification_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_tokens
     */
    omit?: notification_tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_tokensInclude<ExtArgs> | null
    where?: notification_tokensWhereInput
    orderBy?: notification_tokensOrderByWithRelationInput | notification_tokensOrderByWithRelationInput[]
    cursor?: notification_tokensWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Notification_tokensScalarFieldEnum | Notification_tokensScalarFieldEnum[]
  }

  /**
   * users.notifications
   */
  export type users$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    cursor?: notificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * users.orders_orders_customerIdTousers
   */
  export type users$orders_orders_customerIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    where?: ordersWhereInput
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    cursor?: ordersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * users.orders_orders_providerIdTousers
   */
  export type users$orders_orders_providerIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    where?: ordersWhereInput
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    cursor?: ordersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * users.otps
   */
  export type users$otpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otps
     */
    select?: otpsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otps
     */
    omit?: otpsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpsInclude<ExtArgs> | null
    where?: otpsWhereInput
    orderBy?: otpsOrderByWithRelationInput | otpsOrderByWithRelationInput[]
    cursor?: otpsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OtpsScalarFieldEnum | OtpsScalarFieldEnum[]
  }

  /**
   * users.payment_orders
   */
  export type users$payment_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_orders
     */
    select?: payment_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment_orders
     */
    omit?: payment_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_ordersInclude<ExtArgs> | null
    where?: payment_ordersWhereInput
    orderBy?: payment_ordersOrderByWithRelationInput | payment_ordersOrderByWithRelationInput[]
    cursor?: payment_ordersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Payment_ordersScalarFieldEnum | Payment_ordersScalarFieldEnum[]
  }

  /**
   * users.profiles
   */
  export type users$profilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profiles
     */
    select?: profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profiles
     */
    omit?: profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profilesInclude<ExtArgs> | null
    where?: profilesWhereInput
  }

  /**
   * users.providers
   */
  export type users$providersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    where?: providersWhereInput
  }

  /**
   * users.report_schedules
   */
  export type users$report_schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_schedules
     */
    select?: report_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_schedules
     */
    omit?: report_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_schedulesInclude<ExtArgs> | null
    where?: report_schedulesWhereInput
    orderBy?: report_schedulesOrderByWithRelationInput | report_schedulesOrderByWithRelationInput[]
    cursor?: report_schedulesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Report_schedulesScalarFieldEnum | Report_schedulesScalarFieldEnum[]
  }

  /**
   * users.reviews_reviews_revieweeIdTousers
   */
  export type users$reviews_reviews_revieweeIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    where?: reviewsWhereInput
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    cursor?: reviewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * users.reviews_reviews_reviewerIdTousers
   */
  export type users$reviews_reviews_reviewerIdTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    where?: reviewsWhereInput
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    cursor?: reviewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * users.tickets
   */
  export type users$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tickets
     */
    select?: ticketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tickets
     */
    omit?: ticketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketsInclude<ExtArgs> | null
    where?: ticketsWhereInput
    orderBy?: ticketsOrderByWithRelationInput | ticketsOrderByWithRelationInput[]
    cursor?: ticketsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * users.user_payment_methods
   */
  export type users$user_payment_methodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_payment_methods
     */
    select?: user_payment_methodsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_payment_methods
     */
    omit?: user_payment_methodsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_payment_methodsInclude<ExtArgs> | null
    where?: user_payment_methodsWhereInput
    orderBy?: user_payment_methodsOrderByWithRelationInput | user_payment_methodsOrderByWithRelationInput[]
    cursor?: user_payment_methodsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_payment_methodsScalarFieldEnum | User_payment_methodsScalarFieldEnum[]
  }

  /**
   * users.user_verifications
   */
  export type users$user_verificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_verifications
     */
    select?: user_verificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_verifications
     */
    omit?: user_verificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_verificationsInclude<ExtArgs> | null
    where?: user_verificationsWhereInput
  }

  /**
   * users.wallets
   */
  export type users$walletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsInclude<ExtArgs> | null
    where?: walletsWhereInput
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model virtual_assignments
   */

  export type AggregateVirtual_assignments = {
    _count: Virtual_assignmentsCountAggregateOutputType | null
    _min: Virtual_assignmentsMinAggregateOutputType | null
    _max: Virtual_assignmentsMaxAggregateOutputType | null
  }

  export type Virtual_assignmentsMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    virtualNumberId: string | null
    status: string | null
    assignedAt: Date | null
    releasedAt: Date | null
  }

  export type Virtual_assignmentsMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    virtualNumberId: string | null
    status: string | null
    assignedAt: Date | null
    releasedAt: Date | null
  }

  export type Virtual_assignmentsCountAggregateOutputType = {
    id: number
    orderId: number
    virtualNumberId: number
    status: number
    assignedAt: number
    releasedAt: number
    _all: number
  }


  export type Virtual_assignmentsMinAggregateInputType = {
    id?: true
    orderId?: true
    virtualNumberId?: true
    status?: true
    assignedAt?: true
    releasedAt?: true
  }

  export type Virtual_assignmentsMaxAggregateInputType = {
    id?: true
    orderId?: true
    virtualNumberId?: true
    status?: true
    assignedAt?: true
    releasedAt?: true
  }

  export type Virtual_assignmentsCountAggregateInputType = {
    id?: true
    orderId?: true
    virtualNumberId?: true
    status?: true
    assignedAt?: true
    releasedAt?: true
    _all?: true
  }

  export type Virtual_assignmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which virtual_assignments to aggregate.
     */
    where?: virtual_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of virtual_assignments to fetch.
     */
    orderBy?: virtual_assignmentsOrderByWithRelationInput | virtual_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: virtual_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` virtual_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` virtual_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned virtual_assignments
    **/
    _count?: true | Virtual_assignmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Virtual_assignmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Virtual_assignmentsMaxAggregateInputType
  }

  export type GetVirtual_assignmentsAggregateType<T extends Virtual_assignmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateVirtual_assignments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVirtual_assignments[P]>
      : GetScalarType<T[P], AggregateVirtual_assignments[P]>
  }




  export type virtual_assignmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: virtual_assignmentsWhereInput
    orderBy?: virtual_assignmentsOrderByWithAggregationInput | virtual_assignmentsOrderByWithAggregationInput[]
    by: Virtual_assignmentsScalarFieldEnum[] | Virtual_assignmentsScalarFieldEnum
    having?: virtual_assignmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Virtual_assignmentsCountAggregateInputType | true
    _min?: Virtual_assignmentsMinAggregateInputType
    _max?: Virtual_assignmentsMaxAggregateInputType
  }

  export type Virtual_assignmentsGroupByOutputType = {
    id: string
    orderId: string
    virtualNumberId: string
    status: string
    assignedAt: Date
    releasedAt: Date | null
    _count: Virtual_assignmentsCountAggregateOutputType | null
    _min: Virtual_assignmentsMinAggregateOutputType | null
    _max: Virtual_assignmentsMaxAggregateOutputType | null
  }

  type GetVirtual_assignmentsGroupByPayload<T extends virtual_assignmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Virtual_assignmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Virtual_assignmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Virtual_assignmentsGroupByOutputType[P]>
            : GetScalarType<T[P], Virtual_assignmentsGroupByOutputType[P]>
        }
      >
    >


  export type virtual_assignmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    virtualNumberId?: boolean
    status?: boolean
    assignedAt?: boolean
    releasedAt?: boolean
    orders?: boolean | ordersDefaultArgs<ExtArgs>
    virtual_numbers?: boolean | virtual_numbersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["virtual_assignments"]>

  export type virtual_assignmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    virtualNumberId?: boolean
    status?: boolean
    assignedAt?: boolean
    releasedAt?: boolean
    orders?: boolean | ordersDefaultArgs<ExtArgs>
    virtual_numbers?: boolean | virtual_numbersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["virtual_assignments"]>

  export type virtual_assignmentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    virtualNumberId?: boolean
    status?: boolean
    assignedAt?: boolean
    releasedAt?: boolean
    orders?: boolean | ordersDefaultArgs<ExtArgs>
    virtual_numbers?: boolean | virtual_numbersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["virtual_assignments"]>

  export type virtual_assignmentsSelectScalar = {
    id?: boolean
    orderId?: boolean
    virtualNumberId?: boolean
    status?: boolean
    assignedAt?: boolean
    releasedAt?: boolean
  }

  export type virtual_assignmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "virtualNumberId" | "status" | "assignedAt" | "releasedAt", ExtArgs["result"]["virtual_assignments"]>
  export type virtual_assignmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | ordersDefaultArgs<ExtArgs>
    virtual_numbers?: boolean | virtual_numbersDefaultArgs<ExtArgs>
  }
  export type virtual_assignmentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | ordersDefaultArgs<ExtArgs>
    virtual_numbers?: boolean | virtual_numbersDefaultArgs<ExtArgs>
  }
  export type virtual_assignmentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | ordersDefaultArgs<ExtArgs>
    virtual_numbers?: boolean | virtual_numbersDefaultArgs<ExtArgs>
  }

  export type $virtual_assignmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "virtual_assignments"
    objects: {
      orders: Prisma.$ordersPayload<ExtArgs>
      virtual_numbers: Prisma.$virtual_numbersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      virtualNumberId: string
      status: string
      assignedAt: Date
      releasedAt: Date | null
    }, ExtArgs["result"]["virtual_assignments"]>
    composites: {}
  }

  type virtual_assignmentsGetPayload<S extends boolean | null | undefined | virtual_assignmentsDefaultArgs> = $Result.GetResult<Prisma.$virtual_assignmentsPayload, S>

  type virtual_assignmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<virtual_assignmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Virtual_assignmentsCountAggregateInputType | true
    }

  export interface virtual_assignmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['virtual_assignments'], meta: { name: 'virtual_assignments' } }
    /**
     * Find zero or one Virtual_assignments that matches the filter.
     * @param {virtual_assignmentsFindUniqueArgs} args - Arguments to find a Virtual_assignments
     * @example
     * // Get one Virtual_assignments
     * const virtual_assignments = await prisma.virtual_assignments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends virtual_assignmentsFindUniqueArgs>(args: SelectSubset<T, virtual_assignmentsFindUniqueArgs<ExtArgs>>): Prisma__virtual_assignmentsClient<$Result.GetResult<Prisma.$virtual_assignmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Virtual_assignments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {virtual_assignmentsFindUniqueOrThrowArgs} args - Arguments to find a Virtual_assignments
     * @example
     * // Get one Virtual_assignments
     * const virtual_assignments = await prisma.virtual_assignments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends virtual_assignmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, virtual_assignmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__virtual_assignmentsClient<$Result.GetResult<Prisma.$virtual_assignmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Virtual_assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {virtual_assignmentsFindFirstArgs} args - Arguments to find a Virtual_assignments
     * @example
     * // Get one Virtual_assignments
     * const virtual_assignments = await prisma.virtual_assignments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends virtual_assignmentsFindFirstArgs>(args?: SelectSubset<T, virtual_assignmentsFindFirstArgs<ExtArgs>>): Prisma__virtual_assignmentsClient<$Result.GetResult<Prisma.$virtual_assignmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Virtual_assignments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {virtual_assignmentsFindFirstOrThrowArgs} args - Arguments to find a Virtual_assignments
     * @example
     * // Get one Virtual_assignments
     * const virtual_assignments = await prisma.virtual_assignments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends virtual_assignmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, virtual_assignmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__virtual_assignmentsClient<$Result.GetResult<Prisma.$virtual_assignmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Virtual_assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {virtual_assignmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Virtual_assignments
     * const virtual_assignments = await prisma.virtual_assignments.findMany()
     * 
     * // Get first 10 Virtual_assignments
     * const virtual_assignments = await prisma.virtual_assignments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const virtual_assignmentsWithIdOnly = await prisma.virtual_assignments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends virtual_assignmentsFindManyArgs>(args?: SelectSubset<T, virtual_assignmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$virtual_assignmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Virtual_assignments.
     * @param {virtual_assignmentsCreateArgs} args - Arguments to create a Virtual_assignments.
     * @example
     * // Create one Virtual_assignments
     * const Virtual_assignments = await prisma.virtual_assignments.create({
     *   data: {
     *     // ... data to create a Virtual_assignments
     *   }
     * })
     * 
     */
    create<T extends virtual_assignmentsCreateArgs>(args: SelectSubset<T, virtual_assignmentsCreateArgs<ExtArgs>>): Prisma__virtual_assignmentsClient<$Result.GetResult<Prisma.$virtual_assignmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Virtual_assignments.
     * @param {virtual_assignmentsCreateManyArgs} args - Arguments to create many Virtual_assignments.
     * @example
     * // Create many Virtual_assignments
     * const virtual_assignments = await prisma.virtual_assignments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends virtual_assignmentsCreateManyArgs>(args?: SelectSubset<T, virtual_assignmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Virtual_assignments and returns the data saved in the database.
     * @param {virtual_assignmentsCreateManyAndReturnArgs} args - Arguments to create many Virtual_assignments.
     * @example
     * // Create many Virtual_assignments
     * const virtual_assignments = await prisma.virtual_assignments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Virtual_assignments and only return the `id`
     * const virtual_assignmentsWithIdOnly = await prisma.virtual_assignments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends virtual_assignmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, virtual_assignmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$virtual_assignmentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Virtual_assignments.
     * @param {virtual_assignmentsDeleteArgs} args - Arguments to delete one Virtual_assignments.
     * @example
     * // Delete one Virtual_assignments
     * const Virtual_assignments = await prisma.virtual_assignments.delete({
     *   where: {
     *     // ... filter to delete one Virtual_assignments
     *   }
     * })
     * 
     */
    delete<T extends virtual_assignmentsDeleteArgs>(args: SelectSubset<T, virtual_assignmentsDeleteArgs<ExtArgs>>): Prisma__virtual_assignmentsClient<$Result.GetResult<Prisma.$virtual_assignmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Virtual_assignments.
     * @param {virtual_assignmentsUpdateArgs} args - Arguments to update one Virtual_assignments.
     * @example
     * // Update one Virtual_assignments
     * const virtual_assignments = await prisma.virtual_assignments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends virtual_assignmentsUpdateArgs>(args: SelectSubset<T, virtual_assignmentsUpdateArgs<ExtArgs>>): Prisma__virtual_assignmentsClient<$Result.GetResult<Prisma.$virtual_assignmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Virtual_assignments.
     * @param {virtual_assignmentsDeleteManyArgs} args - Arguments to filter Virtual_assignments to delete.
     * @example
     * // Delete a few Virtual_assignments
     * const { count } = await prisma.virtual_assignments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends virtual_assignmentsDeleteManyArgs>(args?: SelectSubset<T, virtual_assignmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Virtual_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {virtual_assignmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Virtual_assignments
     * const virtual_assignments = await prisma.virtual_assignments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends virtual_assignmentsUpdateManyArgs>(args: SelectSubset<T, virtual_assignmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Virtual_assignments and returns the data updated in the database.
     * @param {virtual_assignmentsUpdateManyAndReturnArgs} args - Arguments to update many Virtual_assignments.
     * @example
     * // Update many Virtual_assignments
     * const virtual_assignments = await prisma.virtual_assignments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Virtual_assignments and only return the `id`
     * const virtual_assignmentsWithIdOnly = await prisma.virtual_assignments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends virtual_assignmentsUpdateManyAndReturnArgs>(args: SelectSubset<T, virtual_assignmentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$virtual_assignmentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Virtual_assignments.
     * @param {virtual_assignmentsUpsertArgs} args - Arguments to update or create a Virtual_assignments.
     * @example
     * // Update or create a Virtual_assignments
     * const virtual_assignments = await prisma.virtual_assignments.upsert({
     *   create: {
     *     // ... data to create a Virtual_assignments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Virtual_assignments we want to update
     *   }
     * })
     */
    upsert<T extends virtual_assignmentsUpsertArgs>(args: SelectSubset<T, virtual_assignmentsUpsertArgs<ExtArgs>>): Prisma__virtual_assignmentsClient<$Result.GetResult<Prisma.$virtual_assignmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Virtual_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {virtual_assignmentsCountArgs} args - Arguments to filter Virtual_assignments to count.
     * @example
     * // Count the number of Virtual_assignments
     * const count = await prisma.virtual_assignments.count({
     *   where: {
     *     // ... the filter for the Virtual_assignments we want to count
     *   }
     * })
    **/
    count<T extends virtual_assignmentsCountArgs>(
      args?: Subset<T, virtual_assignmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Virtual_assignmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Virtual_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Virtual_assignmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Virtual_assignmentsAggregateArgs>(args: Subset<T, Virtual_assignmentsAggregateArgs>): Prisma.PrismaPromise<GetVirtual_assignmentsAggregateType<T>>

    /**
     * Group by Virtual_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {virtual_assignmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends virtual_assignmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: virtual_assignmentsGroupByArgs['orderBy'] }
        : { orderBy?: virtual_assignmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, virtual_assignmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVirtual_assignmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the virtual_assignments model
   */
  readonly fields: virtual_assignmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for virtual_assignments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__virtual_assignmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends ordersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ordersDefaultArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    virtual_numbers<T extends virtual_numbersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, virtual_numbersDefaultArgs<ExtArgs>>): Prisma__virtual_numbersClient<$Result.GetResult<Prisma.$virtual_numbersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the virtual_assignments model
   */
  interface virtual_assignmentsFieldRefs {
    readonly id: FieldRef<"virtual_assignments", 'String'>
    readonly orderId: FieldRef<"virtual_assignments", 'String'>
    readonly virtualNumberId: FieldRef<"virtual_assignments", 'String'>
    readonly status: FieldRef<"virtual_assignments", 'String'>
    readonly assignedAt: FieldRef<"virtual_assignments", 'DateTime'>
    readonly releasedAt: FieldRef<"virtual_assignments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * virtual_assignments findUnique
   */
  export type virtual_assignmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_assignments
     */
    select?: virtual_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_assignments
     */
    omit?: virtual_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: virtual_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which virtual_assignments to fetch.
     */
    where: virtual_assignmentsWhereUniqueInput
  }

  /**
   * virtual_assignments findUniqueOrThrow
   */
  export type virtual_assignmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_assignments
     */
    select?: virtual_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_assignments
     */
    omit?: virtual_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: virtual_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which virtual_assignments to fetch.
     */
    where: virtual_assignmentsWhereUniqueInput
  }

  /**
   * virtual_assignments findFirst
   */
  export type virtual_assignmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_assignments
     */
    select?: virtual_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_assignments
     */
    omit?: virtual_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: virtual_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which virtual_assignments to fetch.
     */
    where?: virtual_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of virtual_assignments to fetch.
     */
    orderBy?: virtual_assignmentsOrderByWithRelationInput | virtual_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for virtual_assignments.
     */
    cursor?: virtual_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` virtual_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` virtual_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of virtual_assignments.
     */
    distinct?: Virtual_assignmentsScalarFieldEnum | Virtual_assignmentsScalarFieldEnum[]
  }

  /**
   * virtual_assignments findFirstOrThrow
   */
  export type virtual_assignmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_assignments
     */
    select?: virtual_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_assignments
     */
    omit?: virtual_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: virtual_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which virtual_assignments to fetch.
     */
    where?: virtual_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of virtual_assignments to fetch.
     */
    orderBy?: virtual_assignmentsOrderByWithRelationInput | virtual_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for virtual_assignments.
     */
    cursor?: virtual_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` virtual_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` virtual_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of virtual_assignments.
     */
    distinct?: Virtual_assignmentsScalarFieldEnum | Virtual_assignmentsScalarFieldEnum[]
  }

  /**
   * virtual_assignments findMany
   */
  export type virtual_assignmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_assignments
     */
    select?: virtual_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_assignments
     */
    omit?: virtual_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: virtual_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which virtual_assignments to fetch.
     */
    where?: virtual_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of virtual_assignments to fetch.
     */
    orderBy?: virtual_assignmentsOrderByWithRelationInput | virtual_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing virtual_assignments.
     */
    cursor?: virtual_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` virtual_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` virtual_assignments.
     */
    skip?: number
    distinct?: Virtual_assignmentsScalarFieldEnum | Virtual_assignmentsScalarFieldEnum[]
  }

  /**
   * virtual_assignments create
   */
  export type virtual_assignmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_assignments
     */
    select?: virtual_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_assignments
     */
    omit?: virtual_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: virtual_assignmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a virtual_assignments.
     */
    data: XOR<virtual_assignmentsCreateInput, virtual_assignmentsUncheckedCreateInput>
  }

  /**
   * virtual_assignments createMany
   */
  export type virtual_assignmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many virtual_assignments.
     */
    data: virtual_assignmentsCreateManyInput | virtual_assignmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * virtual_assignments createManyAndReturn
   */
  export type virtual_assignmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_assignments
     */
    select?: virtual_assignmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_assignments
     */
    omit?: virtual_assignmentsOmit<ExtArgs> | null
    /**
     * The data used to create many virtual_assignments.
     */
    data: virtual_assignmentsCreateManyInput | virtual_assignmentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: virtual_assignmentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * virtual_assignments update
   */
  export type virtual_assignmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_assignments
     */
    select?: virtual_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_assignments
     */
    omit?: virtual_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: virtual_assignmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a virtual_assignments.
     */
    data: XOR<virtual_assignmentsUpdateInput, virtual_assignmentsUncheckedUpdateInput>
    /**
     * Choose, which virtual_assignments to update.
     */
    where: virtual_assignmentsWhereUniqueInput
  }

  /**
   * virtual_assignments updateMany
   */
  export type virtual_assignmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update virtual_assignments.
     */
    data: XOR<virtual_assignmentsUpdateManyMutationInput, virtual_assignmentsUncheckedUpdateManyInput>
    /**
     * Filter which virtual_assignments to update
     */
    where?: virtual_assignmentsWhereInput
    /**
     * Limit how many virtual_assignments to update.
     */
    limit?: number
  }

  /**
   * virtual_assignments updateManyAndReturn
   */
  export type virtual_assignmentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_assignments
     */
    select?: virtual_assignmentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_assignments
     */
    omit?: virtual_assignmentsOmit<ExtArgs> | null
    /**
     * The data used to update virtual_assignments.
     */
    data: XOR<virtual_assignmentsUpdateManyMutationInput, virtual_assignmentsUncheckedUpdateManyInput>
    /**
     * Filter which virtual_assignments to update
     */
    where?: virtual_assignmentsWhereInput
    /**
     * Limit how many virtual_assignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: virtual_assignmentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * virtual_assignments upsert
   */
  export type virtual_assignmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_assignments
     */
    select?: virtual_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_assignments
     */
    omit?: virtual_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: virtual_assignmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the virtual_assignments to update in case it exists.
     */
    where: virtual_assignmentsWhereUniqueInput
    /**
     * In case the virtual_assignments found by the `where` argument doesn't exist, create a new virtual_assignments with this data.
     */
    create: XOR<virtual_assignmentsCreateInput, virtual_assignmentsUncheckedCreateInput>
    /**
     * In case the virtual_assignments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<virtual_assignmentsUpdateInput, virtual_assignmentsUncheckedUpdateInput>
  }

  /**
   * virtual_assignments delete
   */
  export type virtual_assignmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_assignments
     */
    select?: virtual_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_assignments
     */
    omit?: virtual_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: virtual_assignmentsInclude<ExtArgs> | null
    /**
     * Filter which virtual_assignments to delete.
     */
    where: virtual_assignmentsWhereUniqueInput
  }

  /**
   * virtual_assignments deleteMany
   */
  export type virtual_assignmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which virtual_assignments to delete
     */
    where?: virtual_assignmentsWhereInput
    /**
     * Limit how many virtual_assignments to delete.
     */
    limit?: number
  }

  /**
   * virtual_assignments without action
   */
  export type virtual_assignmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_assignments
     */
    select?: virtual_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_assignments
     */
    omit?: virtual_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: virtual_assignmentsInclude<ExtArgs> | null
  }


  /**
   * Model virtual_numbers
   */

  export type AggregateVirtual_numbers = {
    _count: Virtual_numbersCountAggregateOutputType | null
    _min: Virtual_numbersMinAggregateOutputType | null
    _max: Virtual_numbersMaxAggregateOutputType | null
  }

  export type Virtual_numbersMinAggregateOutputType = {
    id: string | null
    phoneNumber: string | null
    isAssigned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Virtual_numbersMaxAggregateOutputType = {
    id: string | null
    phoneNumber: string | null
    isAssigned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Virtual_numbersCountAggregateOutputType = {
    id: number
    phoneNumber: number
    isAssigned: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Virtual_numbersMinAggregateInputType = {
    id?: true
    phoneNumber?: true
    isAssigned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Virtual_numbersMaxAggregateInputType = {
    id?: true
    phoneNumber?: true
    isAssigned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Virtual_numbersCountAggregateInputType = {
    id?: true
    phoneNumber?: true
    isAssigned?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Virtual_numbersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which virtual_numbers to aggregate.
     */
    where?: virtual_numbersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of virtual_numbers to fetch.
     */
    orderBy?: virtual_numbersOrderByWithRelationInput | virtual_numbersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: virtual_numbersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` virtual_numbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` virtual_numbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned virtual_numbers
    **/
    _count?: true | Virtual_numbersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Virtual_numbersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Virtual_numbersMaxAggregateInputType
  }

  export type GetVirtual_numbersAggregateType<T extends Virtual_numbersAggregateArgs> = {
        [P in keyof T & keyof AggregateVirtual_numbers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVirtual_numbers[P]>
      : GetScalarType<T[P], AggregateVirtual_numbers[P]>
  }




  export type virtual_numbersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: virtual_numbersWhereInput
    orderBy?: virtual_numbersOrderByWithAggregationInput | virtual_numbersOrderByWithAggregationInput[]
    by: Virtual_numbersScalarFieldEnum[] | Virtual_numbersScalarFieldEnum
    having?: virtual_numbersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Virtual_numbersCountAggregateInputType | true
    _min?: Virtual_numbersMinAggregateInputType
    _max?: Virtual_numbersMaxAggregateInputType
  }

  export type Virtual_numbersGroupByOutputType = {
    id: string
    phoneNumber: string
    isAssigned: boolean
    createdAt: Date
    updatedAt: Date
    _count: Virtual_numbersCountAggregateOutputType | null
    _min: Virtual_numbersMinAggregateOutputType | null
    _max: Virtual_numbersMaxAggregateOutputType | null
  }

  type GetVirtual_numbersGroupByPayload<T extends virtual_numbersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Virtual_numbersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Virtual_numbersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Virtual_numbersGroupByOutputType[P]>
            : GetScalarType<T[P], Virtual_numbersGroupByOutputType[P]>
        }
      >
    >


  export type virtual_numbersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phoneNumber?: boolean
    isAssigned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    virtual_assignments?: boolean | virtual_numbers$virtual_assignmentsArgs<ExtArgs>
    _count?: boolean | Virtual_numbersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["virtual_numbers"]>

  export type virtual_numbersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phoneNumber?: boolean
    isAssigned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["virtual_numbers"]>

  export type virtual_numbersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phoneNumber?: boolean
    isAssigned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["virtual_numbers"]>

  export type virtual_numbersSelectScalar = {
    id?: boolean
    phoneNumber?: boolean
    isAssigned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type virtual_numbersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phoneNumber" | "isAssigned" | "createdAt" | "updatedAt", ExtArgs["result"]["virtual_numbers"]>
  export type virtual_numbersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    virtual_assignments?: boolean | virtual_numbers$virtual_assignmentsArgs<ExtArgs>
    _count?: boolean | Virtual_numbersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type virtual_numbersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type virtual_numbersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $virtual_numbersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "virtual_numbers"
    objects: {
      virtual_assignments: Prisma.$virtual_assignmentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phoneNumber: string
      isAssigned: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["virtual_numbers"]>
    composites: {}
  }

  type virtual_numbersGetPayload<S extends boolean | null | undefined | virtual_numbersDefaultArgs> = $Result.GetResult<Prisma.$virtual_numbersPayload, S>

  type virtual_numbersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<virtual_numbersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Virtual_numbersCountAggregateInputType | true
    }

  export interface virtual_numbersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['virtual_numbers'], meta: { name: 'virtual_numbers' } }
    /**
     * Find zero or one Virtual_numbers that matches the filter.
     * @param {virtual_numbersFindUniqueArgs} args - Arguments to find a Virtual_numbers
     * @example
     * // Get one Virtual_numbers
     * const virtual_numbers = await prisma.virtual_numbers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends virtual_numbersFindUniqueArgs>(args: SelectSubset<T, virtual_numbersFindUniqueArgs<ExtArgs>>): Prisma__virtual_numbersClient<$Result.GetResult<Prisma.$virtual_numbersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Virtual_numbers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {virtual_numbersFindUniqueOrThrowArgs} args - Arguments to find a Virtual_numbers
     * @example
     * // Get one Virtual_numbers
     * const virtual_numbers = await prisma.virtual_numbers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends virtual_numbersFindUniqueOrThrowArgs>(args: SelectSubset<T, virtual_numbersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__virtual_numbersClient<$Result.GetResult<Prisma.$virtual_numbersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Virtual_numbers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {virtual_numbersFindFirstArgs} args - Arguments to find a Virtual_numbers
     * @example
     * // Get one Virtual_numbers
     * const virtual_numbers = await prisma.virtual_numbers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends virtual_numbersFindFirstArgs>(args?: SelectSubset<T, virtual_numbersFindFirstArgs<ExtArgs>>): Prisma__virtual_numbersClient<$Result.GetResult<Prisma.$virtual_numbersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Virtual_numbers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {virtual_numbersFindFirstOrThrowArgs} args - Arguments to find a Virtual_numbers
     * @example
     * // Get one Virtual_numbers
     * const virtual_numbers = await prisma.virtual_numbers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends virtual_numbersFindFirstOrThrowArgs>(args?: SelectSubset<T, virtual_numbersFindFirstOrThrowArgs<ExtArgs>>): Prisma__virtual_numbersClient<$Result.GetResult<Prisma.$virtual_numbersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Virtual_numbers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {virtual_numbersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Virtual_numbers
     * const virtual_numbers = await prisma.virtual_numbers.findMany()
     * 
     * // Get first 10 Virtual_numbers
     * const virtual_numbers = await prisma.virtual_numbers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const virtual_numbersWithIdOnly = await prisma.virtual_numbers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends virtual_numbersFindManyArgs>(args?: SelectSubset<T, virtual_numbersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$virtual_numbersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Virtual_numbers.
     * @param {virtual_numbersCreateArgs} args - Arguments to create a Virtual_numbers.
     * @example
     * // Create one Virtual_numbers
     * const Virtual_numbers = await prisma.virtual_numbers.create({
     *   data: {
     *     // ... data to create a Virtual_numbers
     *   }
     * })
     * 
     */
    create<T extends virtual_numbersCreateArgs>(args: SelectSubset<T, virtual_numbersCreateArgs<ExtArgs>>): Prisma__virtual_numbersClient<$Result.GetResult<Prisma.$virtual_numbersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Virtual_numbers.
     * @param {virtual_numbersCreateManyArgs} args - Arguments to create many Virtual_numbers.
     * @example
     * // Create many Virtual_numbers
     * const virtual_numbers = await prisma.virtual_numbers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends virtual_numbersCreateManyArgs>(args?: SelectSubset<T, virtual_numbersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Virtual_numbers and returns the data saved in the database.
     * @param {virtual_numbersCreateManyAndReturnArgs} args - Arguments to create many Virtual_numbers.
     * @example
     * // Create many Virtual_numbers
     * const virtual_numbers = await prisma.virtual_numbers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Virtual_numbers and only return the `id`
     * const virtual_numbersWithIdOnly = await prisma.virtual_numbers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends virtual_numbersCreateManyAndReturnArgs>(args?: SelectSubset<T, virtual_numbersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$virtual_numbersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Virtual_numbers.
     * @param {virtual_numbersDeleteArgs} args - Arguments to delete one Virtual_numbers.
     * @example
     * // Delete one Virtual_numbers
     * const Virtual_numbers = await prisma.virtual_numbers.delete({
     *   where: {
     *     // ... filter to delete one Virtual_numbers
     *   }
     * })
     * 
     */
    delete<T extends virtual_numbersDeleteArgs>(args: SelectSubset<T, virtual_numbersDeleteArgs<ExtArgs>>): Prisma__virtual_numbersClient<$Result.GetResult<Prisma.$virtual_numbersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Virtual_numbers.
     * @param {virtual_numbersUpdateArgs} args - Arguments to update one Virtual_numbers.
     * @example
     * // Update one Virtual_numbers
     * const virtual_numbers = await prisma.virtual_numbers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends virtual_numbersUpdateArgs>(args: SelectSubset<T, virtual_numbersUpdateArgs<ExtArgs>>): Prisma__virtual_numbersClient<$Result.GetResult<Prisma.$virtual_numbersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Virtual_numbers.
     * @param {virtual_numbersDeleteManyArgs} args - Arguments to filter Virtual_numbers to delete.
     * @example
     * // Delete a few Virtual_numbers
     * const { count } = await prisma.virtual_numbers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends virtual_numbersDeleteManyArgs>(args?: SelectSubset<T, virtual_numbersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Virtual_numbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {virtual_numbersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Virtual_numbers
     * const virtual_numbers = await prisma.virtual_numbers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends virtual_numbersUpdateManyArgs>(args: SelectSubset<T, virtual_numbersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Virtual_numbers and returns the data updated in the database.
     * @param {virtual_numbersUpdateManyAndReturnArgs} args - Arguments to update many Virtual_numbers.
     * @example
     * // Update many Virtual_numbers
     * const virtual_numbers = await prisma.virtual_numbers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Virtual_numbers and only return the `id`
     * const virtual_numbersWithIdOnly = await prisma.virtual_numbers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends virtual_numbersUpdateManyAndReturnArgs>(args: SelectSubset<T, virtual_numbersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$virtual_numbersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Virtual_numbers.
     * @param {virtual_numbersUpsertArgs} args - Arguments to update or create a Virtual_numbers.
     * @example
     * // Update or create a Virtual_numbers
     * const virtual_numbers = await prisma.virtual_numbers.upsert({
     *   create: {
     *     // ... data to create a Virtual_numbers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Virtual_numbers we want to update
     *   }
     * })
     */
    upsert<T extends virtual_numbersUpsertArgs>(args: SelectSubset<T, virtual_numbersUpsertArgs<ExtArgs>>): Prisma__virtual_numbersClient<$Result.GetResult<Prisma.$virtual_numbersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Virtual_numbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {virtual_numbersCountArgs} args - Arguments to filter Virtual_numbers to count.
     * @example
     * // Count the number of Virtual_numbers
     * const count = await prisma.virtual_numbers.count({
     *   where: {
     *     // ... the filter for the Virtual_numbers we want to count
     *   }
     * })
    **/
    count<T extends virtual_numbersCountArgs>(
      args?: Subset<T, virtual_numbersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Virtual_numbersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Virtual_numbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Virtual_numbersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Virtual_numbersAggregateArgs>(args: Subset<T, Virtual_numbersAggregateArgs>): Prisma.PrismaPromise<GetVirtual_numbersAggregateType<T>>

    /**
     * Group by Virtual_numbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {virtual_numbersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends virtual_numbersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: virtual_numbersGroupByArgs['orderBy'] }
        : { orderBy?: virtual_numbersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, virtual_numbersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVirtual_numbersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the virtual_numbers model
   */
  readonly fields: virtual_numbersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for virtual_numbers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__virtual_numbersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    virtual_assignments<T extends virtual_numbers$virtual_assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, virtual_numbers$virtual_assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$virtual_assignmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the virtual_numbers model
   */
  interface virtual_numbersFieldRefs {
    readonly id: FieldRef<"virtual_numbers", 'String'>
    readonly phoneNumber: FieldRef<"virtual_numbers", 'String'>
    readonly isAssigned: FieldRef<"virtual_numbers", 'Boolean'>
    readonly createdAt: FieldRef<"virtual_numbers", 'DateTime'>
    readonly updatedAt: FieldRef<"virtual_numbers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * virtual_numbers findUnique
   */
  export type virtual_numbersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_numbers
     */
    select?: virtual_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_numbers
     */
    omit?: virtual_numbersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: virtual_numbersInclude<ExtArgs> | null
    /**
     * Filter, which virtual_numbers to fetch.
     */
    where: virtual_numbersWhereUniqueInput
  }

  /**
   * virtual_numbers findUniqueOrThrow
   */
  export type virtual_numbersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_numbers
     */
    select?: virtual_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_numbers
     */
    omit?: virtual_numbersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: virtual_numbersInclude<ExtArgs> | null
    /**
     * Filter, which virtual_numbers to fetch.
     */
    where: virtual_numbersWhereUniqueInput
  }

  /**
   * virtual_numbers findFirst
   */
  export type virtual_numbersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_numbers
     */
    select?: virtual_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_numbers
     */
    omit?: virtual_numbersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: virtual_numbersInclude<ExtArgs> | null
    /**
     * Filter, which virtual_numbers to fetch.
     */
    where?: virtual_numbersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of virtual_numbers to fetch.
     */
    orderBy?: virtual_numbersOrderByWithRelationInput | virtual_numbersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for virtual_numbers.
     */
    cursor?: virtual_numbersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` virtual_numbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` virtual_numbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of virtual_numbers.
     */
    distinct?: Virtual_numbersScalarFieldEnum | Virtual_numbersScalarFieldEnum[]
  }

  /**
   * virtual_numbers findFirstOrThrow
   */
  export type virtual_numbersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_numbers
     */
    select?: virtual_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_numbers
     */
    omit?: virtual_numbersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: virtual_numbersInclude<ExtArgs> | null
    /**
     * Filter, which virtual_numbers to fetch.
     */
    where?: virtual_numbersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of virtual_numbers to fetch.
     */
    orderBy?: virtual_numbersOrderByWithRelationInput | virtual_numbersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for virtual_numbers.
     */
    cursor?: virtual_numbersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` virtual_numbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` virtual_numbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of virtual_numbers.
     */
    distinct?: Virtual_numbersScalarFieldEnum | Virtual_numbersScalarFieldEnum[]
  }

  /**
   * virtual_numbers findMany
   */
  export type virtual_numbersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_numbers
     */
    select?: virtual_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_numbers
     */
    omit?: virtual_numbersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: virtual_numbersInclude<ExtArgs> | null
    /**
     * Filter, which virtual_numbers to fetch.
     */
    where?: virtual_numbersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of virtual_numbers to fetch.
     */
    orderBy?: virtual_numbersOrderByWithRelationInput | virtual_numbersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing virtual_numbers.
     */
    cursor?: virtual_numbersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` virtual_numbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` virtual_numbers.
     */
    skip?: number
    distinct?: Virtual_numbersScalarFieldEnum | Virtual_numbersScalarFieldEnum[]
  }

  /**
   * virtual_numbers create
   */
  export type virtual_numbersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_numbers
     */
    select?: virtual_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_numbers
     */
    omit?: virtual_numbersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: virtual_numbersInclude<ExtArgs> | null
    /**
     * The data needed to create a virtual_numbers.
     */
    data: XOR<virtual_numbersCreateInput, virtual_numbersUncheckedCreateInput>
  }

  /**
   * virtual_numbers createMany
   */
  export type virtual_numbersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many virtual_numbers.
     */
    data: virtual_numbersCreateManyInput | virtual_numbersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * virtual_numbers createManyAndReturn
   */
  export type virtual_numbersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_numbers
     */
    select?: virtual_numbersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_numbers
     */
    omit?: virtual_numbersOmit<ExtArgs> | null
    /**
     * The data used to create many virtual_numbers.
     */
    data: virtual_numbersCreateManyInput | virtual_numbersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * virtual_numbers update
   */
  export type virtual_numbersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_numbers
     */
    select?: virtual_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_numbers
     */
    omit?: virtual_numbersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: virtual_numbersInclude<ExtArgs> | null
    /**
     * The data needed to update a virtual_numbers.
     */
    data: XOR<virtual_numbersUpdateInput, virtual_numbersUncheckedUpdateInput>
    /**
     * Choose, which virtual_numbers to update.
     */
    where: virtual_numbersWhereUniqueInput
  }

  /**
   * virtual_numbers updateMany
   */
  export type virtual_numbersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update virtual_numbers.
     */
    data: XOR<virtual_numbersUpdateManyMutationInput, virtual_numbersUncheckedUpdateManyInput>
    /**
     * Filter which virtual_numbers to update
     */
    where?: virtual_numbersWhereInput
    /**
     * Limit how many virtual_numbers to update.
     */
    limit?: number
  }

  /**
   * virtual_numbers updateManyAndReturn
   */
  export type virtual_numbersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_numbers
     */
    select?: virtual_numbersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_numbers
     */
    omit?: virtual_numbersOmit<ExtArgs> | null
    /**
     * The data used to update virtual_numbers.
     */
    data: XOR<virtual_numbersUpdateManyMutationInput, virtual_numbersUncheckedUpdateManyInput>
    /**
     * Filter which virtual_numbers to update
     */
    where?: virtual_numbersWhereInput
    /**
     * Limit how many virtual_numbers to update.
     */
    limit?: number
  }

  /**
   * virtual_numbers upsert
   */
  export type virtual_numbersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_numbers
     */
    select?: virtual_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_numbers
     */
    omit?: virtual_numbersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: virtual_numbersInclude<ExtArgs> | null
    /**
     * The filter to search for the virtual_numbers to update in case it exists.
     */
    where: virtual_numbersWhereUniqueInput
    /**
     * In case the virtual_numbers found by the `where` argument doesn't exist, create a new virtual_numbers with this data.
     */
    create: XOR<virtual_numbersCreateInput, virtual_numbersUncheckedCreateInput>
    /**
     * In case the virtual_numbers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<virtual_numbersUpdateInput, virtual_numbersUncheckedUpdateInput>
  }

  /**
   * virtual_numbers delete
   */
  export type virtual_numbersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_numbers
     */
    select?: virtual_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_numbers
     */
    omit?: virtual_numbersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: virtual_numbersInclude<ExtArgs> | null
    /**
     * Filter which virtual_numbers to delete.
     */
    where: virtual_numbersWhereUniqueInput
  }

  /**
   * virtual_numbers deleteMany
   */
  export type virtual_numbersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which virtual_numbers to delete
     */
    where?: virtual_numbersWhereInput
    /**
     * Limit how many virtual_numbers to delete.
     */
    limit?: number
  }

  /**
   * virtual_numbers.virtual_assignments
   */
  export type virtual_numbers$virtual_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_assignments
     */
    select?: virtual_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_assignments
     */
    omit?: virtual_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: virtual_assignmentsInclude<ExtArgs> | null
    where?: virtual_assignmentsWhereInput
    orderBy?: virtual_assignmentsOrderByWithRelationInput | virtual_assignmentsOrderByWithRelationInput[]
    cursor?: virtual_assignmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Virtual_assignmentsScalarFieldEnum | Virtual_assignmentsScalarFieldEnum[]
  }

  /**
   * virtual_numbers without action
   */
  export type virtual_numbersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the virtual_numbers
     */
    select?: virtual_numbersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the virtual_numbers
     */
    omit?: virtual_numbersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: virtual_numbersInclude<ExtArgs> | null
  }


  /**
   * Model wallets
   */

  export type AggregateWallets = {
    _count: WalletsCountAggregateOutputType | null
    _avg: WalletsAvgAggregateOutputType | null
    _sum: WalletsSumAggregateOutputType | null
    _min: WalletsMinAggregateOutputType | null
    _max: WalletsMaxAggregateOutputType | null
  }

  export type WalletsAvgAggregateOutputType = {
    balance: number | null
  }

  export type WalletsSumAggregateOutputType = {
    balance: number | null
  }

  export type WalletsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletsCountAggregateOutputType = {
    id: number
    userId: number
    balance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WalletsAvgAggregateInputType = {
    balance?: true
  }

  export type WalletsSumAggregateInputType = {
    balance?: true
  }

  export type WalletsMinAggregateInputType = {
    id?: true
    userId?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletsMaxAggregateInputType = {
    id?: true
    userId?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletsCountAggregateInputType = {
    id?: true
    userId?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WalletsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallets to aggregate.
     */
    where?: walletsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletsOrderByWithRelationInput | walletsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: walletsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wallets
    **/
    _count?: true | WalletsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletsMaxAggregateInputType
  }

  export type GetWalletsAggregateType<T extends WalletsAggregateArgs> = {
        [P in keyof T & keyof AggregateWallets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallets[P]>
      : GetScalarType<T[P], AggregateWallets[P]>
  }




  export type walletsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: walletsWhereInput
    orderBy?: walletsOrderByWithAggregationInput | walletsOrderByWithAggregationInput[]
    by: WalletsScalarFieldEnum[] | WalletsScalarFieldEnum
    having?: walletsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletsCountAggregateInputType | true
    _avg?: WalletsAvgAggregateInputType
    _sum?: WalletsSumAggregateInputType
    _min?: WalletsMinAggregateInputType
    _max?: WalletsMaxAggregateInputType
  }

  export type WalletsGroupByOutputType = {
    id: string
    userId: string
    balance: number
    createdAt: Date
    updatedAt: Date
    _count: WalletsCountAggregateOutputType | null
    _avg: WalletsAvgAggregateOutputType | null
    _sum: WalletsSumAggregateOutputType | null
    _min: WalletsMinAggregateOutputType | null
    _max: WalletsMaxAggregateOutputType | null
  }

  type GetWalletsGroupByPayload<T extends walletsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletsGroupByOutputType[P]>
            : GetScalarType<T[P], WalletsGroupByOutputType[P]>
        }
      >
    >


  export type walletsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactions?: boolean | wallets$transactionsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | WalletsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallets"]>

  export type walletsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallets"]>

  export type walletsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallets"]>

  export type walletsSelectScalar = {
    id?: boolean
    userId?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type walletsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "balance" | "createdAt" | "updatedAt", ExtArgs["result"]["wallets"]>
  export type walletsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | wallets$transactionsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | WalletsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type walletsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type walletsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $walletsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "wallets"
    objects: {
      transactions: Prisma.$transactionsPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      balance: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wallets"]>
    composites: {}
  }

  type walletsGetPayload<S extends boolean | null | undefined | walletsDefaultArgs> = $Result.GetResult<Prisma.$walletsPayload, S>

  type walletsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<walletsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletsCountAggregateInputType | true
    }

  export interface walletsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wallets'], meta: { name: 'wallets' } }
    /**
     * Find zero or one Wallets that matches the filter.
     * @param {walletsFindUniqueArgs} args - Arguments to find a Wallets
     * @example
     * // Get one Wallets
     * const wallets = await prisma.wallets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends walletsFindUniqueArgs>(args: SelectSubset<T, walletsFindUniqueArgs<ExtArgs>>): Prisma__walletsClient<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Wallets that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {walletsFindUniqueOrThrowArgs} args - Arguments to find a Wallets
     * @example
     * // Get one Wallets
     * const wallets = await prisma.wallets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends walletsFindUniqueOrThrowArgs>(args: SelectSubset<T, walletsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__walletsClient<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletsFindFirstArgs} args - Arguments to find a Wallets
     * @example
     * // Get one Wallets
     * const wallets = await prisma.wallets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends walletsFindFirstArgs>(args?: SelectSubset<T, walletsFindFirstArgs<ExtArgs>>): Prisma__walletsClient<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletsFindFirstOrThrowArgs} args - Arguments to find a Wallets
     * @example
     * // Get one Wallets
     * const wallets = await prisma.wallets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends walletsFindFirstOrThrowArgs>(args?: SelectSubset<T, walletsFindFirstOrThrowArgs<ExtArgs>>): Prisma__walletsClient<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallets.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletsWithIdOnly = await prisma.wallets.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends walletsFindManyArgs>(args?: SelectSubset<T, walletsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Wallets.
     * @param {walletsCreateArgs} args - Arguments to create a Wallets.
     * @example
     * // Create one Wallets
     * const Wallets = await prisma.wallets.create({
     *   data: {
     *     // ... data to create a Wallets
     *   }
     * })
     * 
     */
    create<T extends walletsCreateArgs>(args: SelectSubset<T, walletsCreateArgs<ExtArgs>>): Prisma__walletsClient<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wallets.
     * @param {walletsCreateManyArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallets = await prisma.wallets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends walletsCreateManyArgs>(args?: SelectSubset<T, walletsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wallets and returns the data saved in the database.
     * @param {walletsCreateManyAndReturnArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallets = await prisma.wallets.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wallets and only return the `id`
     * const walletsWithIdOnly = await prisma.wallets.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends walletsCreateManyAndReturnArgs>(args?: SelectSubset<T, walletsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Wallets.
     * @param {walletsDeleteArgs} args - Arguments to delete one Wallets.
     * @example
     * // Delete one Wallets
     * const Wallets = await prisma.wallets.delete({
     *   where: {
     *     // ... filter to delete one Wallets
     *   }
     * })
     * 
     */
    delete<T extends walletsDeleteArgs>(args: SelectSubset<T, walletsDeleteArgs<ExtArgs>>): Prisma__walletsClient<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Wallets.
     * @param {walletsUpdateArgs} args - Arguments to update one Wallets.
     * @example
     * // Update one Wallets
     * const wallets = await prisma.wallets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends walletsUpdateArgs>(args: SelectSubset<T, walletsUpdateArgs<ExtArgs>>): Prisma__walletsClient<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wallets.
     * @param {walletsDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends walletsDeleteManyArgs>(args?: SelectSubset<T, walletsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallets = await prisma.wallets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends walletsUpdateManyArgs>(args: SelectSubset<T, walletsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets and returns the data updated in the database.
     * @param {walletsUpdateManyAndReturnArgs} args - Arguments to update many Wallets.
     * @example
     * // Update many Wallets
     * const wallets = await prisma.wallets.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Wallets and only return the `id`
     * const walletsWithIdOnly = await prisma.wallets.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends walletsUpdateManyAndReturnArgs>(args: SelectSubset<T, walletsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Wallets.
     * @param {walletsUpsertArgs} args - Arguments to update or create a Wallets.
     * @example
     * // Update or create a Wallets
     * const wallets = await prisma.wallets.upsert({
     *   create: {
     *     // ... data to create a Wallets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallets we want to update
     *   }
     * })
     */
    upsert<T extends walletsUpsertArgs>(args: SelectSubset<T, walletsUpsertArgs<ExtArgs>>): Prisma__walletsClient<$Result.GetResult<Prisma.$walletsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletsCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallets.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends walletsCountArgs>(
      args?: Subset<T, walletsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletsAggregateArgs>(args: Subset<T, WalletsAggregateArgs>): Prisma.PrismaPromise<GetWalletsAggregateType<T>>

    /**
     * Group by Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends walletsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: walletsGroupByArgs['orderBy'] }
        : { orderBy?: walletsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, walletsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wallets model
   */
  readonly fields: walletsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wallets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__walletsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends wallets$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, wallets$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the wallets model
   */
  interface walletsFieldRefs {
    readonly id: FieldRef<"wallets", 'String'>
    readonly userId: FieldRef<"wallets", 'String'>
    readonly balance: FieldRef<"wallets", 'Float'>
    readonly createdAt: FieldRef<"wallets", 'DateTime'>
    readonly updatedAt: FieldRef<"wallets", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * wallets findUnique
   */
  export type walletsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsInclude<ExtArgs> | null
    /**
     * Filter, which wallets to fetch.
     */
    where: walletsWhereUniqueInput
  }

  /**
   * wallets findUniqueOrThrow
   */
  export type walletsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsInclude<ExtArgs> | null
    /**
     * Filter, which wallets to fetch.
     */
    where: walletsWhereUniqueInput
  }

  /**
   * wallets findFirst
   */
  export type walletsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsInclude<ExtArgs> | null
    /**
     * Filter, which wallets to fetch.
     */
    where?: walletsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletsOrderByWithRelationInput | walletsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallets.
     */
    cursor?: walletsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallets.
     */
    distinct?: WalletsScalarFieldEnum | WalletsScalarFieldEnum[]
  }

  /**
   * wallets findFirstOrThrow
   */
  export type walletsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsInclude<ExtArgs> | null
    /**
     * Filter, which wallets to fetch.
     */
    where?: walletsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletsOrderByWithRelationInput | walletsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallets.
     */
    cursor?: walletsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallets.
     */
    distinct?: WalletsScalarFieldEnum | WalletsScalarFieldEnum[]
  }

  /**
   * wallets findMany
   */
  export type walletsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsInclude<ExtArgs> | null
    /**
     * Filter, which wallets to fetch.
     */
    where?: walletsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletsOrderByWithRelationInput | walletsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wallets.
     */
    cursor?: walletsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    distinct?: WalletsScalarFieldEnum | WalletsScalarFieldEnum[]
  }

  /**
   * wallets create
   */
  export type walletsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsInclude<ExtArgs> | null
    /**
     * The data needed to create a wallets.
     */
    data: XOR<walletsCreateInput, walletsUncheckedCreateInput>
  }

  /**
   * wallets createMany
   */
  export type walletsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wallets.
     */
    data: walletsCreateManyInput | walletsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * wallets createManyAndReturn
   */
  export type walletsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * The data used to create many wallets.
     */
    data: walletsCreateManyInput | walletsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * wallets update
   */
  export type walletsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsInclude<ExtArgs> | null
    /**
     * The data needed to update a wallets.
     */
    data: XOR<walletsUpdateInput, walletsUncheckedUpdateInput>
    /**
     * Choose, which wallets to update.
     */
    where: walletsWhereUniqueInput
  }

  /**
   * wallets updateMany
   */
  export type walletsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wallets.
     */
    data: XOR<walletsUpdateManyMutationInput, walletsUncheckedUpdateManyInput>
    /**
     * Filter which wallets to update
     */
    where?: walletsWhereInput
    /**
     * Limit how many wallets to update.
     */
    limit?: number
  }

  /**
   * wallets updateManyAndReturn
   */
  export type walletsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * The data used to update wallets.
     */
    data: XOR<walletsUpdateManyMutationInput, walletsUncheckedUpdateManyInput>
    /**
     * Filter which wallets to update
     */
    where?: walletsWhereInput
    /**
     * Limit how many wallets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * wallets upsert
   */
  export type walletsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsInclude<ExtArgs> | null
    /**
     * The filter to search for the wallets to update in case it exists.
     */
    where: walletsWhereUniqueInput
    /**
     * In case the wallets found by the `where` argument doesn't exist, create a new wallets with this data.
     */
    create: XOR<walletsCreateInput, walletsUncheckedCreateInput>
    /**
     * In case the wallets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<walletsUpdateInput, walletsUncheckedUpdateInput>
  }

  /**
   * wallets delete
   */
  export type walletsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsInclude<ExtArgs> | null
    /**
     * Filter which wallets to delete.
     */
    where: walletsWhereUniqueInput
  }

  /**
   * wallets deleteMany
   */
  export type walletsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallets to delete
     */
    where?: walletsWhereInput
    /**
     * Limit how many wallets to delete.
     */
    limit?: number
  }

  /**
   * wallets.transactions
   */
  export type wallets$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    where?: transactionsWhereInput
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    cursor?: transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * wallets without action
   */
  export type walletsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallets
     */
    select?: walletsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallets
     */
    omit?: walletsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletsInclude<ExtArgs> | null
  }


  /**
   * Model zones
   */

  export type AggregateZones = {
    _count: ZonesCountAggregateOutputType | null
    _min: ZonesMinAggregateOutputType | null
    _max: ZonesMaxAggregateOutputType | null
  }

  export type ZonesMinAggregateOutputType = {
    id: string | null
    name: string | null
    city: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ZonesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    city: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ZonesCountAggregateOutputType = {
    id: number
    name: number
    city: number
    polygon: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ZonesMinAggregateInputType = {
    id?: true
    name?: true
    city?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ZonesMaxAggregateInputType = {
    id?: true
    name?: true
    city?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ZonesCountAggregateInputType = {
    id?: true
    name?: true
    city?: true
    polygon?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ZonesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which zones to aggregate.
     */
    where?: zonesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zones to fetch.
     */
    orderBy?: zonesOrderByWithRelationInput | zonesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: zonesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned zones
    **/
    _count?: true | ZonesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZonesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZonesMaxAggregateInputType
  }

  export type GetZonesAggregateType<T extends ZonesAggregateArgs> = {
        [P in keyof T & keyof AggregateZones]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZones[P]>
      : GetScalarType<T[P], AggregateZones[P]>
  }




  export type zonesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: zonesWhereInput
    orderBy?: zonesOrderByWithAggregationInput | zonesOrderByWithAggregationInput[]
    by: ZonesScalarFieldEnum[] | ZonesScalarFieldEnum
    having?: zonesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZonesCountAggregateInputType | true
    _min?: ZonesMinAggregateInputType
    _max?: ZonesMaxAggregateInputType
  }

  export type ZonesGroupByOutputType = {
    id: string
    name: string
    city: string
    polygon: JsonValue
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ZonesCountAggregateOutputType | null
    _min: ZonesMinAggregateOutputType | null
    _max: ZonesMaxAggregateOutputType | null
  }

  type GetZonesGroupByPayload<T extends zonesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZonesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZonesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZonesGroupByOutputType[P]>
            : GetScalarType<T[P], ZonesGroupByOutputType[P]>
        }
      >
    >


  export type zonesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    city?: boolean
    polygon?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider_locations?: boolean | zones$provider_locationsArgs<ExtArgs>
    _count?: boolean | ZonesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zones"]>

  export type zonesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    city?: boolean
    polygon?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["zones"]>

  export type zonesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    city?: boolean
    polygon?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["zones"]>

  export type zonesSelectScalar = {
    id?: boolean
    name?: boolean
    city?: boolean
    polygon?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type zonesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "city" | "polygon" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["zones"]>
  export type zonesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider_locations?: boolean | zones$provider_locationsArgs<ExtArgs>
    _count?: boolean | ZonesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type zonesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type zonesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $zonesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "zones"
    objects: {
      provider_locations: Prisma.$provider_locationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      city: string
      polygon: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["zones"]>
    composites: {}
  }

  type zonesGetPayload<S extends boolean | null | undefined | zonesDefaultArgs> = $Result.GetResult<Prisma.$zonesPayload, S>

  type zonesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<zonesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ZonesCountAggregateInputType | true
    }

  export interface zonesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['zones'], meta: { name: 'zones' } }
    /**
     * Find zero or one Zones that matches the filter.
     * @param {zonesFindUniqueArgs} args - Arguments to find a Zones
     * @example
     * // Get one Zones
     * const zones = await prisma.zones.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends zonesFindUniqueArgs>(args: SelectSubset<T, zonesFindUniqueArgs<ExtArgs>>): Prisma__zonesClient<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Zones that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {zonesFindUniqueOrThrowArgs} args - Arguments to find a Zones
     * @example
     * // Get one Zones
     * const zones = await prisma.zones.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends zonesFindUniqueOrThrowArgs>(args: SelectSubset<T, zonesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__zonesClient<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zonesFindFirstArgs} args - Arguments to find a Zones
     * @example
     * // Get one Zones
     * const zones = await prisma.zones.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends zonesFindFirstArgs>(args?: SelectSubset<T, zonesFindFirstArgs<ExtArgs>>): Prisma__zonesClient<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zones that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zonesFindFirstOrThrowArgs} args - Arguments to find a Zones
     * @example
     * // Get one Zones
     * const zones = await prisma.zones.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends zonesFindFirstOrThrowArgs>(args?: SelectSubset<T, zonesFindFirstOrThrowArgs<ExtArgs>>): Prisma__zonesClient<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Zones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zonesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Zones
     * const zones = await prisma.zones.findMany()
     * 
     * // Get first 10 Zones
     * const zones = await prisma.zones.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zonesWithIdOnly = await prisma.zones.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends zonesFindManyArgs>(args?: SelectSubset<T, zonesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Zones.
     * @param {zonesCreateArgs} args - Arguments to create a Zones.
     * @example
     * // Create one Zones
     * const Zones = await prisma.zones.create({
     *   data: {
     *     // ... data to create a Zones
     *   }
     * })
     * 
     */
    create<T extends zonesCreateArgs>(args: SelectSubset<T, zonesCreateArgs<ExtArgs>>): Prisma__zonesClient<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Zones.
     * @param {zonesCreateManyArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zones = await prisma.zones.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends zonesCreateManyArgs>(args?: SelectSubset<T, zonesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Zones and returns the data saved in the database.
     * @param {zonesCreateManyAndReturnArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zones = await prisma.zones.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Zones and only return the `id`
     * const zonesWithIdOnly = await prisma.zones.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends zonesCreateManyAndReturnArgs>(args?: SelectSubset<T, zonesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Zones.
     * @param {zonesDeleteArgs} args - Arguments to delete one Zones.
     * @example
     * // Delete one Zones
     * const Zones = await prisma.zones.delete({
     *   where: {
     *     // ... filter to delete one Zones
     *   }
     * })
     * 
     */
    delete<T extends zonesDeleteArgs>(args: SelectSubset<T, zonesDeleteArgs<ExtArgs>>): Prisma__zonesClient<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Zones.
     * @param {zonesUpdateArgs} args - Arguments to update one Zones.
     * @example
     * // Update one Zones
     * const zones = await prisma.zones.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends zonesUpdateArgs>(args: SelectSubset<T, zonesUpdateArgs<ExtArgs>>): Prisma__zonesClient<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Zones.
     * @param {zonesDeleteManyArgs} args - Arguments to filter Zones to delete.
     * @example
     * // Delete a few Zones
     * const { count } = await prisma.zones.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends zonesDeleteManyArgs>(args?: SelectSubset<T, zonesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zonesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Zones
     * const zones = await prisma.zones.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends zonesUpdateManyArgs>(args: SelectSubset<T, zonesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones and returns the data updated in the database.
     * @param {zonesUpdateManyAndReturnArgs} args - Arguments to update many Zones.
     * @example
     * // Update many Zones
     * const zones = await prisma.zones.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Zones and only return the `id`
     * const zonesWithIdOnly = await prisma.zones.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends zonesUpdateManyAndReturnArgs>(args: SelectSubset<T, zonesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Zones.
     * @param {zonesUpsertArgs} args - Arguments to update or create a Zones.
     * @example
     * // Update or create a Zones
     * const zones = await prisma.zones.upsert({
     *   create: {
     *     // ... data to create a Zones
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Zones we want to update
     *   }
     * })
     */
    upsert<T extends zonesUpsertArgs>(args: SelectSubset<T, zonesUpsertArgs<ExtArgs>>): Prisma__zonesClient<$Result.GetResult<Prisma.$zonesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zonesCountArgs} args - Arguments to filter Zones to count.
     * @example
     * // Count the number of Zones
     * const count = await prisma.zones.count({
     *   where: {
     *     // ... the filter for the Zones we want to count
     *   }
     * })
    **/
    count<T extends zonesCountArgs>(
      args?: Subset<T, zonesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZonesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZonesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZonesAggregateArgs>(args: Subset<T, ZonesAggregateArgs>): Prisma.PrismaPromise<GetZonesAggregateType<T>>

    /**
     * Group by Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zonesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends zonesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: zonesGroupByArgs['orderBy'] }
        : { orderBy?: zonesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, zonesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZonesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the zones model
   */
  readonly fields: zonesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for zones.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__zonesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider_locations<T extends zones$provider_locationsArgs<ExtArgs> = {}>(args?: Subset<T, zones$provider_locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_locationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the zones model
   */
  interface zonesFieldRefs {
    readonly id: FieldRef<"zones", 'String'>
    readonly name: FieldRef<"zones", 'String'>
    readonly city: FieldRef<"zones", 'String'>
    readonly polygon: FieldRef<"zones", 'Json'>
    readonly isActive: FieldRef<"zones", 'Boolean'>
    readonly createdAt: FieldRef<"zones", 'DateTime'>
    readonly updatedAt: FieldRef<"zones", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * zones findUnique
   */
  export type zonesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
    /**
     * Filter, which zones to fetch.
     */
    where: zonesWhereUniqueInput
  }

  /**
   * zones findUniqueOrThrow
   */
  export type zonesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
    /**
     * Filter, which zones to fetch.
     */
    where: zonesWhereUniqueInput
  }

  /**
   * zones findFirst
   */
  export type zonesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
    /**
     * Filter, which zones to fetch.
     */
    where?: zonesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zones to fetch.
     */
    orderBy?: zonesOrderByWithRelationInput | zonesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for zones.
     */
    cursor?: zonesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of zones.
     */
    distinct?: ZonesScalarFieldEnum | ZonesScalarFieldEnum[]
  }

  /**
   * zones findFirstOrThrow
   */
  export type zonesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
    /**
     * Filter, which zones to fetch.
     */
    where?: zonesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zones to fetch.
     */
    orderBy?: zonesOrderByWithRelationInput | zonesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for zones.
     */
    cursor?: zonesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of zones.
     */
    distinct?: ZonesScalarFieldEnum | ZonesScalarFieldEnum[]
  }

  /**
   * zones findMany
   */
  export type zonesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
    /**
     * Filter, which zones to fetch.
     */
    where?: zonesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zones to fetch.
     */
    orderBy?: zonesOrderByWithRelationInput | zonesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing zones.
     */
    cursor?: zonesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zones.
     */
    skip?: number
    distinct?: ZonesScalarFieldEnum | ZonesScalarFieldEnum[]
  }

  /**
   * zones create
   */
  export type zonesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
    /**
     * The data needed to create a zones.
     */
    data: XOR<zonesCreateInput, zonesUncheckedCreateInput>
  }

  /**
   * zones createMany
   */
  export type zonesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many zones.
     */
    data: zonesCreateManyInput | zonesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * zones createManyAndReturn
   */
  export type zonesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * The data used to create many zones.
     */
    data: zonesCreateManyInput | zonesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * zones update
   */
  export type zonesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
    /**
     * The data needed to update a zones.
     */
    data: XOR<zonesUpdateInput, zonesUncheckedUpdateInput>
    /**
     * Choose, which zones to update.
     */
    where: zonesWhereUniqueInput
  }

  /**
   * zones updateMany
   */
  export type zonesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update zones.
     */
    data: XOR<zonesUpdateManyMutationInput, zonesUncheckedUpdateManyInput>
    /**
     * Filter which zones to update
     */
    where?: zonesWhereInput
    /**
     * Limit how many zones to update.
     */
    limit?: number
  }

  /**
   * zones updateManyAndReturn
   */
  export type zonesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * The data used to update zones.
     */
    data: XOR<zonesUpdateManyMutationInput, zonesUncheckedUpdateManyInput>
    /**
     * Filter which zones to update
     */
    where?: zonesWhereInput
    /**
     * Limit how many zones to update.
     */
    limit?: number
  }

  /**
   * zones upsert
   */
  export type zonesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
    /**
     * The filter to search for the zones to update in case it exists.
     */
    where: zonesWhereUniqueInput
    /**
     * In case the zones found by the `where` argument doesn't exist, create a new zones with this data.
     */
    create: XOR<zonesCreateInput, zonesUncheckedCreateInput>
    /**
     * In case the zones was found with the provided `where` argument, update it with this data.
     */
    update: XOR<zonesUpdateInput, zonesUncheckedUpdateInput>
  }

  /**
   * zones delete
   */
  export type zonesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
    /**
     * Filter which zones to delete.
     */
    where: zonesWhereUniqueInput
  }

  /**
   * zones deleteMany
   */
  export type zonesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which zones to delete
     */
    where?: zonesWhereInput
    /**
     * Limit how many zones to delete.
     */
    limit?: number
  }

  /**
   * zones.provider_locations
   */
  export type zones$provider_locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_locations
     */
    select?: provider_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_locations
     */
    omit?: provider_locationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_locationsInclude<ExtArgs> | null
    where?: provider_locationsWhereInput
    orderBy?: provider_locationsOrderByWithRelationInput | provider_locationsOrderByWithRelationInput[]
    cursor?: provider_locationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Provider_locationsScalarFieldEnum | Provider_locationsScalarFieldEnum[]
  }

  /**
   * zones without action
   */
  export type zonesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zones
     */
    select?: zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zones
     */
    omit?: zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zonesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Admin_actionsScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    action: 'action',
    targetId: 'targetId',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type Admin_actionsScalarFieldEnum = (typeof Admin_actionsScalarFieldEnum)[keyof typeof Admin_actionsScalarFieldEnum]


  export const Call_logsScalarFieldEnum: {
    id: 'id',
    callSessionId: 'callSessionId',
    status: 'status',
    duration: 'duration',
    timestamp: 'timestamp'
  };

  export type Call_logsScalarFieldEnum = (typeof Call_logsScalarFieldEnum)[keyof typeof Call_logsScalarFieldEnum]


  export const Call_sessionsScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    providerId: 'providerId',
    orderId: 'orderId',
    twilioCallSid: 'twilioCallSid',
    customerPhone: 'customerPhone',
    providerPhone: 'providerPhone',
    status: 'status',
    duration: 'duration',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Call_sessionsScalarFieldEnum = (typeof Call_sessionsScalarFieldEnum)[keyof typeof Call_sessionsScalarFieldEnum]


  export const FaqsScalarFieldEnum: {
    id: 'id',
    question: 'question',
    answer: 'answer',
    category: 'category',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FaqsScalarFieldEnum = (typeof FaqsScalarFieldEnum)[keyof typeof FaqsScalarFieldEnum]


  export const MessagesScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    receiverId: 'receiverId',
    content: 'content',
    orderId: 'orderId',
    createdAt: 'createdAt'
  };

  export type MessagesScalarFieldEnum = (typeof MessagesScalarFieldEnum)[keyof typeof MessagesScalarFieldEnum]


  export const Notification_preferencesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    pushEnabled: 'pushEnabled',
    emailEnabled: 'emailEnabled',
    smsEnabled: 'smsEnabled',
    orderUpdates: 'orderUpdates',
    messages: 'messages',
    promotions: 'promotions',
    systemAlerts: 'systemAlerts',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Notification_preferencesScalarFieldEnum = (typeof Notification_preferencesScalarFieldEnum)[keyof typeof Notification_preferencesScalarFieldEnum]


  export const Notification_tokensScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    platform: 'platform',
    createdAt: 'createdAt'
  };

  export type Notification_tokensScalarFieldEnum = (typeof Notification_tokensScalarFieldEnum)[keyof typeof Notification_tokensScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    body: 'body',
    data: 'data',
    type: 'type',
    status: 'status',
    readAt: 'readAt',
    createdAt: 'createdAt'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const OrdersScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    providerId: 'providerId',
    serviceId: 'serviceId',
    status: 'status',
    totalAmount: 'totalAmount',
    commission: 'commission',
    serviceDate: 'serviceDate',
    address: 'address',
    notes: 'notes',
    cancelledBy: 'cancelledBy',
    cancelReason: 'cancelReason',
    cancelledAt: 'cancelledAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrdersScalarFieldEnum = (typeof OrdersScalarFieldEnum)[keyof typeof OrdersScalarFieldEnum]


  export const OtpsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    code: 'code',
    type: 'type',
    isUsed: 'isUsed',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type OtpsScalarFieldEnum = (typeof OtpsScalarFieldEnum)[keyof typeof OtpsScalarFieldEnum]


  export const Payment_ordersScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    orderId: 'orderId',
    paymentId: 'paymentId',
    amount: 'amount',
    currency: 'currency',
    paymentMethod: 'paymentMethod',
    status: 'status',
    type: 'type',
    signature: 'signature',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Payment_ordersScalarFieldEnum = (typeof Payment_ordersScalarFieldEnum)[keyof typeof Payment_ordersScalarFieldEnum]


  export const ProfilesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    avatar: 'avatar',
    address: 'address',
    pincode: 'pincode',
    city: 'city',
    state: 'state',
    country: 'country',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    passwordHash: 'passwordHash',
    googleId: 'googleId',
    googleVerified: 'googleVerified'
  };

  export type ProfilesScalarFieldEnum = (typeof ProfilesScalarFieldEnum)[keyof typeof ProfilesScalarFieldEnum]


  export const Provider_locationsScalarFieldEnum: {
    id: 'id',
    providerId: 'providerId',
    lat: 'lat',
    lng: 'lng',
    address: 'address',
    zoneId: 'zoneId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Provider_locationsScalarFieldEnum = (typeof Provider_locationsScalarFieldEnum)[keyof typeof Provider_locationsScalarFieldEnum]


  export const ProvidersScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    businessName: 'businessName',
    providerType: 'providerType',
    category: 'category',
    area: 'area',
    address: 'address',
    panNumber: 'panNumber',
    aadhaarNumber: 'aadhaarNumber',
    gstNumber: 'gstNumber',
    bankAccount: 'bankAccount',
    upiId: 'upiId',
    isVerified: 'isVerified',
    isActive: 'isActive',
    rating: 'rating',
    totalOrders: 'totalOrders',
    isOnline: 'isOnline',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProvidersScalarFieldEnum = (typeof ProvidersScalarFieldEnum)[keyof typeof ProvidersScalarFieldEnum]


  export const Report_schedulesScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    reportType: 'reportType',
    frequency: 'frequency',
    email: 'email',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Report_schedulesScalarFieldEnum = (typeof Report_schedulesScalarFieldEnum)[keyof typeof Report_schedulesScalarFieldEnum]


  export const ReviewsScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    reviewerId: 'reviewerId',
    revieweeId: 'revieweeId',
    providerId: 'providerId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt'
  };

  export type ReviewsScalarFieldEnum = (typeof ReviewsScalarFieldEnum)[keyof typeof ReviewsScalarFieldEnum]


  export const ServicesScalarFieldEnum: {
    id: 'id',
    providerId: 'providerId',
    name: 'name',
    description: 'description',
    category: 'category',
    price: 'price',
    basePrice: 'basePrice',
    offerPercent: 'offerPercent',
    estimatedTime: 'estimatedTime',
    warrantyMonths: 'warrantyMonths',
    duration: 'duration',
    status: 'status',
    isActive: 'isActive',
    rejectionReason: 'rejectionReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServicesScalarFieldEnum = (typeof ServicesScalarFieldEnum)[keyof typeof ServicesScalarFieldEnum]


  export const TicketsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    subject: 'subject',
    description: 'description',
    status: 'status',
    priority: 'priority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TicketsScalarFieldEnum = (typeof TicketsScalarFieldEnum)[keyof typeof TicketsScalarFieldEnum]


  export const TransactionsScalarFieldEnum: {
    id: 'id',
    walletId: 'walletId',
    amount: 'amount',
    type: 'type',
    description: 'description',
    paymentMethod: 'paymentMethod',
    orderId: 'orderId',
    createdAt: 'createdAt'
  };

  export type TransactionsScalarFieldEnum = (typeof TransactionsScalarFieldEnum)[keyof typeof TransactionsScalarFieldEnum]


  export const User_payment_methodsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    upiId: 'upiId',
    cardNumber: 'cardNumber',
    cardName: 'cardName',
    expiryMonth: 'expiryMonth',
    expiryYear: 'expiryYear',
    last4: 'last4',
    isDefault: 'isDefault',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type User_payment_methodsScalarFieldEnum = (typeof User_payment_methodsScalarFieldEnum)[keyof typeof User_payment_methodsScalarFieldEnum]


  export const User_verificationsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    idType: 'idType',
    idNumber: 'idNumber',
    idFrontImage: 'idFrontImage',
    idBackImage: 'idBackImage',
    addressProofType: 'addressProofType',
    addressProofNumber: 'addressProofNumber',
    addressProofImage: 'addressProofImage',
    verificationStatus: 'verificationStatus',
    verifiedAt: 'verifiedAt',
    verifiedBy: 'verifiedBy',
    rejectionReason: 'rejectionReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type User_verificationsScalarFieldEnum = (typeof User_verificationsScalarFieldEnum)[keyof typeof User_verificationsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    email: 'email',
    phone: 'phone',
    userType: 'userType',
    isVerified: 'isVerified',
    isActive: 'isActive',
    isBlocked: 'isBlocked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    cancellationsCount: 'cancellationsCount',
    isSuspect: 'isSuspect'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const Virtual_assignmentsScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    virtualNumberId: 'virtualNumberId',
    status: 'status',
    assignedAt: 'assignedAt',
    releasedAt: 'releasedAt'
  };

  export type Virtual_assignmentsScalarFieldEnum = (typeof Virtual_assignmentsScalarFieldEnum)[keyof typeof Virtual_assignmentsScalarFieldEnum]


  export const Virtual_numbersScalarFieldEnum: {
    id: 'id',
    phoneNumber: 'phoneNumber',
    isAssigned: 'isAssigned',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Virtual_numbersScalarFieldEnum = (typeof Virtual_numbersScalarFieldEnum)[keyof typeof Virtual_numbersScalarFieldEnum]


  export const WalletsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    balance: 'balance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WalletsScalarFieldEnum = (typeof WalletsScalarFieldEnum)[keyof typeof WalletsScalarFieldEnum]


  export const ZonesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    city: 'city',
    polygon: 'polygon',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ZonesScalarFieldEnum = (typeof ZonesScalarFieldEnum)[keyof typeof ZonesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ProviderType'
   */
  export type EnumProviderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProviderType'>
    


  /**
   * Reference to a field of type 'ProviderType[]'
   */
  export type ListEnumProviderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProviderType[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'UserType'
   */
  export type EnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType'>
    


  /**
   * Reference to a field of type 'UserType[]'
   */
  export type ListEnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType[]'>
    
  /**
   * Deep Input Types
   */


  export type admin_actionsWhereInput = {
    AND?: admin_actionsWhereInput | admin_actionsWhereInput[]
    OR?: admin_actionsWhereInput[]
    NOT?: admin_actionsWhereInput | admin_actionsWhereInput[]
    id?: StringFilter<"admin_actions"> | string
    adminId?: StringFilter<"admin_actions"> | string
    action?: StringFilter<"admin_actions"> | string
    targetId?: StringFilter<"admin_actions"> | string
    details?: JsonNullableFilter<"admin_actions">
    createdAt?: DateTimeFilter<"admin_actions"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type admin_actionsOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetId?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type admin_actionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: admin_actionsWhereInput | admin_actionsWhereInput[]
    OR?: admin_actionsWhereInput[]
    NOT?: admin_actionsWhereInput | admin_actionsWhereInput[]
    adminId?: StringFilter<"admin_actions"> | string
    action?: StringFilter<"admin_actions"> | string
    targetId?: StringFilter<"admin_actions"> | string
    details?: JsonNullableFilter<"admin_actions">
    createdAt?: DateTimeFilter<"admin_actions"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type admin_actionsOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetId?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: admin_actionsCountOrderByAggregateInput
    _max?: admin_actionsMaxOrderByAggregateInput
    _min?: admin_actionsMinOrderByAggregateInput
  }

  export type admin_actionsScalarWhereWithAggregatesInput = {
    AND?: admin_actionsScalarWhereWithAggregatesInput | admin_actionsScalarWhereWithAggregatesInput[]
    OR?: admin_actionsScalarWhereWithAggregatesInput[]
    NOT?: admin_actionsScalarWhereWithAggregatesInput | admin_actionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"admin_actions"> | string
    adminId?: StringWithAggregatesFilter<"admin_actions"> | string
    action?: StringWithAggregatesFilter<"admin_actions"> | string
    targetId?: StringWithAggregatesFilter<"admin_actions"> | string
    details?: JsonNullableWithAggregatesFilter<"admin_actions">
    createdAt?: DateTimeWithAggregatesFilter<"admin_actions"> | Date | string
  }

  export type call_logsWhereInput = {
    AND?: call_logsWhereInput | call_logsWhereInput[]
    OR?: call_logsWhereInput[]
    NOT?: call_logsWhereInput | call_logsWhereInput[]
    id?: StringFilter<"call_logs"> | string
    callSessionId?: StringFilter<"call_logs"> | string
    status?: StringFilter<"call_logs"> | string
    duration?: IntNullableFilter<"call_logs"> | number | null
    timestamp?: DateTimeFilter<"call_logs"> | Date | string
    call_sessions?: XOR<Call_sessionsScalarRelationFilter, call_sessionsWhereInput>
  }

  export type call_logsOrderByWithRelationInput = {
    id?: SortOrder
    callSessionId?: SortOrder
    status?: SortOrder
    duration?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    call_sessions?: call_sessionsOrderByWithRelationInput
  }

  export type call_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: call_logsWhereInput | call_logsWhereInput[]
    OR?: call_logsWhereInput[]
    NOT?: call_logsWhereInput | call_logsWhereInput[]
    callSessionId?: StringFilter<"call_logs"> | string
    status?: StringFilter<"call_logs"> | string
    duration?: IntNullableFilter<"call_logs"> | number | null
    timestamp?: DateTimeFilter<"call_logs"> | Date | string
    call_sessions?: XOR<Call_sessionsScalarRelationFilter, call_sessionsWhereInput>
  }, "id">

  export type call_logsOrderByWithAggregationInput = {
    id?: SortOrder
    callSessionId?: SortOrder
    status?: SortOrder
    duration?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: call_logsCountOrderByAggregateInput
    _avg?: call_logsAvgOrderByAggregateInput
    _max?: call_logsMaxOrderByAggregateInput
    _min?: call_logsMinOrderByAggregateInput
    _sum?: call_logsSumOrderByAggregateInput
  }

  export type call_logsScalarWhereWithAggregatesInput = {
    AND?: call_logsScalarWhereWithAggregatesInput | call_logsScalarWhereWithAggregatesInput[]
    OR?: call_logsScalarWhereWithAggregatesInput[]
    NOT?: call_logsScalarWhereWithAggregatesInput | call_logsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"call_logs"> | string
    callSessionId?: StringWithAggregatesFilter<"call_logs"> | string
    status?: StringWithAggregatesFilter<"call_logs"> | string
    duration?: IntNullableWithAggregatesFilter<"call_logs"> | number | null
    timestamp?: DateTimeWithAggregatesFilter<"call_logs"> | Date | string
  }

  export type call_sessionsWhereInput = {
    AND?: call_sessionsWhereInput | call_sessionsWhereInput[]
    OR?: call_sessionsWhereInput[]
    NOT?: call_sessionsWhereInput | call_sessionsWhereInput[]
    id?: StringFilter<"call_sessions"> | string
    customerId?: StringFilter<"call_sessions"> | string
    providerId?: StringFilter<"call_sessions"> | string
    orderId?: StringNullableFilter<"call_sessions"> | string | null
    twilioCallSid?: StringNullableFilter<"call_sessions"> | string | null
    customerPhone?: StringFilter<"call_sessions"> | string
    providerPhone?: StringFilter<"call_sessions"> | string
    status?: StringFilter<"call_sessions"> | string
    duration?: IntNullableFilter<"call_sessions"> | number | null
    startedAt?: DateTimeNullableFilter<"call_sessions"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"call_sessions"> | Date | string | null
    createdAt?: DateTimeFilter<"call_sessions"> | Date | string
    updatedAt?: DateTimeFilter<"call_sessions"> | Date | string
    call_logs?: Call_logsListRelationFilter
    users_call_sessions_customerIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    orders?: XOR<OrdersNullableScalarRelationFilter, ordersWhereInput> | null
    users_call_sessions_providerIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type call_sessionsOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    providerId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    twilioCallSid?: SortOrderInput | SortOrder
    customerPhone?: SortOrder
    providerPhone?: SortOrder
    status?: SortOrder
    duration?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    call_logs?: call_logsOrderByRelationAggregateInput
    users_call_sessions_customerIdTousers?: usersOrderByWithRelationInput
    orders?: ordersOrderByWithRelationInput
    users_call_sessions_providerIdTousers?: usersOrderByWithRelationInput
  }

  export type call_sessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: call_sessionsWhereInput | call_sessionsWhereInput[]
    OR?: call_sessionsWhereInput[]
    NOT?: call_sessionsWhereInput | call_sessionsWhereInput[]
    customerId?: StringFilter<"call_sessions"> | string
    providerId?: StringFilter<"call_sessions"> | string
    orderId?: StringNullableFilter<"call_sessions"> | string | null
    twilioCallSid?: StringNullableFilter<"call_sessions"> | string | null
    customerPhone?: StringFilter<"call_sessions"> | string
    providerPhone?: StringFilter<"call_sessions"> | string
    status?: StringFilter<"call_sessions"> | string
    duration?: IntNullableFilter<"call_sessions"> | number | null
    startedAt?: DateTimeNullableFilter<"call_sessions"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"call_sessions"> | Date | string | null
    createdAt?: DateTimeFilter<"call_sessions"> | Date | string
    updatedAt?: DateTimeFilter<"call_sessions"> | Date | string
    call_logs?: Call_logsListRelationFilter
    users_call_sessions_customerIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    orders?: XOR<OrdersNullableScalarRelationFilter, ordersWhereInput> | null
    users_call_sessions_providerIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type call_sessionsOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    providerId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    twilioCallSid?: SortOrderInput | SortOrder
    customerPhone?: SortOrder
    providerPhone?: SortOrder
    status?: SortOrder
    duration?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: call_sessionsCountOrderByAggregateInput
    _avg?: call_sessionsAvgOrderByAggregateInput
    _max?: call_sessionsMaxOrderByAggregateInput
    _min?: call_sessionsMinOrderByAggregateInput
    _sum?: call_sessionsSumOrderByAggregateInput
  }

  export type call_sessionsScalarWhereWithAggregatesInput = {
    AND?: call_sessionsScalarWhereWithAggregatesInput | call_sessionsScalarWhereWithAggregatesInput[]
    OR?: call_sessionsScalarWhereWithAggregatesInput[]
    NOT?: call_sessionsScalarWhereWithAggregatesInput | call_sessionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"call_sessions"> | string
    customerId?: StringWithAggregatesFilter<"call_sessions"> | string
    providerId?: StringWithAggregatesFilter<"call_sessions"> | string
    orderId?: StringNullableWithAggregatesFilter<"call_sessions"> | string | null
    twilioCallSid?: StringNullableWithAggregatesFilter<"call_sessions"> | string | null
    customerPhone?: StringWithAggregatesFilter<"call_sessions"> | string
    providerPhone?: StringWithAggregatesFilter<"call_sessions"> | string
    status?: StringWithAggregatesFilter<"call_sessions"> | string
    duration?: IntNullableWithAggregatesFilter<"call_sessions"> | number | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"call_sessions"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"call_sessions"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"call_sessions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"call_sessions"> | Date | string
  }

  export type faqsWhereInput = {
    AND?: faqsWhereInput | faqsWhereInput[]
    OR?: faqsWhereInput[]
    NOT?: faqsWhereInput | faqsWhereInput[]
    id?: StringFilter<"faqs"> | string
    question?: StringFilter<"faqs"> | string
    answer?: StringFilter<"faqs"> | string
    category?: StringFilter<"faqs"> | string
    order?: IntFilter<"faqs"> | number
    createdAt?: DateTimeFilter<"faqs"> | Date | string
    updatedAt?: DateTimeFilter<"faqs"> | Date | string
  }

  export type faqsOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type faqsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: faqsWhereInput | faqsWhereInput[]
    OR?: faqsWhereInput[]
    NOT?: faqsWhereInput | faqsWhereInput[]
    question?: StringFilter<"faqs"> | string
    answer?: StringFilter<"faqs"> | string
    category?: StringFilter<"faqs"> | string
    order?: IntFilter<"faqs"> | number
    createdAt?: DateTimeFilter<"faqs"> | Date | string
    updatedAt?: DateTimeFilter<"faqs"> | Date | string
  }, "id">

  export type faqsOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: faqsCountOrderByAggregateInput
    _avg?: faqsAvgOrderByAggregateInput
    _max?: faqsMaxOrderByAggregateInput
    _min?: faqsMinOrderByAggregateInput
    _sum?: faqsSumOrderByAggregateInput
  }

  export type faqsScalarWhereWithAggregatesInput = {
    AND?: faqsScalarWhereWithAggregatesInput | faqsScalarWhereWithAggregatesInput[]
    OR?: faqsScalarWhereWithAggregatesInput[]
    NOT?: faqsScalarWhereWithAggregatesInput | faqsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"faqs"> | string
    question?: StringWithAggregatesFilter<"faqs"> | string
    answer?: StringWithAggregatesFilter<"faqs"> | string
    category?: StringWithAggregatesFilter<"faqs"> | string
    order?: IntWithAggregatesFilter<"faqs"> | number
    createdAt?: DateTimeWithAggregatesFilter<"faqs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"faqs"> | Date | string
  }

  export type messagesWhereInput = {
    AND?: messagesWhereInput | messagesWhereInput[]
    OR?: messagesWhereInput[]
    NOT?: messagesWhereInput | messagesWhereInput[]
    id?: StringFilter<"messages"> | string
    senderId?: StringFilter<"messages"> | string
    receiverId?: StringFilter<"messages"> | string
    content?: StringFilter<"messages"> | string
    orderId?: StringNullableFilter<"messages"> | string | null
    createdAt?: DateTimeFilter<"messages"> | Date | string
    users_messages_receiverIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    users_messages_senderIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type messagesOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    orderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    users_messages_receiverIdTousers?: usersOrderByWithRelationInput
    users_messages_senderIdTousers?: usersOrderByWithRelationInput
  }

  export type messagesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: messagesWhereInput | messagesWhereInput[]
    OR?: messagesWhereInput[]
    NOT?: messagesWhereInput | messagesWhereInput[]
    senderId?: StringFilter<"messages"> | string
    receiverId?: StringFilter<"messages"> | string
    content?: StringFilter<"messages"> | string
    orderId?: StringNullableFilter<"messages"> | string | null
    createdAt?: DateTimeFilter<"messages"> | Date | string
    users_messages_receiverIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    users_messages_senderIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type messagesOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    orderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: messagesCountOrderByAggregateInput
    _max?: messagesMaxOrderByAggregateInput
    _min?: messagesMinOrderByAggregateInput
  }

  export type messagesScalarWhereWithAggregatesInput = {
    AND?: messagesScalarWhereWithAggregatesInput | messagesScalarWhereWithAggregatesInput[]
    OR?: messagesScalarWhereWithAggregatesInput[]
    NOT?: messagesScalarWhereWithAggregatesInput | messagesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"messages"> | string
    senderId?: StringWithAggregatesFilter<"messages"> | string
    receiverId?: StringWithAggregatesFilter<"messages"> | string
    content?: StringWithAggregatesFilter<"messages"> | string
    orderId?: StringNullableWithAggregatesFilter<"messages"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"messages"> | Date | string
  }

  export type notification_preferencesWhereInput = {
    AND?: notification_preferencesWhereInput | notification_preferencesWhereInput[]
    OR?: notification_preferencesWhereInput[]
    NOT?: notification_preferencesWhereInput | notification_preferencesWhereInput[]
    id?: StringFilter<"notification_preferences"> | string
    userId?: StringFilter<"notification_preferences"> | string
    pushEnabled?: BoolFilter<"notification_preferences"> | boolean
    emailEnabled?: BoolFilter<"notification_preferences"> | boolean
    smsEnabled?: BoolFilter<"notification_preferences"> | boolean
    orderUpdates?: BoolFilter<"notification_preferences"> | boolean
    messages?: BoolFilter<"notification_preferences"> | boolean
    promotions?: BoolFilter<"notification_preferences"> | boolean
    systemAlerts?: BoolFilter<"notification_preferences"> | boolean
    createdAt?: DateTimeFilter<"notification_preferences"> | Date | string
    updatedAt?: DateTimeFilter<"notification_preferences"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type notification_preferencesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    pushEnabled?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    orderUpdates?: SortOrder
    messages?: SortOrder
    promotions?: SortOrder
    systemAlerts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type notification_preferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: notification_preferencesWhereInput | notification_preferencesWhereInput[]
    OR?: notification_preferencesWhereInput[]
    NOT?: notification_preferencesWhereInput | notification_preferencesWhereInput[]
    pushEnabled?: BoolFilter<"notification_preferences"> | boolean
    emailEnabled?: BoolFilter<"notification_preferences"> | boolean
    smsEnabled?: BoolFilter<"notification_preferences"> | boolean
    orderUpdates?: BoolFilter<"notification_preferences"> | boolean
    messages?: BoolFilter<"notification_preferences"> | boolean
    promotions?: BoolFilter<"notification_preferences"> | boolean
    systemAlerts?: BoolFilter<"notification_preferences"> | boolean
    createdAt?: DateTimeFilter<"notification_preferences"> | Date | string
    updatedAt?: DateTimeFilter<"notification_preferences"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "userId">

  export type notification_preferencesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    pushEnabled?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    orderUpdates?: SortOrder
    messages?: SortOrder
    promotions?: SortOrder
    systemAlerts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: notification_preferencesCountOrderByAggregateInput
    _max?: notification_preferencesMaxOrderByAggregateInput
    _min?: notification_preferencesMinOrderByAggregateInput
  }

  export type notification_preferencesScalarWhereWithAggregatesInput = {
    AND?: notification_preferencesScalarWhereWithAggregatesInput | notification_preferencesScalarWhereWithAggregatesInput[]
    OR?: notification_preferencesScalarWhereWithAggregatesInput[]
    NOT?: notification_preferencesScalarWhereWithAggregatesInput | notification_preferencesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"notification_preferences"> | string
    userId?: StringWithAggregatesFilter<"notification_preferences"> | string
    pushEnabled?: BoolWithAggregatesFilter<"notification_preferences"> | boolean
    emailEnabled?: BoolWithAggregatesFilter<"notification_preferences"> | boolean
    smsEnabled?: BoolWithAggregatesFilter<"notification_preferences"> | boolean
    orderUpdates?: BoolWithAggregatesFilter<"notification_preferences"> | boolean
    messages?: BoolWithAggregatesFilter<"notification_preferences"> | boolean
    promotions?: BoolWithAggregatesFilter<"notification_preferences"> | boolean
    systemAlerts?: BoolWithAggregatesFilter<"notification_preferences"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"notification_preferences"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"notification_preferences"> | Date | string
  }

  export type notification_tokensWhereInput = {
    AND?: notification_tokensWhereInput | notification_tokensWhereInput[]
    OR?: notification_tokensWhereInput[]
    NOT?: notification_tokensWhereInput | notification_tokensWhereInput[]
    id?: StringFilter<"notification_tokens"> | string
    userId?: StringFilter<"notification_tokens"> | string
    token?: StringFilter<"notification_tokens"> | string
    platform?: StringNullableFilter<"notification_tokens"> | string | null
    createdAt?: DateTimeFilter<"notification_tokens"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type notification_tokensOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    platform?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type notification_tokensWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: notification_tokensWhereInput | notification_tokensWhereInput[]
    OR?: notification_tokensWhereInput[]
    NOT?: notification_tokensWhereInput | notification_tokensWhereInput[]
    userId?: StringFilter<"notification_tokens"> | string
    platform?: StringNullableFilter<"notification_tokens"> | string | null
    createdAt?: DateTimeFilter<"notification_tokens"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "token">

  export type notification_tokensOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    platform?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: notification_tokensCountOrderByAggregateInput
    _max?: notification_tokensMaxOrderByAggregateInput
    _min?: notification_tokensMinOrderByAggregateInput
  }

  export type notification_tokensScalarWhereWithAggregatesInput = {
    AND?: notification_tokensScalarWhereWithAggregatesInput | notification_tokensScalarWhereWithAggregatesInput[]
    OR?: notification_tokensScalarWhereWithAggregatesInput[]
    NOT?: notification_tokensScalarWhereWithAggregatesInput | notification_tokensScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"notification_tokens"> | string
    userId?: StringWithAggregatesFilter<"notification_tokens"> | string
    token?: StringWithAggregatesFilter<"notification_tokens"> | string
    platform?: StringNullableWithAggregatesFilter<"notification_tokens"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"notification_tokens"> | Date | string
  }

  export type notificationsWhereInput = {
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    id?: StringFilter<"notifications"> | string
    userId?: StringFilter<"notifications"> | string
    title?: StringFilter<"notifications"> | string
    body?: StringFilter<"notifications"> | string
    data?: JsonNullableFilter<"notifications">
    type?: StringFilter<"notifications"> | string
    status?: StringFilter<"notifications"> | string
    readAt?: DateTimeNullableFilter<"notifications"> | Date | string | null
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type notificationsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    data?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type notificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    userId?: StringFilter<"notifications"> | string
    title?: StringFilter<"notifications"> | string
    body?: StringFilter<"notifications"> | string
    data?: JsonNullableFilter<"notifications">
    type?: StringFilter<"notifications"> | string
    status?: StringFilter<"notifications"> | string
    readAt?: DateTimeNullableFilter<"notifications"> | Date | string | null
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type notificationsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    data?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: notificationsCountOrderByAggregateInput
    _max?: notificationsMaxOrderByAggregateInput
    _min?: notificationsMinOrderByAggregateInput
  }

  export type notificationsScalarWhereWithAggregatesInput = {
    AND?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    OR?: notificationsScalarWhereWithAggregatesInput[]
    NOT?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"notifications"> | string
    userId?: StringWithAggregatesFilter<"notifications"> | string
    title?: StringWithAggregatesFilter<"notifications"> | string
    body?: StringWithAggregatesFilter<"notifications"> | string
    data?: JsonNullableWithAggregatesFilter<"notifications">
    type?: StringWithAggregatesFilter<"notifications"> | string
    status?: StringWithAggregatesFilter<"notifications"> | string
    readAt?: DateTimeNullableWithAggregatesFilter<"notifications"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"notifications"> | Date | string
  }

  export type ordersWhereInput = {
    AND?: ordersWhereInput | ordersWhereInput[]
    OR?: ordersWhereInput[]
    NOT?: ordersWhereInput | ordersWhereInput[]
    id?: StringFilter<"orders"> | string
    customerId?: StringFilter<"orders"> | string
    providerId?: StringFilter<"orders"> | string
    serviceId?: StringFilter<"orders"> | string
    status?: EnumOrderStatusFilter<"orders"> | $Enums.OrderStatus
    totalAmount?: FloatFilter<"orders"> | number
    commission?: FloatFilter<"orders"> | number
    serviceDate?: DateTimeFilter<"orders"> | Date | string
    address?: StringFilter<"orders"> | string
    notes?: StringNullableFilter<"orders"> | string | null
    cancelledBy?: StringNullableFilter<"orders"> | string | null
    cancelReason?: StringNullableFilter<"orders"> | string | null
    cancelledAt?: DateTimeNullableFilter<"orders"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"orders"> | Date | string | null
    createdAt?: DateTimeFilter<"orders"> | Date | string
    updatedAt?: DateTimeFilter<"orders"> | Date | string
    call_sessions?: Call_sessionsListRelationFilter
    users_orders_customerIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    users_orders_providerIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    services?: XOR<ServicesScalarRelationFilter, servicesWhereInput>
    reviews?: XOR<ReviewsNullableScalarRelationFilter, reviewsWhereInput> | null
    virtual_assignments?: XOR<Virtual_assignmentsNullableScalarRelationFilter, virtual_assignmentsWhereInput> | null
  }

  export type ordersOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    providerId?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    commission?: SortOrder
    serviceDate?: SortOrder
    address?: SortOrder
    notes?: SortOrderInput | SortOrder
    cancelledBy?: SortOrderInput | SortOrder
    cancelReason?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    call_sessions?: call_sessionsOrderByRelationAggregateInput
    users_orders_customerIdTousers?: usersOrderByWithRelationInput
    users_orders_providerIdTousers?: usersOrderByWithRelationInput
    services?: servicesOrderByWithRelationInput
    reviews?: reviewsOrderByWithRelationInput
    virtual_assignments?: virtual_assignmentsOrderByWithRelationInput
  }

  export type ordersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ordersWhereInput | ordersWhereInput[]
    OR?: ordersWhereInput[]
    NOT?: ordersWhereInput | ordersWhereInput[]
    customerId?: StringFilter<"orders"> | string
    providerId?: StringFilter<"orders"> | string
    serviceId?: StringFilter<"orders"> | string
    status?: EnumOrderStatusFilter<"orders"> | $Enums.OrderStatus
    totalAmount?: FloatFilter<"orders"> | number
    commission?: FloatFilter<"orders"> | number
    serviceDate?: DateTimeFilter<"orders"> | Date | string
    address?: StringFilter<"orders"> | string
    notes?: StringNullableFilter<"orders"> | string | null
    cancelledBy?: StringNullableFilter<"orders"> | string | null
    cancelReason?: StringNullableFilter<"orders"> | string | null
    cancelledAt?: DateTimeNullableFilter<"orders"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"orders"> | Date | string | null
    createdAt?: DateTimeFilter<"orders"> | Date | string
    updatedAt?: DateTimeFilter<"orders"> | Date | string
    call_sessions?: Call_sessionsListRelationFilter
    users_orders_customerIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    users_orders_providerIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    services?: XOR<ServicesScalarRelationFilter, servicesWhereInput>
    reviews?: XOR<ReviewsNullableScalarRelationFilter, reviewsWhereInput> | null
    virtual_assignments?: XOR<Virtual_assignmentsNullableScalarRelationFilter, virtual_assignmentsWhereInput> | null
  }, "id">

  export type ordersOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    providerId?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    commission?: SortOrder
    serviceDate?: SortOrder
    address?: SortOrder
    notes?: SortOrderInput | SortOrder
    cancelledBy?: SortOrderInput | SortOrder
    cancelReason?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ordersCountOrderByAggregateInput
    _avg?: ordersAvgOrderByAggregateInput
    _max?: ordersMaxOrderByAggregateInput
    _min?: ordersMinOrderByAggregateInput
    _sum?: ordersSumOrderByAggregateInput
  }

  export type ordersScalarWhereWithAggregatesInput = {
    AND?: ordersScalarWhereWithAggregatesInput | ordersScalarWhereWithAggregatesInput[]
    OR?: ordersScalarWhereWithAggregatesInput[]
    NOT?: ordersScalarWhereWithAggregatesInput | ordersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"orders"> | string
    customerId?: StringWithAggregatesFilter<"orders"> | string
    providerId?: StringWithAggregatesFilter<"orders"> | string
    serviceId?: StringWithAggregatesFilter<"orders"> | string
    status?: EnumOrderStatusWithAggregatesFilter<"orders"> | $Enums.OrderStatus
    totalAmount?: FloatWithAggregatesFilter<"orders"> | number
    commission?: FloatWithAggregatesFilter<"orders"> | number
    serviceDate?: DateTimeWithAggregatesFilter<"orders"> | Date | string
    address?: StringWithAggregatesFilter<"orders"> | string
    notes?: StringNullableWithAggregatesFilter<"orders"> | string | null
    cancelledBy?: StringNullableWithAggregatesFilter<"orders"> | string | null
    cancelReason?: StringNullableWithAggregatesFilter<"orders"> | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"orders"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"orders"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"orders"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"orders"> | Date | string
  }

  export type otpsWhereInput = {
    AND?: otpsWhereInput | otpsWhereInput[]
    OR?: otpsWhereInput[]
    NOT?: otpsWhereInput | otpsWhereInput[]
    id?: StringFilter<"otps"> | string
    userId?: StringFilter<"otps"> | string
    code?: StringFilter<"otps"> | string
    type?: StringFilter<"otps"> | string
    isUsed?: BoolFilter<"otps"> | boolean
    expiresAt?: DateTimeFilter<"otps"> | Date | string
    createdAt?: DateTimeFilter<"otps"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type otpsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    type?: SortOrder
    isUsed?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type otpsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: otpsWhereInput | otpsWhereInput[]
    OR?: otpsWhereInput[]
    NOT?: otpsWhereInput | otpsWhereInput[]
    userId?: StringFilter<"otps"> | string
    code?: StringFilter<"otps"> | string
    type?: StringFilter<"otps"> | string
    isUsed?: BoolFilter<"otps"> | boolean
    expiresAt?: DateTimeFilter<"otps"> | Date | string
    createdAt?: DateTimeFilter<"otps"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type otpsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    type?: SortOrder
    isUsed?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: otpsCountOrderByAggregateInput
    _max?: otpsMaxOrderByAggregateInput
    _min?: otpsMinOrderByAggregateInput
  }

  export type otpsScalarWhereWithAggregatesInput = {
    AND?: otpsScalarWhereWithAggregatesInput | otpsScalarWhereWithAggregatesInput[]
    OR?: otpsScalarWhereWithAggregatesInput[]
    NOT?: otpsScalarWhereWithAggregatesInput | otpsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"otps"> | string
    userId?: StringWithAggregatesFilter<"otps"> | string
    code?: StringWithAggregatesFilter<"otps"> | string
    type?: StringWithAggregatesFilter<"otps"> | string
    isUsed?: BoolWithAggregatesFilter<"otps"> | boolean
    expiresAt?: DateTimeWithAggregatesFilter<"otps"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"otps"> | Date | string
  }

  export type payment_ordersWhereInput = {
    AND?: payment_ordersWhereInput | payment_ordersWhereInput[]
    OR?: payment_ordersWhereInput[]
    NOT?: payment_ordersWhereInput | payment_ordersWhereInput[]
    id?: StringFilter<"payment_orders"> | string
    userId?: StringFilter<"payment_orders"> | string
    orderId?: StringFilter<"payment_orders"> | string
    paymentId?: StringNullableFilter<"payment_orders"> | string | null
    amount?: FloatFilter<"payment_orders"> | number
    currency?: StringFilter<"payment_orders"> | string
    paymentMethod?: StringFilter<"payment_orders"> | string
    status?: StringFilter<"payment_orders"> | string
    type?: StringFilter<"payment_orders"> | string
    signature?: StringNullableFilter<"payment_orders"> | string | null
    metadata?: JsonNullableFilter<"payment_orders">
    createdAt?: DateTimeFilter<"payment_orders"> | Date | string
    updatedAt?: DateTimeFilter<"payment_orders"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type payment_ordersOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    type?: SortOrder
    signature?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type payment_ordersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: payment_ordersWhereInput | payment_ordersWhereInput[]
    OR?: payment_ordersWhereInput[]
    NOT?: payment_ordersWhereInput | payment_ordersWhereInput[]
    userId?: StringFilter<"payment_orders"> | string
    paymentId?: StringNullableFilter<"payment_orders"> | string | null
    amount?: FloatFilter<"payment_orders"> | number
    currency?: StringFilter<"payment_orders"> | string
    paymentMethod?: StringFilter<"payment_orders"> | string
    status?: StringFilter<"payment_orders"> | string
    type?: StringFilter<"payment_orders"> | string
    signature?: StringNullableFilter<"payment_orders"> | string | null
    metadata?: JsonNullableFilter<"payment_orders">
    createdAt?: DateTimeFilter<"payment_orders"> | Date | string
    updatedAt?: DateTimeFilter<"payment_orders"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "orderId">

  export type payment_ordersOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    type?: SortOrder
    signature?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: payment_ordersCountOrderByAggregateInput
    _avg?: payment_ordersAvgOrderByAggregateInput
    _max?: payment_ordersMaxOrderByAggregateInput
    _min?: payment_ordersMinOrderByAggregateInput
    _sum?: payment_ordersSumOrderByAggregateInput
  }

  export type payment_ordersScalarWhereWithAggregatesInput = {
    AND?: payment_ordersScalarWhereWithAggregatesInput | payment_ordersScalarWhereWithAggregatesInput[]
    OR?: payment_ordersScalarWhereWithAggregatesInput[]
    NOT?: payment_ordersScalarWhereWithAggregatesInput | payment_ordersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"payment_orders"> | string
    userId?: StringWithAggregatesFilter<"payment_orders"> | string
    orderId?: StringWithAggregatesFilter<"payment_orders"> | string
    paymentId?: StringNullableWithAggregatesFilter<"payment_orders"> | string | null
    amount?: FloatWithAggregatesFilter<"payment_orders"> | number
    currency?: StringWithAggregatesFilter<"payment_orders"> | string
    paymentMethod?: StringWithAggregatesFilter<"payment_orders"> | string
    status?: StringWithAggregatesFilter<"payment_orders"> | string
    type?: StringWithAggregatesFilter<"payment_orders"> | string
    signature?: StringNullableWithAggregatesFilter<"payment_orders"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"payment_orders">
    createdAt?: DateTimeWithAggregatesFilter<"payment_orders"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"payment_orders"> | Date | string
  }

  export type profilesWhereInput = {
    AND?: profilesWhereInput | profilesWhereInput[]
    OR?: profilesWhereInput[]
    NOT?: profilesWhereInput | profilesWhereInput[]
    id?: StringFilter<"profiles"> | string
    userId?: StringFilter<"profiles"> | string
    firstName?: StringFilter<"profiles"> | string
    lastName?: StringFilter<"profiles"> | string
    avatar?: StringNullableFilter<"profiles"> | string | null
    address?: StringNullableFilter<"profiles"> | string | null
    pincode?: StringNullableFilter<"profiles"> | string | null
    city?: StringNullableFilter<"profiles"> | string | null
    state?: StringNullableFilter<"profiles"> | string | null
    country?: StringFilter<"profiles"> | string
    createdAt?: DateTimeFilter<"profiles"> | Date | string
    updatedAt?: DateTimeFilter<"profiles"> | Date | string
    passwordHash?: StringNullableFilter<"profiles"> | string | null
    googleId?: StringNullableFilter<"profiles"> | string | null
    googleVerified?: BoolFilter<"profiles"> | boolean
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type profilesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatar?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    googleVerified?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type profilesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: profilesWhereInput | profilesWhereInput[]
    OR?: profilesWhereInput[]
    NOT?: profilesWhereInput | profilesWhereInput[]
    firstName?: StringFilter<"profiles"> | string
    lastName?: StringFilter<"profiles"> | string
    avatar?: StringNullableFilter<"profiles"> | string | null
    address?: StringNullableFilter<"profiles"> | string | null
    pincode?: StringNullableFilter<"profiles"> | string | null
    city?: StringNullableFilter<"profiles"> | string | null
    state?: StringNullableFilter<"profiles"> | string | null
    country?: StringFilter<"profiles"> | string
    createdAt?: DateTimeFilter<"profiles"> | Date | string
    updatedAt?: DateTimeFilter<"profiles"> | Date | string
    passwordHash?: StringNullableFilter<"profiles"> | string | null
    googleId?: StringNullableFilter<"profiles"> | string | null
    googleVerified?: BoolFilter<"profiles"> | boolean
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "userId">

  export type profilesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatar?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    googleVerified?: SortOrder
    _count?: profilesCountOrderByAggregateInput
    _max?: profilesMaxOrderByAggregateInput
    _min?: profilesMinOrderByAggregateInput
  }

  export type profilesScalarWhereWithAggregatesInput = {
    AND?: profilesScalarWhereWithAggregatesInput | profilesScalarWhereWithAggregatesInput[]
    OR?: profilesScalarWhereWithAggregatesInput[]
    NOT?: profilesScalarWhereWithAggregatesInput | profilesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"profiles"> | string
    userId?: StringWithAggregatesFilter<"profiles"> | string
    firstName?: StringWithAggregatesFilter<"profiles"> | string
    lastName?: StringWithAggregatesFilter<"profiles"> | string
    avatar?: StringNullableWithAggregatesFilter<"profiles"> | string | null
    address?: StringNullableWithAggregatesFilter<"profiles"> | string | null
    pincode?: StringNullableWithAggregatesFilter<"profiles"> | string | null
    city?: StringNullableWithAggregatesFilter<"profiles"> | string | null
    state?: StringNullableWithAggregatesFilter<"profiles"> | string | null
    country?: StringWithAggregatesFilter<"profiles"> | string
    createdAt?: DateTimeWithAggregatesFilter<"profiles"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"profiles"> | Date | string
    passwordHash?: StringNullableWithAggregatesFilter<"profiles"> | string | null
    googleId?: StringNullableWithAggregatesFilter<"profiles"> | string | null
    googleVerified?: BoolWithAggregatesFilter<"profiles"> | boolean
  }

  export type provider_locationsWhereInput = {
    AND?: provider_locationsWhereInput | provider_locationsWhereInput[]
    OR?: provider_locationsWhereInput[]
    NOT?: provider_locationsWhereInput | provider_locationsWhereInput[]
    id?: StringFilter<"provider_locations"> | string
    providerId?: StringFilter<"provider_locations"> | string
    lat?: FloatFilter<"provider_locations"> | number
    lng?: FloatFilter<"provider_locations"> | number
    address?: StringNullableFilter<"provider_locations"> | string | null
    zoneId?: StringNullableFilter<"provider_locations"> | string | null
    createdAt?: DateTimeFilter<"provider_locations"> | Date | string
    updatedAt?: DateTimeFilter<"provider_locations"> | Date | string
    providers?: XOR<ProvidersScalarRelationFilter, providersWhereInput>
    zones?: XOR<ZonesNullableScalarRelationFilter, zonesWhereInput> | null
  }

  export type provider_locationsOrderByWithRelationInput = {
    id?: SortOrder
    providerId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    address?: SortOrderInput | SortOrder
    zoneId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    providers?: providersOrderByWithRelationInput
    zones?: zonesOrderByWithRelationInput
  }

  export type provider_locationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: provider_locationsWhereInput | provider_locationsWhereInput[]
    OR?: provider_locationsWhereInput[]
    NOT?: provider_locationsWhereInput | provider_locationsWhereInput[]
    providerId?: StringFilter<"provider_locations"> | string
    lat?: FloatFilter<"provider_locations"> | number
    lng?: FloatFilter<"provider_locations"> | number
    address?: StringNullableFilter<"provider_locations"> | string | null
    zoneId?: StringNullableFilter<"provider_locations"> | string | null
    createdAt?: DateTimeFilter<"provider_locations"> | Date | string
    updatedAt?: DateTimeFilter<"provider_locations"> | Date | string
    providers?: XOR<ProvidersScalarRelationFilter, providersWhereInput>
    zones?: XOR<ZonesNullableScalarRelationFilter, zonesWhereInput> | null
  }, "id">

  export type provider_locationsOrderByWithAggregationInput = {
    id?: SortOrder
    providerId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    address?: SortOrderInput | SortOrder
    zoneId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: provider_locationsCountOrderByAggregateInput
    _avg?: provider_locationsAvgOrderByAggregateInput
    _max?: provider_locationsMaxOrderByAggregateInput
    _min?: provider_locationsMinOrderByAggregateInput
    _sum?: provider_locationsSumOrderByAggregateInput
  }

  export type provider_locationsScalarWhereWithAggregatesInput = {
    AND?: provider_locationsScalarWhereWithAggregatesInput | provider_locationsScalarWhereWithAggregatesInput[]
    OR?: provider_locationsScalarWhereWithAggregatesInput[]
    NOT?: provider_locationsScalarWhereWithAggregatesInput | provider_locationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"provider_locations"> | string
    providerId?: StringWithAggregatesFilter<"provider_locations"> | string
    lat?: FloatWithAggregatesFilter<"provider_locations"> | number
    lng?: FloatWithAggregatesFilter<"provider_locations"> | number
    address?: StringNullableWithAggregatesFilter<"provider_locations"> | string | null
    zoneId?: StringNullableWithAggregatesFilter<"provider_locations"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"provider_locations"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"provider_locations"> | Date | string
  }

  export type providersWhereInput = {
    AND?: providersWhereInput | providersWhereInput[]
    OR?: providersWhereInput[]
    NOT?: providersWhereInput | providersWhereInput[]
    id?: StringFilter<"providers"> | string
    userId?: StringFilter<"providers"> | string
    businessName?: StringFilter<"providers"> | string
    providerType?: EnumProviderTypeFilter<"providers"> | $Enums.ProviderType
    category?: StringFilter<"providers"> | string
    area?: StringFilter<"providers"> | string
    address?: StringFilter<"providers"> | string
    panNumber?: StringFilter<"providers"> | string
    aadhaarNumber?: StringFilter<"providers"> | string
    gstNumber?: StringNullableFilter<"providers"> | string | null
    bankAccount?: StringNullableFilter<"providers"> | string | null
    upiId?: StringNullableFilter<"providers"> | string | null
    isVerified?: BoolFilter<"providers"> | boolean
    isActive?: BoolFilter<"providers"> | boolean
    rating?: FloatFilter<"providers"> | number
    totalOrders?: IntFilter<"providers"> | number
    isOnline?: BoolFilter<"providers"> | boolean
    createdAt?: DateTimeFilter<"providers"> | Date | string
    updatedAt?: DateTimeFilter<"providers"> | Date | string
    provider_locations?: Provider_locationsListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    reviews?: ReviewsListRelationFilter
    services?: ServicesListRelationFilter
  }

  export type providersOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    businessName?: SortOrder
    providerType?: SortOrder
    category?: SortOrder
    area?: SortOrder
    address?: SortOrder
    panNumber?: SortOrder
    aadhaarNumber?: SortOrder
    gstNumber?: SortOrderInput | SortOrder
    bankAccount?: SortOrderInput | SortOrder
    upiId?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    rating?: SortOrder
    totalOrders?: SortOrder
    isOnline?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider_locations?: provider_locationsOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
    reviews?: reviewsOrderByRelationAggregateInput
    services?: servicesOrderByRelationAggregateInput
  }

  export type providersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: providersWhereInput | providersWhereInput[]
    OR?: providersWhereInput[]
    NOT?: providersWhereInput | providersWhereInput[]
    businessName?: StringFilter<"providers"> | string
    providerType?: EnumProviderTypeFilter<"providers"> | $Enums.ProviderType
    category?: StringFilter<"providers"> | string
    area?: StringFilter<"providers"> | string
    address?: StringFilter<"providers"> | string
    panNumber?: StringFilter<"providers"> | string
    aadhaarNumber?: StringFilter<"providers"> | string
    gstNumber?: StringNullableFilter<"providers"> | string | null
    bankAccount?: StringNullableFilter<"providers"> | string | null
    upiId?: StringNullableFilter<"providers"> | string | null
    isVerified?: BoolFilter<"providers"> | boolean
    isActive?: BoolFilter<"providers"> | boolean
    rating?: FloatFilter<"providers"> | number
    totalOrders?: IntFilter<"providers"> | number
    isOnline?: BoolFilter<"providers"> | boolean
    createdAt?: DateTimeFilter<"providers"> | Date | string
    updatedAt?: DateTimeFilter<"providers"> | Date | string
    provider_locations?: Provider_locationsListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    reviews?: ReviewsListRelationFilter
    services?: ServicesListRelationFilter
  }, "id" | "userId">

  export type providersOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    businessName?: SortOrder
    providerType?: SortOrder
    category?: SortOrder
    area?: SortOrder
    address?: SortOrder
    panNumber?: SortOrder
    aadhaarNumber?: SortOrder
    gstNumber?: SortOrderInput | SortOrder
    bankAccount?: SortOrderInput | SortOrder
    upiId?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    rating?: SortOrder
    totalOrders?: SortOrder
    isOnline?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: providersCountOrderByAggregateInput
    _avg?: providersAvgOrderByAggregateInput
    _max?: providersMaxOrderByAggregateInput
    _min?: providersMinOrderByAggregateInput
    _sum?: providersSumOrderByAggregateInput
  }

  export type providersScalarWhereWithAggregatesInput = {
    AND?: providersScalarWhereWithAggregatesInput | providersScalarWhereWithAggregatesInput[]
    OR?: providersScalarWhereWithAggregatesInput[]
    NOT?: providersScalarWhereWithAggregatesInput | providersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"providers"> | string
    userId?: StringWithAggregatesFilter<"providers"> | string
    businessName?: StringWithAggregatesFilter<"providers"> | string
    providerType?: EnumProviderTypeWithAggregatesFilter<"providers"> | $Enums.ProviderType
    category?: StringWithAggregatesFilter<"providers"> | string
    area?: StringWithAggregatesFilter<"providers"> | string
    address?: StringWithAggregatesFilter<"providers"> | string
    panNumber?: StringWithAggregatesFilter<"providers"> | string
    aadhaarNumber?: StringWithAggregatesFilter<"providers"> | string
    gstNumber?: StringNullableWithAggregatesFilter<"providers"> | string | null
    bankAccount?: StringNullableWithAggregatesFilter<"providers"> | string | null
    upiId?: StringNullableWithAggregatesFilter<"providers"> | string | null
    isVerified?: BoolWithAggregatesFilter<"providers"> | boolean
    isActive?: BoolWithAggregatesFilter<"providers"> | boolean
    rating?: FloatWithAggregatesFilter<"providers"> | number
    totalOrders?: IntWithAggregatesFilter<"providers"> | number
    isOnline?: BoolWithAggregatesFilter<"providers"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"providers"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"providers"> | Date | string
  }

  export type report_schedulesWhereInput = {
    AND?: report_schedulesWhereInput | report_schedulesWhereInput[]
    OR?: report_schedulesWhereInput[]
    NOT?: report_schedulesWhereInput | report_schedulesWhereInput[]
    id?: StringFilter<"report_schedules"> | string
    adminId?: StringFilter<"report_schedules"> | string
    reportType?: StringFilter<"report_schedules"> | string
    frequency?: StringFilter<"report_schedules"> | string
    email?: StringFilter<"report_schedules"> | string
    isActive?: BoolFilter<"report_schedules"> | boolean
    createdAt?: DateTimeFilter<"report_schedules"> | Date | string
    updatedAt?: DateTimeFilter<"report_schedules"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type report_schedulesOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    reportType?: SortOrder
    frequency?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type report_schedulesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: report_schedulesWhereInput | report_schedulesWhereInput[]
    OR?: report_schedulesWhereInput[]
    NOT?: report_schedulesWhereInput | report_schedulesWhereInput[]
    adminId?: StringFilter<"report_schedules"> | string
    reportType?: StringFilter<"report_schedules"> | string
    frequency?: StringFilter<"report_schedules"> | string
    email?: StringFilter<"report_schedules"> | string
    isActive?: BoolFilter<"report_schedules"> | boolean
    createdAt?: DateTimeFilter<"report_schedules"> | Date | string
    updatedAt?: DateTimeFilter<"report_schedules"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type report_schedulesOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    reportType?: SortOrder
    frequency?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: report_schedulesCountOrderByAggregateInput
    _max?: report_schedulesMaxOrderByAggregateInput
    _min?: report_schedulesMinOrderByAggregateInput
  }

  export type report_schedulesScalarWhereWithAggregatesInput = {
    AND?: report_schedulesScalarWhereWithAggregatesInput | report_schedulesScalarWhereWithAggregatesInput[]
    OR?: report_schedulesScalarWhereWithAggregatesInput[]
    NOT?: report_schedulesScalarWhereWithAggregatesInput | report_schedulesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"report_schedules"> | string
    adminId?: StringWithAggregatesFilter<"report_schedules"> | string
    reportType?: StringWithAggregatesFilter<"report_schedules"> | string
    frequency?: StringWithAggregatesFilter<"report_schedules"> | string
    email?: StringWithAggregatesFilter<"report_schedules"> | string
    isActive?: BoolWithAggregatesFilter<"report_schedules"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"report_schedules"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"report_schedules"> | Date | string
  }

  export type reviewsWhereInput = {
    AND?: reviewsWhereInput | reviewsWhereInput[]
    OR?: reviewsWhereInput[]
    NOT?: reviewsWhereInput | reviewsWhereInput[]
    id?: StringFilter<"reviews"> | string
    orderId?: StringFilter<"reviews"> | string
    reviewerId?: StringFilter<"reviews"> | string
    revieweeId?: StringFilter<"reviews"> | string
    providerId?: StringNullableFilter<"reviews"> | string | null
    rating?: IntFilter<"reviews"> | number
    comment?: StringNullableFilter<"reviews"> | string | null
    createdAt?: DateTimeFilter<"reviews"> | Date | string
    orders?: XOR<OrdersScalarRelationFilter, ordersWhereInput>
    providers?: XOR<ProvidersNullableScalarRelationFilter, providersWhereInput> | null
    users_reviews_revieweeIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    users_reviews_reviewerIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type reviewsOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    reviewerId?: SortOrder
    revieweeId?: SortOrder
    providerId?: SortOrderInput | SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    orders?: ordersOrderByWithRelationInput
    providers?: providersOrderByWithRelationInput
    users_reviews_revieweeIdTousers?: usersOrderByWithRelationInput
    users_reviews_reviewerIdTousers?: usersOrderByWithRelationInput
  }

  export type reviewsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: reviewsWhereInput | reviewsWhereInput[]
    OR?: reviewsWhereInput[]
    NOT?: reviewsWhereInput | reviewsWhereInput[]
    reviewerId?: StringFilter<"reviews"> | string
    revieweeId?: StringFilter<"reviews"> | string
    providerId?: StringNullableFilter<"reviews"> | string | null
    rating?: IntFilter<"reviews"> | number
    comment?: StringNullableFilter<"reviews"> | string | null
    createdAt?: DateTimeFilter<"reviews"> | Date | string
    orders?: XOR<OrdersScalarRelationFilter, ordersWhereInput>
    providers?: XOR<ProvidersNullableScalarRelationFilter, providersWhereInput> | null
    users_reviews_revieweeIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    users_reviews_reviewerIdTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "orderId">

  export type reviewsOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    reviewerId?: SortOrder
    revieweeId?: SortOrder
    providerId?: SortOrderInput | SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: reviewsCountOrderByAggregateInput
    _avg?: reviewsAvgOrderByAggregateInput
    _max?: reviewsMaxOrderByAggregateInput
    _min?: reviewsMinOrderByAggregateInput
    _sum?: reviewsSumOrderByAggregateInput
  }

  export type reviewsScalarWhereWithAggregatesInput = {
    AND?: reviewsScalarWhereWithAggregatesInput | reviewsScalarWhereWithAggregatesInput[]
    OR?: reviewsScalarWhereWithAggregatesInput[]
    NOT?: reviewsScalarWhereWithAggregatesInput | reviewsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"reviews"> | string
    orderId?: StringWithAggregatesFilter<"reviews"> | string
    reviewerId?: StringWithAggregatesFilter<"reviews"> | string
    revieweeId?: StringWithAggregatesFilter<"reviews"> | string
    providerId?: StringNullableWithAggregatesFilter<"reviews"> | string | null
    rating?: IntWithAggregatesFilter<"reviews"> | number
    comment?: StringNullableWithAggregatesFilter<"reviews"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"reviews"> | Date | string
  }

  export type servicesWhereInput = {
    AND?: servicesWhereInput | servicesWhereInput[]
    OR?: servicesWhereInput[]
    NOT?: servicesWhereInput | servicesWhereInput[]
    id?: StringFilter<"services"> | string
    providerId?: StringFilter<"services"> | string
    name?: StringFilter<"services"> | string
    description?: StringFilter<"services"> | string
    category?: StringFilter<"services"> | string
    price?: FloatFilter<"services"> | number
    basePrice?: FloatNullableFilter<"services"> | number | null
    offerPercent?: IntNullableFilter<"services"> | number | null
    estimatedTime?: IntNullableFilter<"services"> | number | null
    warrantyMonths?: IntNullableFilter<"services"> | number | null
    duration?: IntFilter<"services"> | number
    status?: StringFilter<"services"> | string
    isActive?: BoolFilter<"services"> | boolean
    rejectionReason?: StringNullableFilter<"services"> | string | null
    createdAt?: DateTimeFilter<"services"> | Date | string
    updatedAt?: DateTimeFilter<"services"> | Date | string
    orders?: OrdersListRelationFilter
    providers?: XOR<ProvidersScalarRelationFilter, providersWhereInput>
  }

  export type servicesOrderByWithRelationInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    price?: SortOrder
    basePrice?: SortOrderInput | SortOrder
    offerPercent?: SortOrderInput | SortOrder
    estimatedTime?: SortOrderInput | SortOrder
    warrantyMonths?: SortOrderInput | SortOrder
    duration?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orders?: ordersOrderByRelationAggregateInput
    providers?: providersOrderByWithRelationInput
  }

  export type servicesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: servicesWhereInput | servicesWhereInput[]
    OR?: servicesWhereInput[]
    NOT?: servicesWhereInput | servicesWhereInput[]
    providerId?: StringFilter<"services"> | string
    name?: StringFilter<"services"> | string
    description?: StringFilter<"services"> | string
    category?: StringFilter<"services"> | string
    price?: FloatFilter<"services"> | number
    basePrice?: FloatNullableFilter<"services"> | number | null
    offerPercent?: IntNullableFilter<"services"> | number | null
    estimatedTime?: IntNullableFilter<"services"> | number | null
    warrantyMonths?: IntNullableFilter<"services"> | number | null
    duration?: IntFilter<"services"> | number
    status?: StringFilter<"services"> | string
    isActive?: BoolFilter<"services"> | boolean
    rejectionReason?: StringNullableFilter<"services"> | string | null
    createdAt?: DateTimeFilter<"services"> | Date | string
    updatedAt?: DateTimeFilter<"services"> | Date | string
    orders?: OrdersListRelationFilter
    providers?: XOR<ProvidersScalarRelationFilter, providersWhereInput>
  }, "id">

  export type servicesOrderByWithAggregationInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    price?: SortOrder
    basePrice?: SortOrderInput | SortOrder
    offerPercent?: SortOrderInput | SortOrder
    estimatedTime?: SortOrderInput | SortOrder
    warrantyMonths?: SortOrderInput | SortOrder
    duration?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: servicesCountOrderByAggregateInput
    _avg?: servicesAvgOrderByAggregateInput
    _max?: servicesMaxOrderByAggregateInput
    _min?: servicesMinOrderByAggregateInput
    _sum?: servicesSumOrderByAggregateInput
  }

  export type servicesScalarWhereWithAggregatesInput = {
    AND?: servicesScalarWhereWithAggregatesInput | servicesScalarWhereWithAggregatesInput[]
    OR?: servicesScalarWhereWithAggregatesInput[]
    NOT?: servicesScalarWhereWithAggregatesInput | servicesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"services"> | string
    providerId?: StringWithAggregatesFilter<"services"> | string
    name?: StringWithAggregatesFilter<"services"> | string
    description?: StringWithAggregatesFilter<"services"> | string
    category?: StringWithAggregatesFilter<"services"> | string
    price?: FloatWithAggregatesFilter<"services"> | number
    basePrice?: FloatNullableWithAggregatesFilter<"services"> | number | null
    offerPercent?: IntNullableWithAggregatesFilter<"services"> | number | null
    estimatedTime?: IntNullableWithAggregatesFilter<"services"> | number | null
    warrantyMonths?: IntNullableWithAggregatesFilter<"services"> | number | null
    duration?: IntWithAggregatesFilter<"services"> | number
    status?: StringWithAggregatesFilter<"services"> | string
    isActive?: BoolWithAggregatesFilter<"services"> | boolean
    rejectionReason?: StringNullableWithAggregatesFilter<"services"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"services"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"services"> | Date | string
  }

  export type ticketsWhereInput = {
    AND?: ticketsWhereInput | ticketsWhereInput[]
    OR?: ticketsWhereInput[]
    NOT?: ticketsWhereInput | ticketsWhereInput[]
    id?: StringFilter<"tickets"> | string
    userId?: StringFilter<"tickets"> | string
    subject?: StringFilter<"tickets"> | string
    description?: StringFilter<"tickets"> | string
    status?: StringFilter<"tickets"> | string
    priority?: StringFilter<"tickets"> | string
    createdAt?: DateTimeFilter<"tickets"> | Date | string
    updatedAt?: DateTimeFilter<"tickets"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type ticketsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type ticketsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ticketsWhereInput | ticketsWhereInput[]
    OR?: ticketsWhereInput[]
    NOT?: ticketsWhereInput | ticketsWhereInput[]
    userId?: StringFilter<"tickets"> | string
    subject?: StringFilter<"tickets"> | string
    description?: StringFilter<"tickets"> | string
    status?: StringFilter<"tickets"> | string
    priority?: StringFilter<"tickets"> | string
    createdAt?: DateTimeFilter<"tickets"> | Date | string
    updatedAt?: DateTimeFilter<"tickets"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type ticketsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ticketsCountOrderByAggregateInput
    _max?: ticketsMaxOrderByAggregateInput
    _min?: ticketsMinOrderByAggregateInput
  }

  export type ticketsScalarWhereWithAggregatesInput = {
    AND?: ticketsScalarWhereWithAggregatesInput | ticketsScalarWhereWithAggregatesInput[]
    OR?: ticketsScalarWhereWithAggregatesInput[]
    NOT?: ticketsScalarWhereWithAggregatesInput | ticketsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tickets"> | string
    userId?: StringWithAggregatesFilter<"tickets"> | string
    subject?: StringWithAggregatesFilter<"tickets"> | string
    description?: StringWithAggregatesFilter<"tickets"> | string
    status?: StringWithAggregatesFilter<"tickets"> | string
    priority?: StringWithAggregatesFilter<"tickets"> | string
    createdAt?: DateTimeWithAggregatesFilter<"tickets"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"tickets"> | Date | string
  }

  export type transactionsWhereInput = {
    AND?: transactionsWhereInput | transactionsWhereInput[]
    OR?: transactionsWhereInput[]
    NOT?: transactionsWhereInput | transactionsWhereInput[]
    id?: StringFilter<"transactions"> | string
    walletId?: StringFilter<"transactions"> | string
    amount?: FloatFilter<"transactions"> | number
    type?: EnumTransactionTypeFilter<"transactions"> | $Enums.TransactionType
    description?: StringFilter<"transactions"> | string
    paymentMethod?: EnumPaymentMethodNullableFilter<"transactions"> | $Enums.PaymentMethod | null
    orderId?: StringNullableFilter<"transactions"> | string | null
    createdAt?: DateTimeFilter<"transactions"> | Date | string
    wallets?: XOR<WalletsScalarRelationFilter, walletsWhereInput>
  }

  export type transactionsOrderByWithRelationInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    wallets?: walletsOrderByWithRelationInput
  }

  export type transactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: transactionsWhereInput | transactionsWhereInput[]
    OR?: transactionsWhereInput[]
    NOT?: transactionsWhereInput | transactionsWhereInput[]
    walletId?: StringFilter<"transactions"> | string
    amount?: FloatFilter<"transactions"> | number
    type?: EnumTransactionTypeFilter<"transactions"> | $Enums.TransactionType
    description?: StringFilter<"transactions"> | string
    paymentMethod?: EnumPaymentMethodNullableFilter<"transactions"> | $Enums.PaymentMethod | null
    orderId?: StringNullableFilter<"transactions"> | string | null
    createdAt?: DateTimeFilter<"transactions"> | Date | string
    wallets?: XOR<WalletsScalarRelationFilter, walletsWhereInput>
  }, "id">

  export type transactionsOrderByWithAggregationInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: transactionsCountOrderByAggregateInput
    _avg?: transactionsAvgOrderByAggregateInput
    _max?: transactionsMaxOrderByAggregateInput
    _min?: transactionsMinOrderByAggregateInput
    _sum?: transactionsSumOrderByAggregateInput
  }

  export type transactionsScalarWhereWithAggregatesInput = {
    AND?: transactionsScalarWhereWithAggregatesInput | transactionsScalarWhereWithAggregatesInput[]
    OR?: transactionsScalarWhereWithAggregatesInput[]
    NOT?: transactionsScalarWhereWithAggregatesInput | transactionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"transactions"> | string
    walletId?: StringWithAggregatesFilter<"transactions"> | string
    amount?: FloatWithAggregatesFilter<"transactions"> | number
    type?: EnumTransactionTypeWithAggregatesFilter<"transactions"> | $Enums.TransactionType
    description?: StringWithAggregatesFilter<"transactions"> | string
    paymentMethod?: EnumPaymentMethodNullableWithAggregatesFilter<"transactions"> | $Enums.PaymentMethod | null
    orderId?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"transactions"> | Date | string
  }

  export type user_payment_methodsWhereInput = {
    AND?: user_payment_methodsWhereInput | user_payment_methodsWhereInput[]
    OR?: user_payment_methodsWhereInput[]
    NOT?: user_payment_methodsWhereInput | user_payment_methodsWhereInput[]
    id?: StringFilter<"user_payment_methods"> | string
    userId?: StringFilter<"user_payment_methods"> | string
    type?: StringFilter<"user_payment_methods"> | string
    provider?: StringNullableFilter<"user_payment_methods"> | string | null
    upiId?: StringNullableFilter<"user_payment_methods"> | string | null
    cardNumber?: StringNullableFilter<"user_payment_methods"> | string | null
    cardName?: StringNullableFilter<"user_payment_methods"> | string | null
    expiryMonth?: StringNullableFilter<"user_payment_methods"> | string | null
    expiryYear?: StringNullableFilter<"user_payment_methods"> | string | null
    last4?: StringNullableFilter<"user_payment_methods"> | string | null
    isDefault?: BoolFilter<"user_payment_methods"> | boolean
    isActive?: BoolFilter<"user_payment_methods"> | boolean
    createdAt?: DateTimeFilter<"user_payment_methods"> | Date | string
    updatedAt?: DateTimeFilter<"user_payment_methods"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type user_payment_methodsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrderInput | SortOrder
    upiId?: SortOrderInput | SortOrder
    cardNumber?: SortOrderInput | SortOrder
    cardName?: SortOrderInput | SortOrder
    expiryMonth?: SortOrderInput | SortOrder
    expiryYear?: SortOrderInput | SortOrder
    last4?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type user_payment_methodsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: user_payment_methodsWhereInput | user_payment_methodsWhereInput[]
    OR?: user_payment_methodsWhereInput[]
    NOT?: user_payment_methodsWhereInput | user_payment_methodsWhereInput[]
    userId?: StringFilter<"user_payment_methods"> | string
    type?: StringFilter<"user_payment_methods"> | string
    provider?: StringNullableFilter<"user_payment_methods"> | string | null
    upiId?: StringNullableFilter<"user_payment_methods"> | string | null
    cardNumber?: StringNullableFilter<"user_payment_methods"> | string | null
    cardName?: StringNullableFilter<"user_payment_methods"> | string | null
    expiryMonth?: StringNullableFilter<"user_payment_methods"> | string | null
    expiryYear?: StringNullableFilter<"user_payment_methods"> | string | null
    last4?: StringNullableFilter<"user_payment_methods"> | string | null
    isDefault?: BoolFilter<"user_payment_methods"> | boolean
    isActive?: BoolFilter<"user_payment_methods"> | boolean
    createdAt?: DateTimeFilter<"user_payment_methods"> | Date | string
    updatedAt?: DateTimeFilter<"user_payment_methods"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type user_payment_methodsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrderInput | SortOrder
    upiId?: SortOrderInput | SortOrder
    cardNumber?: SortOrderInput | SortOrder
    cardName?: SortOrderInput | SortOrder
    expiryMonth?: SortOrderInput | SortOrder
    expiryYear?: SortOrderInput | SortOrder
    last4?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: user_payment_methodsCountOrderByAggregateInput
    _max?: user_payment_methodsMaxOrderByAggregateInput
    _min?: user_payment_methodsMinOrderByAggregateInput
  }

  export type user_payment_methodsScalarWhereWithAggregatesInput = {
    AND?: user_payment_methodsScalarWhereWithAggregatesInput | user_payment_methodsScalarWhereWithAggregatesInput[]
    OR?: user_payment_methodsScalarWhereWithAggregatesInput[]
    NOT?: user_payment_methodsScalarWhereWithAggregatesInput | user_payment_methodsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user_payment_methods"> | string
    userId?: StringWithAggregatesFilter<"user_payment_methods"> | string
    type?: StringWithAggregatesFilter<"user_payment_methods"> | string
    provider?: StringNullableWithAggregatesFilter<"user_payment_methods"> | string | null
    upiId?: StringNullableWithAggregatesFilter<"user_payment_methods"> | string | null
    cardNumber?: StringNullableWithAggregatesFilter<"user_payment_methods"> | string | null
    cardName?: StringNullableWithAggregatesFilter<"user_payment_methods"> | string | null
    expiryMonth?: StringNullableWithAggregatesFilter<"user_payment_methods"> | string | null
    expiryYear?: StringNullableWithAggregatesFilter<"user_payment_methods"> | string | null
    last4?: StringNullableWithAggregatesFilter<"user_payment_methods"> | string | null
    isDefault?: BoolWithAggregatesFilter<"user_payment_methods"> | boolean
    isActive?: BoolWithAggregatesFilter<"user_payment_methods"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"user_payment_methods"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"user_payment_methods"> | Date | string
  }

  export type user_verificationsWhereInput = {
    AND?: user_verificationsWhereInput | user_verificationsWhereInput[]
    OR?: user_verificationsWhereInput[]
    NOT?: user_verificationsWhereInput | user_verificationsWhereInput[]
    id?: StringFilter<"user_verifications"> | string
    userId?: StringFilter<"user_verifications"> | string
    idType?: StringFilter<"user_verifications"> | string
    idNumber?: StringFilter<"user_verifications"> | string
    idFrontImage?: StringFilter<"user_verifications"> | string
    idBackImage?: StringNullableFilter<"user_verifications"> | string | null
    addressProofType?: StringFilter<"user_verifications"> | string
    addressProofNumber?: StringFilter<"user_verifications"> | string
    addressProofImage?: StringFilter<"user_verifications"> | string
    verificationStatus?: StringFilter<"user_verifications"> | string
    verifiedAt?: DateTimeNullableFilter<"user_verifications"> | Date | string | null
    verifiedBy?: StringNullableFilter<"user_verifications"> | string | null
    rejectionReason?: StringNullableFilter<"user_verifications"> | string | null
    createdAt?: DateTimeFilter<"user_verifications"> | Date | string
    updatedAt?: DateTimeFilter<"user_verifications"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type user_verificationsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    idType?: SortOrder
    idNumber?: SortOrder
    idFrontImage?: SortOrder
    idBackImage?: SortOrderInput | SortOrder
    addressProofType?: SortOrder
    addressProofNumber?: SortOrder
    addressProofImage?: SortOrder
    verificationStatus?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type user_verificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: user_verificationsWhereInput | user_verificationsWhereInput[]
    OR?: user_verificationsWhereInput[]
    NOT?: user_verificationsWhereInput | user_verificationsWhereInput[]
    idType?: StringFilter<"user_verifications"> | string
    idNumber?: StringFilter<"user_verifications"> | string
    idFrontImage?: StringFilter<"user_verifications"> | string
    idBackImage?: StringNullableFilter<"user_verifications"> | string | null
    addressProofType?: StringFilter<"user_verifications"> | string
    addressProofNumber?: StringFilter<"user_verifications"> | string
    addressProofImage?: StringFilter<"user_verifications"> | string
    verificationStatus?: StringFilter<"user_verifications"> | string
    verifiedAt?: DateTimeNullableFilter<"user_verifications"> | Date | string | null
    verifiedBy?: StringNullableFilter<"user_verifications"> | string | null
    rejectionReason?: StringNullableFilter<"user_verifications"> | string | null
    createdAt?: DateTimeFilter<"user_verifications"> | Date | string
    updatedAt?: DateTimeFilter<"user_verifications"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "userId">

  export type user_verificationsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    idType?: SortOrder
    idNumber?: SortOrder
    idFrontImage?: SortOrder
    idBackImage?: SortOrderInput | SortOrder
    addressProofType?: SortOrder
    addressProofNumber?: SortOrder
    addressProofImage?: SortOrder
    verificationStatus?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: user_verificationsCountOrderByAggregateInput
    _max?: user_verificationsMaxOrderByAggregateInput
    _min?: user_verificationsMinOrderByAggregateInput
  }

  export type user_verificationsScalarWhereWithAggregatesInput = {
    AND?: user_verificationsScalarWhereWithAggregatesInput | user_verificationsScalarWhereWithAggregatesInput[]
    OR?: user_verificationsScalarWhereWithAggregatesInput[]
    NOT?: user_verificationsScalarWhereWithAggregatesInput | user_verificationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user_verifications"> | string
    userId?: StringWithAggregatesFilter<"user_verifications"> | string
    idType?: StringWithAggregatesFilter<"user_verifications"> | string
    idNumber?: StringWithAggregatesFilter<"user_verifications"> | string
    idFrontImage?: StringWithAggregatesFilter<"user_verifications"> | string
    idBackImage?: StringNullableWithAggregatesFilter<"user_verifications"> | string | null
    addressProofType?: StringWithAggregatesFilter<"user_verifications"> | string
    addressProofNumber?: StringWithAggregatesFilter<"user_verifications"> | string
    addressProofImage?: StringWithAggregatesFilter<"user_verifications"> | string
    verificationStatus?: StringWithAggregatesFilter<"user_verifications"> | string
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"user_verifications"> | Date | string | null
    verifiedBy?: StringNullableWithAggregatesFilter<"user_verifications"> | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"user_verifications"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"user_verifications"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"user_verifications"> | Date | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: StringFilter<"users"> | string
    email?: StringNullableFilter<"users"> | string | null
    phone?: StringNullableFilter<"users"> | string | null
    userType?: EnumUserTypeFilter<"users"> | $Enums.UserType
    isVerified?: BoolFilter<"users"> | boolean
    isActive?: BoolFilter<"users"> | boolean
    isBlocked?: BoolFilter<"users"> | boolean
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    cancellationsCount?: IntFilter<"users"> | number
    isSuspect?: BoolFilter<"users"> | boolean
    admin_actions?: Admin_actionsListRelationFilter
    call_sessions_call_sessions_customerIdTousers?: Call_sessionsListRelationFilter
    call_sessions_call_sessions_providerIdTousers?: Call_sessionsListRelationFilter
    messages_messages_receiverIdTousers?: MessagesListRelationFilter
    messages_messages_senderIdTousers?: MessagesListRelationFilter
    notification_preferences?: XOR<Notification_preferencesNullableScalarRelationFilter, notification_preferencesWhereInput> | null
    notification_tokens?: Notification_tokensListRelationFilter
    notifications?: NotificationsListRelationFilter
    orders_orders_customerIdTousers?: OrdersListRelationFilter
    orders_orders_providerIdTousers?: OrdersListRelationFilter
    otps?: OtpsListRelationFilter
    payment_orders?: Payment_ordersListRelationFilter
    profiles?: XOR<ProfilesNullableScalarRelationFilter, profilesWhereInput> | null
    providers?: XOR<ProvidersNullableScalarRelationFilter, providersWhereInput> | null
    report_schedules?: Report_schedulesListRelationFilter
    reviews_reviews_revieweeIdTousers?: ReviewsListRelationFilter
    reviews_reviews_reviewerIdTousers?: ReviewsListRelationFilter
    tickets?: TicketsListRelationFilter
    user_payment_methods?: User_payment_methodsListRelationFilter
    user_verifications?: XOR<User_verificationsNullableScalarRelationFilter, user_verificationsWhereInput> | null
    wallets?: XOR<WalletsNullableScalarRelationFilter, walletsWhereInput> | null
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    userType?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cancellationsCount?: SortOrder
    isSuspect?: SortOrder
    admin_actions?: admin_actionsOrderByRelationAggregateInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsOrderByRelationAggregateInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsOrderByRelationAggregateInput
    messages_messages_receiverIdTousers?: messagesOrderByRelationAggregateInput
    messages_messages_senderIdTousers?: messagesOrderByRelationAggregateInput
    notification_preferences?: notification_preferencesOrderByWithRelationInput
    notification_tokens?: notification_tokensOrderByRelationAggregateInput
    notifications?: notificationsOrderByRelationAggregateInput
    orders_orders_customerIdTousers?: ordersOrderByRelationAggregateInput
    orders_orders_providerIdTousers?: ordersOrderByRelationAggregateInput
    otps?: otpsOrderByRelationAggregateInput
    payment_orders?: payment_ordersOrderByRelationAggregateInput
    profiles?: profilesOrderByWithRelationInput
    providers?: providersOrderByWithRelationInput
    report_schedules?: report_schedulesOrderByRelationAggregateInput
    reviews_reviews_revieweeIdTousers?: reviewsOrderByRelationAggregateInput
    reviews_reviews_reviewerIdTousers?: reviewsOrderByRelationAggregateInput
    tickets?: ticketsOrderByRelationAggregateInput
    user_payment_methods?: user_payment_methodsOrderByRelationAggregateInput
    user_verifications?: user_verificationsOrderByWithRelationInput
    wallets?: walletsOrderByWithRelationInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    userType?: EnumUserTypeFilter<"users"> | $Enums.UserType
    isVerified?: BoolFilter<"users"> | boolean
    isActive?: BoolFilter<"users"> | boolean
    isBlocked?: BoolFilter<"users"> | boolean
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    cancellationsCount?: IntFilter<"users"> | number
    isSuspect?: BoolFilter<"users"> | boolean
    admin_actions?: Admin_actionsListRelationFilter
    call_sessions_call_sessions_customerIdTousers?: Call_sessionsListRelationFilter
    call_sessions_call_sessions_providerIdTousers?: Call_sessionsListRelationFilter
    messages_messages_receiverIdTousers?: MessagesListRelationFilter
    messages_messages_senderIdTousers?: MessagesListRelationFilter
    notification_preferences?: XOR<Notification_preferencesNullableScalarRelationFilter, notification_preferencesWhereInput> | null
    notification_tokens?: Notification_tokensListRelationFilter
    notifications?: NotificationsListRelationFilter
    orders_orders_customerIdTousers?: OrdersListRelationFilter
    orders_orders_providerIdTousers?: OrdersListRelationFilter
    otps?: OtpsListRelationFilter
    payment_orders?: Payment_ordersListRelationFilter
    profiles?: XOR<ProfilesNullableScalarRelationFilter, profilesWhereInput> | null
    providers?: XOR<ProvidersNullableScalarRelationFilter, providersWhereInput> | null
    report_schedules?: Report_schedulesListRelationFilter
    reviews_reviews_revieweeIdTousers?: ReviewsListRelationFilter
    reviews_reviews_reviewerIdTousers?: ReviewsListRelationFilter
    tickets?: TicketsListRelationFilter
    user_payment_methods?: User_payment_methodsListRelationFilter
    user_verifications?: XOR<User_verificationsNullableScalarRelationFilter, user_verificationsWhereInput> | null
    wallets?: XOR<WalletsNullableScalarRelationFilter, walletsWhereInput> | null
  }, "id" | "email" | "phone">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    userType?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cancellationsCount?: SortOrder
    isSuspect?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users"> | string
    email?: StringNullableWithAggregatesFilter<"users"> | string | null
    phone?: StringNullableWithAggregatesFilter<"users"> | string | null
    userType?: EnumUserTypeWithAggregatesFilter<"users"> | $Enums.UserType
    isVerified?: BoolWithAggregatesFilter<"users"> | boolean
    isActive?: BoolWithAggregatesFilter<"users"> | boolean
    isBlocked?: BoolWithAggregatesFilter<"users"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    cancellationsCount?: IntWithAggregatesFilter<"users"> | number
    isSuspect?: BoolWithAggregatesFilter<"users"> | boolean
  }

  export type virtual_assignmentsWhereInput = {
    AND?: virtual_assignmentsWhereInput | virtual_assignmentsWhereInput[]
    OR?: virtual_assignmentsWhereInput[]
    NOT?: virtual_assignmentsWhereInput | virtual_assignmentsWhereInput[]
    id?: StringFilter<"virtual_assignments"> | string
    orderId?: StringFilter<"virtual_assignments"> | string
    virtualNumberId?: StringFilter<"virtual_assignments"> | string
    status?: StringFilter<"virtual_assignments"> | string
    assignedAt?: DateTimeFilter<"virtual_assignments"> | Date | string
    releasedAt?: DateTimeNullableFilter<"virtual_assignments"> | Date | string | null
    orders?: XOR<OrdersScalarRelationFilter, ordersWhereInput>
    virtual_numbers?: XOR<Virtual_numbersScalarRelationFilter, virtual_numbersWhereInput>
  }

  export type virtual_assignmentsOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    virtualNumberId?: SortOrder
    status?: SortOrder
    assignedAt?: SortOrder
    releasedAt?: SortOrderInput | SortOrder
    orders?: ordersOrderByWithRelationInput
    virtual_numbers?: virtual_numbersOrderByWithRelationInput
  }

  export type virtual_assignmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: virtual_assignmentsWhereInput | virtual_assignmentsWhereInput[]
    OR?: virtual_assignmentsWhereInput[]
    NOT?: virtual_assignmentsWhereInput | virtual_assignmentsWhereInput[]
    virtualNumberId?: StringFilter<"virtual_assignments"> | string
    status?: StringFilter<"virtual_assignments"> | string
    assignedAt?: DateTimeFilter<"virtual_assignments"> | Date | string
    releasedAt?: DateTimeNullableFilter<"virtual_assignments"> | Date | string | null
    orders?: XOR<OrdersScalarRelationFilter, ordersWhereInput>
    virtual_numbers?: XOR<Virtual_numbersScalarRelationFilter, virtual_numbersWhereInput>
  }, "id" | "orderId">

  export type virtual_assignmentsOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    virtualNumberId?: SortOrder
    status?: SortOrder
    assignedAt?: SortOrder
    releasedAt?: SortOrderInput | SortOrder
    _count?: virtual_assignmentsCountOrderByAggregateInput
    _max?: virtual_assignmentsMaxOrderByAggregateInput
    _min?: virtual_assignmentsMinOrderByAggregateInput
  }

  export type virtual_assignmentsScalarWhereWithAggregatesInput = {
    AND?: virtual_assignmentsScalarWhereWithAggregatesInput | virtual_assignmentsScalarWhereWithAggregatesInput[]
    OR?: virtual_assignmentsScalarWhereWithAggregatesInput[]
    NOT?: virtual_assignmentsScalarWhereWithAggregatesInput | virtual_assignmentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"virtual_assignments"> | string
    orderId?: StringWithAggregatesFilter<"virtual_assignments"> | string
    virtualNumberId?: StringWithAggregatesFilter<"virtual_assignments"> | string
    status?: StringWithAggregatesFilter<"virtual_assignments"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"virtual_assignments"> | Date | string
    releasedAt?: DateTimeNullableWithAggregatesFilter<"virtual_assignments"> | Date | string | null
  }

  export type virtual_numbersWhereInput = {
    AND?: virtual_numbersWhereInput | virtual_numbersWhereInput[]
    OR?: virtual_numbersWhereInput[]
    NOT?: virtual_numbersWhereInput | virtual_numbersWhereInput[]
    id?: StringFilter<"virtual_numbers"> | string
    phoneNumber?: StringFilter<"virtual_numbers"> | string
    isAssigned?: BoolFilter<"virtual_numbers"> | boolean
    createdAt?: DateTimeFilter<"virtual_numbers"> | Date | string
    updatedAt?: DateTimeFilter<"virtual_numbers"> | Date | string
    virtual_assignments?: Virtual_assignmentsListRelationFilter
  }

  export type virtual_numbersOrderByWithRelationInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    isAssigned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    virtual_assignments?: virtual_assignmentsOrderByRelationAggregateInput
  }

  export type virtual_numbersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phoneNumber?: string
    AND?: virtual_numbersWhereInput | virtual_numbersWhereInput[]
    OR?: virtual_numbersWhereInput[]
    NOT?: virtual_numbersWhereInput | virtual_numbersWhereInput[]
    isAssigned?: BoolFilter<"virtual_numbers"> | boolean
    createdAt?: DateTimeFilter<"virtual_numbers"> | Date | string
    updatedAt?: DateTimeFilter<"virtual_numbers"> | Date | string
    virtual_assignments?: Virtual_assignmentsListRelationFilter
  }, "id" | "phoneNumber">

  export type virtual_numbersOrderByWithAggregationInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    isAssigned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: virtual_numbersCountOrderByAggregateInput
    _max?: virtual_numbersMaxOrderByAggregateInput
    _min?: virtual_numbersMinOrderByAggregateInput
  }

  export type virtual_numbersScalarWhereWithAggregatesInput = {
    AND?: virtual_numbersScalarWhereWithAggregatesInput | virtual_numbersScalarWhereWithAggregatesInput[]
    OR?: virtual_numbersScalarWhereWithAggregatesInput[]
    NOT?: virtual_numbersScalarWhereWithAggregatesInput | virtual_numbersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"virtual_numbers"> | string
    phoneNumber?: StringWithAggregatesFilter<"virtual_numbers"> | string
    isAssigned?: BoolWithAggregatesFilter<"virtual_numbers"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"virtual_numbers"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"virtual_numbers"> | Date | string
  }

  export type walletsWhereInput = {
    AND?: walletsWhereInput | walletsWhereInput[]
    OR?: walletsWhereInput[]
    NOT?: walletsWhereInput | walletsWhereInput[]
    id?: StringFilter<"wallets"> | string
    userId?: StringFilter<"wallets"> | string
    balance?: FloatFilter<"wallets"> | number
    createdAt?: DateTimeFilter<"wallets"> | Date | string
    updatedAt?: DateTimeFilter<"wallets"> | Date | string
    transactions?: TransactionsListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type walletsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactions?: transactionsOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
  }

  export type walletsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: walletsWhereInput | walletsWhereInput[]
    OR?: walletsWhereInput[]
    NOT?: walletsWhereInput | walletsWhereInput[]
    balance?: FloatFilter<"wallets"> | number
    createdAt?: DateTimeFilter<"wallets"> | Date | string
    updatedAt?: DateTimeFilter<"wallets"> | Date | string
    transactions?: TransactionsListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "userId">

  export type walletsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: walletsCountOrderByAggregateInput
    _avg?: walletsAvgOrderByAggregateInput
    _max?: walletsMaxOrderByAggregateInput
    _min?: walletsMinOrderByAggregateInput
    _sum?: walletsSumOrderByAggregateInput
  }

  export type walletsScalarWhereWithAggregatesInput = {
    AND?: walletsScalarWhereWithAggregatesInput | walletsScalarWhereWithAggregatesInput[]
    OR?: walletsScalarWhereWithAggregatesInput[]
    NOT?: walletsScalarWhereWithAggregatesInput | walletsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"wallets"> | string
    userId?: StringWithAggregatesFilter<"wallets"> | string
    balance?: FloatWithAggregatesFilter<"wallets"> | number
    createdAt?: DateTimeWithAggregatesFilter<"wallets"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"wallets"> | Date | string
  }

  export type zonesWhereInput = {
    AND?: zonesWhereInput | zonesWhereInput[]
    OR?: zonesWhereInput[]
    NOT?: zonesWhereInput | zonesWhereInput[]
    id?: StringFilter<"zones"> | string
    name?: StringFilter<"zones"> | string
    city?: StringFilter<"zones"> | string
    polygon?: JsonFilter<"zones">
    isActive?: BoolFilter<"zones"> | boolean
    createdAt?: DateTimeFilter<"zones"> | Date | string
    updatedAt?: DateTimeFilter<"zones"> | Date | string
    provider_locations?: Provider_locationsListRelationFilter
  }

  export type zonesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    polygon?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider_locations?: provider_locationsOrderByRelationAggregateInput
  }

  export type zonesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: zonesWhereInput | zonesWhereInput[]
    OR?: zonesWhereInput[]
    NOT?: zonesWhereInput | zonesWhereInput[]
    city?: StringFilter<"zones"> | string
    polygon?: JsonFilter<"zones">
    isActive?: BoolFilter<"zones"> | boolean
    createdAt?: DateTimeFilter<"zones"> | Date | string
    updatedAt?: DateTimeFilter<"zones"> | Date | string
    provider_locations?: Provider_locationsListRelationFilter
  }, "id" | "name">

  export type zonesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    polygon?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: zonesCountOrderByAggregateInput
    _max?: zonesMaxOrderByAggregateInput
    _min?: zonesMinOrderByAggregateInput
  }

  export type zonesScalarWhereWithAggregatesInput = {
    AND?: zonesScalarWhereWithAggregatesInput | zonesScalarWhereWithAggregatesInput[]
    OR?: zonesScalarWhereWithAggregatesInput[]
    NOT?: zonesScalarWhereWithAggregatesInput | zonesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"zones"> | string
    name?: StringWithAggregatesFilter<"zones"> | string
    city?: StringWithAggregatesFilter<"zones"> | string
    polygon?: JsonWithAggregatesFilter<"zones">
    isActive?: BoolWithAggregatesFilter<"zones"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"zones"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"zones"> | Date | string
  }

  export type admin_actionsCreateInput = {
    id: string
    action: string
    targetId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    users: usersCreateNestedOneWithoutAdmin_actionsInput
  }

  export type admin_actionsUncheckedCreateInput = {
    id: string
    adminId: string
    action: string
    targetId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type admin_actionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutAdmin_actionsNestedInput
  }

  export type admin_actionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admin_actionsCreateManyInput = {
    id: string
    adminId: string
    action: string
    targetId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type admin_actionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admin_actionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type call_logsCreateInput = {
    id: string
    status: string
    duration?: number | null
    timestamp?: Date | string
    call_sessions: call_sessionsCreateNestedOneWithoutCall_logsInput
  }

  export type call_logsUncheckedCreateInput = {
    id: string
    callSessionId: string
    status: string
    duration?: number | null
    timestamp?: Date | string
  }

  export type call_logsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    call_sessions?: call_sessionsUpdateOneRequiredWithoutCall_logsNestedInput
  }

  export type call_logsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    callSessionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type call_logsCreateManyInput = {
    id: string
    callSessionId: string
    status: string
    duration?: number | null
    timestamp?: Date | string
  }

  export type call_logsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type call_logsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    callSessionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type call_sessionsCreateInput = {
    id: string
    twilioCallSid?: string | null
    customerPhone: string
    providerPhone: string
    status?: string
    duration?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    call_logs?: call_logsCreateNestedManyWithoutCall_sessionsInput
    users_call_sessions_customerIdTousers: usersCreateNestedOneWithoutCall_sessions_call_sessions_customerIdTousersInput
    orders?: ordersCreateNestedOneWithoutCall_sessionsInput
    users_call_sessions_providerIdTousers: usersCreateNestedOneWithoutCall_sessions_call_sessions_providerIdTousersInput
  }

  export type call_sessionsUncheckedCreateInput = {
    id: string
    customerId: string
    providerId: string
    orderId?: string | null
    twilioCallSid?: string | null
    customerPhone: string
    providerPhone: string
    status?: string
    duration?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    call_logs?: call_logsUncheckedCreateNestedManyWithoutCall_sessionsInput
  }

  export type call_sessionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    call_logs?: call_logsUpdateManyWithoutCall_sessionsNestedInput
    users_call_sessions_customerIdTousers?: usersUpdateOneRequiredWithoutCall_sessions_call_sessions_customerIdTousersNestedInput
    orders?: ordersUpdateOneWithoutCall_sessionsNestedInput
    users_call_sessions_providerIdTousers?: usersUpdateOneRequiredWithoutCall_sessions_call_sessions_providerIdTousersNestedInput
  }

  export type call_sessionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    call_logs?: call_logsUncheckedUpdateManyWithoutCall_sessionsNestedInput
  }

  export type call_sessionsCreateManyInput = {
    id: string
    customerId: string
    providerId: string
    orderId?: string | null
    twilioCallSid?: string | null
    customerPhone: string
    providerPhone: string
    status?: string
    duration?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type call_sessionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type call_sessionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type faqsCreateInput = {
    id: string
    question: string
    answer: string
    category: string
    order?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type faqsUncheckedCreateInput = {
    id: string
    question: string
    answer: string
    category: string
    order?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type faqsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type faqsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type faqsCreateManyInput = {
    id: string
    question: string
    answer: string
    category: string
    order?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type faqsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type faqsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type messagesCreateInput = {
    id: string
    content: string
    orderId?: string | null
    createdAt?: Date | string
    users_messages_receiverIdTousers: usersCreateNestedOneWithoutMessages_messages_receiverIdTousersInput
    users_messages_senderIdTousers: usersCreateNestedOneWithoutMessages_messages_senderIdTousersInput
  }

  export type messagesUncheckedCreateInput = {
    id: string
    senderId: string
    receiverId: string
    content: string
    orderId?: string | null
    createdAt?: Date | string
  }

  export type messagesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_messages_receiverIdTousers?: usersUpdateOneRequiredWithoutMessages_messages_receiverIdTousersNestedInput
    users_messages_senderIdTousers?: usersUpdateOneRequiredWithoutMessages_messages_senderIdTousersNestedInput
  }

  export type messagesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type messagesCreateManyInput = {
    id: string
    senderId: string
    receiverId: string
    content: string
    orderId?: string | null
    createdAt?: Date | string
  }

  export type messagesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type messagesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notification_preferencesCreateInput = {
    id: string
    pushEnabled?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    orderUpdates?: boolean
    messages?: boolean
    promotions?: boolean
    systemAlerts?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    users: usersCreateNestedOneWithoutNotification_preferencesInput
  }

  export type notification_preferencesUncheckedCreateInput = {
    id: string
    userId: string
    pushEnabled?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    orderUpdates?: boolean
    messages?: boolean
    promotions?: boolean
    systemAlerts?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type notification_preferencesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    orderUpdates?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    promotions?: BoolFieldUpdateOperationsInput | boolean
    systemAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutNotification_preferencesNestedInput
  }

  export type notification_preferencesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    orderUpdates?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    promotions?: BoolFieldUpdateOperationsInput | boolean
    systemAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notification_preferencesCreateManyInput = {
    id: string
    userId: string
    pushEnabled?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    orderUpdates?: boolean
    messages?: boolean
    promotions?: boolean
    systemAlerts?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type notification_preferencesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    orderUpdates?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    promotions?: BoolFieldUpdateOperationsInput | boolean
    systemAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notification_preferencesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    orderUpdates?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    promotions?: BoolFieldUpdateOperationsInput | boolean
    systemAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notification_tokensCreateInput = {
    id: string
    token: string
    platform?: string | null
    createdAt?: Date | string
    users: usersCreateNestedOneWithoutNotification_tokensInput
  }

  export type notification_tokensUncheckedCreateInput = {
    id: string
    userId: string
    token: string
    platform?: string | null
    createdAt?: Date | string
  }

  export type notification_tokensUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutNotification_tokensNestedInput
  }

  export type notification_tokensUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notification_tokensCreateManyInput = {
    id: string
    userId: string
    token: string
    platform?: string | null
    createdAt?: Date | string
  }

  export type notification_tokensUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notification_tokensUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsCreateInput = {
    id: string
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    type: string
    status?: string
    readAt?: Date | string | null
    createdAt?: Date | string
    users: usersCreateNestedOneWithoutNotificationsInput
  }

  export type notificationsUncheckedCreateInput = {
    id: string
    userId: string
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    type: string
    status?: string
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type notificationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type notificationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsCreateManyInput = {
    id: string
    userId: string
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    type: string
    status?: string
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type notificationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ordersCreateInput = {
    id: string
    status?: $Enums.OrderStatus
    totalAmount: number
    commission?: number
    serviceDate: Date | string
    address: string
    notes?: string | null
    cancelledBy?: string | null
    cancelReason?: string | null
    cancelledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    call_sessions?: call_sessionsCreateNestedManyWithoutOrdersInput
    users_orders_customerIdTousers: usersCreateNestedOneWithoutOrders_orders_customerIdTousersInput
    users_orders_providerIdTousers: usersCreateNestedOneWithoutOrders_orders_providerIdTousersInput
    services: servicesCreateNestedOneWithoutOrdersInput
    reviews?: reviewsCreateNestedOneWithoutOrdersInput
    virtual_assignments?: virtual_assignmentsCreateNestedOneWithoutOrdersInput
  }

  export type ordersUncheckedCreateInput = {
    id: string
    customerId: string
    providerId: string
    serviceId: string
    status?: $Enums.OrderStatus
    totalAmount: number
    commission?: number
    serviceDate: Date | string
    address: string
    notes?: string | null
    cancelledBy?: string | null
    cancelReason?: string | null
    cancelledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    call_sessions?: call_sessionsUncheckedCreateNestedManyWithoutOrdersInput
    reviews?: reviewsUncheckedCreateNestedOneWithoutOrdersInput
    virtual_assignments?: virtual_assignmentsUncheckedCreateNestedOneWithoutOrdersInput
  }

  export type ordersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    call_sessions?: call_sessionsUpdateManyWithoutOrdersNestedInput
    users_orders_customerIdTousers?: usersUpdateOneRequiredWithoutOrders_orders_customerIdTousersNestedInput
    users_orders_providerIdTousers?: usersUpdateOneRequiredWithoutOrders_orders_providerIdTousersNestedInput
    services?: servicesUpdateOneRequiredWithoutOrdersNestedInput
    reviews?: reviewsUpdateOneWithoutOrdersNestedInput
    virtual_assignments?: virtual_assignmentsUpdateOneWithoutOrdersNestedInput
  }

  export type ordersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    call_sessions?: call_sessionsUncheckedUpdateManyWithoutOrdersNestedInput
    reviews?: reviewsUncheckedUpdateOneWithoutOrdersNestedInput
    virtual_assignments?: virtual_assignmentsUncheckedUpdateOneWithoutOrdersNestedInput
  }

  export type ordersCreateManyInput = {
    id: string
    customerId: string
    providerId: string
    serviceId: string
    status?: $Enums.OrderStatus
    totalAmount: number
    commission?: number
    serviceDate: Date | string
    address: string
    notes?: string | null
    cancelledBy?: string | null
    cancelReason?: string | null
    cancelledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ordersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ordersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type otpsCreateInput = {
    id: string
    code: string
    type: string
    isUsed?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    users: usersCreateNestedOneWithoutOtpsInput
  }

  export type otpsUncheckedCreateInput = {
    id: string
    userId: string
    code: string
    type: string
    isUsed?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type otpsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutOtpsNestedInput
  }

  export type otpsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type otpsCreateManyInput = {
    id: string
    userId: string
    code: string
    type: string
    isUsed?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type otpsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type otpsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_ordersCreateInput = {
    id: string
    orderId: string
    paymentId?: string | null
    amount: number
    currency?: string
    paymentMethod: string
    status?: string
    type: string
    signature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
    users: usersCreateNestedOneWithoutPayment_ordersInput
  }

  export type payment_ordersUncheckedCreateInput = {
    id: string
    userId: string
    orderId: string
    paymentId?: string | null
    amount: number
    currency?: string
    paymentMethod: string
    status?: string
    type: string
    signature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type payment_ordersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutPayment_ordersNestedInput
  }

  export type payment_ordersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_ordersCreateManyInput = {
    id: string
    userId: string
    orderId: string
    paymentId?: string | null
    amount: number
    currency?: string
    paymentMethod: string
    status?: string
    type: string
    signature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type payment_ordersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_ordersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type profilesCreateInput = {
    id: string
    firstName: string
    lastName: string
    avatar?: string | null
    address?: string | null
    pincode?: string | null
    city?: string | null
    state?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt: Date | string
    passwordHash?: string | null
    googleId?: string | null
    googleVerified?: boolean
    users: usersCreateNestedOneWithoutProfilesInput
  }

  export type profilesUncheckedCreateInput = {
    id: string
    userId: string
    firstName: string
    lastName: string
    avatar?: string | null
    address?: string | null
    pincode?: string | null
    city?: string | null
    state?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt: Date | string
    passwordHash?: string | null
    googleId?: string | null
    googleVerified?: boolean
  }

  export type profilesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleVerified?: BoolFieldUpdateOperationsInput | boolean
    users?: usersUpdateOneRequiredWithoutProfilesNestedInput
  }

  export type profilesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type profilesCreateManyInput = {
    id: string
    userId: string
    firstName: string
    lastName: string
    avatar?: string | null
    address?: string | null
    pincode?: string | null
    city?: string | null
    state?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt: Date | string
    passwordHash?: string | null
    googleId?: string | null
    googleVerified?: boolean
  }

  export type profilesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type profilesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type provider_locationsCreateInput = {
    id: string
    lat: number
    lng: number
    address?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    providers: providersCreateNestedOneWithoutProvider_locationsInput
    zones?: zonesCreateNestedOneWithoutProvider_locationsInput
  }

  export type provider_locationsUncheckedCreateInput = {
    id: string
    providerId: string
    lat: number
    lng: number
    address?: string | null
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type provider_locationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providers?: providersUpdateOneRequiredWithoutProvider_locationsNestedInput
    zones?: zonesUpdateOneWithoutProvider_locationsNestedInput
  }

  export type provider_locationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type provider_locationsCreateManyInput = {
    id: string
    providerId: string
    lat: number
    lng: number
    address?: string | null
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type provider_locationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type provider_locationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type providersCreateInput = {
    id: string
    businessName: string
    providerType: $Enums.ProviderType
    category: string
    area: string
    address: string
    panNumber: string
    aadhaarNumber: string
    gstNumber?: string | null
    bankAccount?: string | null
    upiId?: string | null
    isVerified?: boolean
    isActive?: boolean
    rating?: number
    totalOrders?: number
    isOnline?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    provider_locations?: provider_locationsCreateNestedManyWithoutProvidersInput
    users: usersCreateNestedOneWithoutProvidersInput
    reviews?: reviewsCreateNestedManyWithoutProvidersInput
    services?: servicesCreateNestedManyWithoutProvidersInput
  }

  export type providersUncheckedCreateInput = {
    id: string
    userId: string
    businessName: string
    providerType: $Enums.ProviderType
    category: string
    area: string
    address: string
    panNumber: string
    aadhaarNumber: string
    gstNumber?: string | null
    bankAccount?: string | null
    upiId?: string | null
    isVerified?: boolean
    isActive?: boolean
    rating?: number
    totalOrders?: number
    isOnline?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    provider_locations?: provider_locationsUncheckedCreateNestedManyWithoutProvidersInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutProvidersInput
    services?: servicesUncheckedCreateNestedManyWithoutProvidersInput
  }

  export type providersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    category?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    panNumber?: StringFieldUpdateOperationsInput | string
    aadhaarNumber?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_locations?: provider_locationsUpdateManyWithoutProvidersNestedInput
    users?: usersUpdateOneRequiredWithoutProvidersNestedInput
    reviews?: reviewsUpdateManyWithoutProvidersNestedInput
    services?: servicesUpdateManyWithoutProvidersNestedInput
  }

  export type providersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    category?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    panNumber?: StringFieldUpdateOperationsInput | string
    aadhaarNumber?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_locations?: provider_locationsUncheckedUpdateManyWithoutProvidersNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutProvidersNestedInput
    services?: servicesUncheckedUpdateManyWithoutProvidersNestedInput
  }

  export type providersCreateManyInput = {
    id: string
    userId: string
    businessName: string
    providerType: $Enums.ProviderType
    category: string
    area: string
    address: string
    panNumber: string
    aadhaarNumber: string
    gstNumber?: string | null
    bankAccount?: string | null
    upiId?: string | null
    isVerified?: boolean
    isActive?: boolean
    rating?: number
    totalOrders?: number
    isOnline?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type providersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    category?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    panNumber?: StringFieldUpdateOperationsInput | string
    aadhaarNumber?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type providersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    category?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    panNumber?: StringFieldUpdateOperationsInput | string
    aadhaarNumber?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type report_schedulesCreateInput = {
    id: string
    reportType: string
    frequency: string
    email: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    users: usersCreateNestedOneWithoutReport_schedulesInput
  }

  export type report_schedulesUncheckedCreateInput = {
    id: string
    adminId: string
    reportType: string
    frequency: string
    email: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type report_schedulesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutReport_schedulesNestedInput
  }

  export type report_schedulesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type report_schedulesCreateManyInput = {
    id: string
    adminId: string
    reportType: string
    frequency: string
    email: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type report_schedulesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type report_schedulesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewsCreateInput = {
    id: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    orders: ordersCreateNestedOneWithoutReviewsInput
    providers?: providersCreateNestedOneWithoutReviewsInput
    users_reviews_revieweeIdTousers: usersCreateNestedOneWithoutReviews_reviews_revieweeIdTousersInput
    users_reviews_reviewerIdTousers: usersCreateNestedOneWithoutReviews_reviews_reviewerIdTousersInput
  }

  export type reviewsUncheckedCreateInput = {
    id: string
    orderId: string
    reviewerId: string
    revieweeId: string
    providerId?: string | null
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type reviewsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: ordersUpdateOneRequiredWithoutReviewsNestedInput
    providers?: providersUpdateOneWithoutReviewsNestedInput
    users_reviews_revieweeIdTousers?: usersUpdateOneRequiredWithoutReviews_reviews_revieweeIdTousersNestedInput
    users_reviews_reviewerIdTousers?: usersUpdateOneRequiredWithoutReviews_reviews_reviewerIdTousersNestedInput
  }

  export type reviewsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewsCreateManyInput = {
    id: string
    orderId: string
    reviewerId: string
    revieweeId: string
    providerId?: string | null
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type reviewsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type servicesCreateInput = {
    id: string
    name: string
    description: string
    category: string
    price: number
    basePrice?: number | null
    offerPercent?: number | null
    estimatedTime?: number | null
    warrantyMonths?: number | null
    duration: number
    status?: string
    isActive?: boolean
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    orders?: ordersCreateNestedManyWithoutServicesInput
    providers: providersCreateNestedOneWithoutServicesInput
  }

  export type servicesUncheckedCreateInput = {
    id: string
    providerId: string
    name: string
    description: string
    category: string
    price: number
    basePrice?: number | null
    offerPercent?: number | null
    estimatedTime?: number | null
    warrantyMonths?: number | null
    duration: number
    status?: string
    isActive?: boolean
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    orders?: ordersUncheckedCreateNestedManyWithoutServicesInput
  }

  export type servicesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    offerPercent?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedTime?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyMonths?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: ordersUpdateManyWithoutServicesNestedInput
    providers?: providersUpdateOneRequiredWithoutServicesNestedInput
  }

  export type servicesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    offerPercent?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedTime?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyMonths?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: ordersUncheckedUpdateManyWithoutServicesNestedInput
  }

  export type servicesCreateManyInput = {
    id: string
    providerId: string
    name: string
    description: string
    category: string
    price: number
    basePrice?: number | null
    offerPercent?: number | null
    estimatedTime?: number | null
    warrantyMonths?: number | null
    duration: number
    status?: string
    isActive?: boolean
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type servicesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    offerPercent?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedTime?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyMonths?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type servicesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    offerPercent?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedTime?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyMonths?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ticketsCreateInput = {
    id: string
    subject: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt: Date | string
    users: usersCreateNestedOneWithoutTicketsInput
  }

  export type ticketsUncheckedCreateInput = {
    id: string
    userId: string
    subject: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ticketsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type ticketsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ticketsCreateManyInput = {
    id: string
    userId: string
    subject: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ticketsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ticketsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsCreateInput = {
    id: string
    amount: number
    type: $Enums.TransactionType
    description: string
    paymentMethod?: $Enums.PaymentMethod | null
    orderId?: string | null
    createdAt?: Date | string
    wallets: walletsCreateNestedOneWithoutTransactionsInput
  }

  export type transactionsUncheckedCreateInput = {
    id: string
    walletId: string
    amount: number
    type: $Enums.TransactionType
    description: string
    paymentMethod?: $Enums.PaymentMethod | null
    orderId?: string | null
    createdAt?: Date | string
  }

  export type transactionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wallets?: walletsUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsCreateManyInput = {
    id: string
    walletId: string
    amount: number
    type: $Enums.TransactionType
    description: string
    paymentMethod?: $Enums.PaymentMethod | null
    orderId?: string | null
    createdAt?: Date | string
  }

  export type transactionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_payment_methodsCreateInput = {
    id: string
    type: string
    provider?: string | null
    upiId?: string | null
    cardNumber?: string | null
    cardName?: string | null
    expiryMonth?: string | null
    expiryYear?: string | null
    last4?: string | null
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    users: usersCreateNestedOneWithoutUser_payment_methodsInput
  }

  export type user_payment_methodsUncheckedCreateInput = {
    id: string
    userId: string
    type: string
    provider?: string | null
    upiId?: string | null
    cardNumber?: string | null
    cardName?: string | null
    expiryMonth?: string | null
    expiryYear?: string | null
    last4?: string | null
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type user_payment_methodsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardName?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableStringFieldUpdateOperationsInput | string | null
    expiryYear?: NullableStringFieldUpdateOperationsInput | string | null
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutUser_payment_methodsNestedInput
  }

  export type user_payment_methodsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardName?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableStringFieldUpdateOperationsInput | string | null
    expiryYear?: NullableStringFieldUpdateOperationsInput | string | null
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_payment_methodsCreateManyInput = {
    id: string
    userId: string
    type: string
    provider?: string | null
    upiId?: string | null
    cardNumber?: string | null
    cardName?: string | null
    expiryMonth?: string | null
    expiryYear?: string | null
    last4?: string | null
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type user_payment_methodsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardName?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableStringFieldUpdateOperationsInput | string | null
    expiryYear?: NullableStringFieldUpdateOperationsInput | string | null
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_payment_methodsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardName?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableStringFieldUpdateOperationsInput | string | null
    expiryYear?: NullableStringFieldUpdateOperationsInput | string | null
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_verificationsCreateInput = {
    id: string
    idType: string
    idNumber: string
    idFrontImage: string
    idBackImage?: string | null
    addressProofType: string
    addressProofNumber: string
    addressProofImage: string
    verificationStatus?: string
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    users: usersCreateNestedOneWithoutUser_verificationsInput
  }

  export type user_verificationsUncheckedCreateInput = {
    id: string
    userId: string
    idType: string
    idNumber: string
    idFrontImage: string
    idBackImage?: string | null
    addressProofType: string
    addressProofNumber: string
    addressProofImage: string
    verificationStatus?: string
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type user_verificationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idType?: StringFieldUpdateOperationsInput | string
    idNumber?: StringFieldUpdateOperationsInput | string
    idFrontImage?: StringFieldUpdateOperationsInput | string
    idBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    addressProofType?: StringFieldUpdateOperationsInput | string
    addressProofNumber?: StringFieldUpdateOperationsInput | string
    addressProofImage?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutUser_verificationsNestedInput
  }

  export type user_verificationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    idType?: StringFieldUpdateOperationsInput | string
    idNumber?: StringFieldUpdateOperationsInput | string
    idFrontImage?: StringFieldUpdateOperationsInput | string
    idBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    addressProofType?: StringFieldUpdateOperationsInput | string
    addressProofNumber?: StringFieldUpdateOperationsInput | string
    addressProofImage?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_verificationsCreateManyInput = {
    id: string
    userId: string
    idType: string
    idNumber: string
    idFrontImage: string
    idBackImage?: string | null
    addressProofType: string
    addressProofNumber: string
    addressProofImage: string
    verificationStatus?: string
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type user_verificationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    idType?: StringFieldUpdateOperationsInput | string
    idNumber?: StringFieldUpdateOperationsInput | string
    idFrontImage?: StringFieldUpdateOperationsInput | string
    idBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    addressProofType?: StringFieldUpdateOperationsInput | string
    addressProofNumber?: StringFieldUpdateOperationsInput | string
    addressProofImage?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_verificationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    idType?: StringFieldUpdateOperationsInput | string
    idNumber?: StringFieldUpdateOperationsInput | string
    idFrontImage?: StringFieldUpdateOperationsInput | string
    idBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    addressProofType?: StringFieldUpdateOperationsInput | string
    addressProofNumber?: StringFieldUpdateOperationsInput | string
    addressProofImage?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersCreateNestedManyWithoutUsersInput
    profiles?: profilesCreateNestedOneWithoutUsersInput
    providers?: providersCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsUncheckedCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsUncheckedCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersUncheckedCreateNestedManyWithoutUsersInput
    profiles?: profilesUncheckedCreateNestedOneWithoutUsersInput
    providers?: providersUncheckedCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesUncheckedCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsUncheckedCreateNestedOneWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUpdateManyWithoutUsersNestedInput
    profiles?: profilesUpdateOneWithoutUsersNestedInput
    providers?: providersUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUncheckedUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUncheckedUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUncheckedUpdateManyWithoutUsersNestedInput
    profiles?: profilesUncheckedUpdateOneWithoutUsersNestedInput
    providers?: providersUncheckedUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUncheckedUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUncheckedUpdateOneWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
  }

  export type usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type virtual_assignmentsCreateInput = {
    id: string
    status?: string
    assignedAt?: Date | string
    releasedAt?: Date | string | null
    orders: ordersCreateNestedOneWithoutVirtual_assignmentsInput
    virtual_numbers: virtual_numbersCreateNestedOneWithoutVirtual_assignmentsInput
  }

  export type virtual_assignmentsUncheckedCreateInput = {
    id: string
    orderId: string
    virtualNumberId: string
    status?: string
    assignedAt?: Date | string
    releasedAt?: Date | string | null
  }

  export type virtual_assignmentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: ordersUpdateOneRequiredWithoutVirtual_assignmentsNestedInput
    virtual_numbers?: virtual_numbersUpdateOneRequiredWithoutVirtual_assignmentsNestedInput
  }

  export type virtual_assignmentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    virtualNumberId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type virtual_assignmentsCreateManyInput = {
    id: string
    orderId: string
    virtualNumberId: string
    status?: string
    assignedAt?: Date | string
    releasedAt?: Date | string | null
  }

  export type virtual_assignmentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type virtual_assignmentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    virtualNumberId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type virtual_numbersCreateInput = {
    id: string
    phoneNumber: string
    isAssigned?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    virtual_assignments?: virtual_assignmentsCreateNestedManyWithoutVirtual_numbersInput
  }

  export type virtual_numbersUncheckedCreateInput = {
    id: string
    phoneNumber: string
    isAssigned?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    virtual_assignments?: virtual_assignmentsUncheckedCreateNestedManyWithoutVirtual_numbersInput
  }

  export type virtual_numbersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAssigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtual_assignments?: virtual_assignmentsUpdateManyWithoutVirtual_numbersNestedInput
  }

  export type virtual_numbersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAssigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtual_assignments?: virtual_assignmentsUncheckedUpdateManyWithoutVirtual_numbersNestedInput
  }

  export type virtual_numbersCreateManyInput = {
    id: string
    phoneNumber: string
    isAssigned?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type virtual_numbersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAssigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type virtual_numbersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAssigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type walletsCreateInput = {
    id: string
    balance?: number
    createdAt?: Date | string
    updatedAt: Date | string
    transactions?: transactionsCreateNestedManyWithoutWalletsInput
    users: usersCreateNestedOneWithoutWalletsInput
  }

  export type walletsUncheckedCreateInput = {
    id: string
    userId: string
    balance?: number
    createdAt?: Date | string
    updatedAt: Date | string
    transactions?: transactionsUncheckedCreateNestedManyWithoutWalletsInput
  }

  export type walletsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: transactionsUpdateManyWithoutWalletsNestedInput
    users?: usersUpdateOneRequiredWithoutWalletsNestedInput
  }

  export type walletsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: transactionsUncheckedUpdateManyWithoutWalletsNestedInput
  }

  export type walletsCreateManyInput = {
    id: string
    userId: string
    balance?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type walletsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type walletsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type zonesCreateInput = {
    id: string
    name: string
    city: string
    polygon: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    provider_locations?: provider_locationsCreateNestedManyWithoutZonesInput
  }

  export type zonesUncheckedCreateInput = {
    id: string
    name: string
    city: string
    polygon: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    provider_locations?: provider_locationsUncheckedCreateNestedManyWithoutZonesInput
  }

  export type zonesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    polygon?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_locations?: provider_locationsUpdateManyWithoutZonesNestedInput
  }

  export type zonesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    polygon?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_locations?: provider_locationsUncheckedUpdateManyWithoutZonesNestedInput
  }

  export type zonesCreateManyInput = {
    id: string
    name: string
    city: string
    polygon: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type zonesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    polygon?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type zonesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    polygon?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type admin_actionsCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetId?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type admin_actionsMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetId?: SortOrder
    createdAt?: SortOrder
  }

  export type admin_actionsMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetId?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type Call_sessionsScalarRelationFilter = {
    is?: call_sessionsWhereInput
    isNot?: call_sessionsWhereInput
  }

  export type call_logsCountOrderByAggregateInput = {
    id?: SortOrder
    callSessionId?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    timestamp?: SortOrder
  }

  export type call_logsAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type call_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    callSessionId?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    timestamp?: SortOrder
  }

  export type call_logsMinOrderByAggregateInput = {
    id?: SortOrder
    callSessionId?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    timestamp?: SortOrder
  }

  export type call_logsSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type Call_logsListRelationFilter = {
    every?: call_logsWhereInput
    some?: call_logsWhereInput
    none?: call_logsWhereInput
  }

  export type OrdersNullableScalarRelationFilter = {
    is?: ordersWhereInput | null
    isNot?: ordersWhereInput | null
  }

  export type call_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type call_sessionsCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    providerId?: SortOrder
    orderId?: SortOrder
    twilioCallSid?: SortOrder
    customerPhone?: SortOrder
    providerPhone?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type call_sessionsAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type call_sessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    providerId?: SortOrder
    orderId?: SortOrder
    twilioCallSid?: SortOrder
    customerPhone?: SortOrder
    providerPhone?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type call_sessionsMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    providerId?: SortOrder
    orderId?: SortOrder
    twilioCallSid?: SortOrder
    customerPhone?: SortOrder
    providerPhone?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type call_sessionsSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type faqsCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type faqsAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type faqsMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type faqsMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    category?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type faqsSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type messagesCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
  }

  export type messagesMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
  }

  export type messagesMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type notification_preferencesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pushEnabled?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    orderUpdates?: SortOrder
    messages?: SortOrder
    promotions?: SortOrder
    systemAlerts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type notification_preferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pushEnabled?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    orderUpdates?: SortOrder
    messages?: SortOrder
    promotions?: SortOrder
    systemAlerts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type notification_preferencesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pushEnabled?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    orderUpdates?: SortOrder
    messages?: SortOrder
    promotions?: SortOrder
    systemAlerts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type notification_tokensCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    platform?: SortOrder
    createdAt?: SortOrder
  }

  export type notification_tokensMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    platform?: SortOrder
    createdAt?: SortOrder
  }

  export type notification_tokensMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    platform?: SortOrder
    createdAt?: SortOrder
  }

  export type notificationsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    data?: SortOrder
    type?: SortOrder
    status?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type notificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    type?: SortOrder
    status?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type notificationsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    type?: SortOrder
    status?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type Call_sessionsListRelationFilter = {
    every?: call_sessionsWhereInput
    some?: call_sessionsWhereInput
    none?: call_sessionsWhereInput
  }

  export type ServicesScalarRelationFilter = {
    is?: servicesWhereInput
    isNot?: servicesWhereInput
  }

  export type ReviewsNullableScalarRelationFilter = {
    is?: reviewsWhereInput | null
    isNot?: reviewsWhereInput | null
  }

  export type Virtual_assignmentsNullableScalarRelationFilter = {
    is?: virtual_assignmentsWhereInput | null
    isNot?: virtual_assignmentsWhereInput | null
  }

  export type call_sessionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ordersCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    providerId?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    commission?: SortOrder
    serviceDate?: SortOrder
    address?: SortOrder
    notes?: SortOrder
    cancelledBy?: SortOrder
    cancelReason?: SortOrder
    cancelledAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ordersAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
    commission?: SortOrder
  }

  export type ordersMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    providerId?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    commission?: SortOrder
    serviceDate?: SortOrder
    address?: SortOrder
    notes?: SortOrder
    cancelledBy?: SortOrder
    cancelReason?: SortOrder
    cancelledAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ordersMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    providerId?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    commission?: SortOrder
    serviceDate?: SortOrder
    address?: SortOrder
    notes?: SortOrder
    cancelledBy?: SortOrder
    cancelReason?: SortOrder
    cancelledAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ordersSumOrderByAggregateInput = {
    totalAmount?: SortOrder
    commission?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type otpsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    type?: SortOrder
    isUsed?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type otpsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    type?: SortOrder
    isUsed?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type otpsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    type?: SortOrder
    isUsed?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type payment_ordersCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    paymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    type?: SortOrder
    signature?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type payment_ordersAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type payment_ordersMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    paymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    type?: SortOrder
    signature?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type payment_ordersMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    paymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    type?: SortOrder
    signature?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type payment_ordersSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type profilesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatar?: SortOrder
    address?: SortOrder
    pincode?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    passwordHash?: SortOrder
    googleId?: SortOrder
    googleVerified?: SortOrder
  }

  export type profilesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatar?: SortOrder
    address?: SortOrder
    pincode?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    passwordHash?: SortOrder
    googleId?: SortOrder
    googleVerified?: SortOrder
  }

  export type profilesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatar?: SortOrder
    address?: SortOrder
    pincode?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    passwordHash?: SortOrder
    googleId?: SortOrder
    googleVerified?: SortOrder
  }

  export type ProvidersScalarRelationFilter = {
    is?: providersWhereInput
    isNot?: providersWhereInput
  }

  export type ZonesNullableScalarRelationFilter = {
    is?: zonesWhereInput | null
    isNot?: zonesWhereInput | null
  }

  export type provider_locationsCountOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    address?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type provider_locationsAvgOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
  }

  export type provider_locationsMaxOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    address?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type provider_locationsMinOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    address?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type provider_locationsSumOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
  }

  export type EnumProviderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProviderType | EnumProviderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProviderType[] | ListEnumProviderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProviderType[] | ListEnumProviderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderTypeFilter<$PrismaModel> | $Enums.ProviderType
  }

  export type Provider_locationsListRelationFilter = {
    every?: provider_locationsWhereInput
    some?: provider_locationsWhereInput
    none?: provider_locationsWhereInput
  }

  export type ReviewsListRelationFilter = {
    every?: reviewsWhereInput
    some?: reviewsWhereInput
    none?: reviewsWhereInput
  }

  export type ServicesListRelationFilter = {
    every?: servicesWhereInput
    some?: servicesWhereInput
    none?: servicesWhereInput
  }

  export type provider_locationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reviewsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type servicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type providersCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    businessName?: SortOrder
    providerType?: SortOrder
    category?: SortOrder
    area?: SortOrder
    address?: SortOrder
    panNumber?: SortOrder
    aadhaarNumber?: SortOrder
    gstNumber?: SortOrder
    bankAccount?: SortOrder
    upiId?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    rating?: SortOrder
    totalOrders?: SortOrder
    isOnline?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type providersAvgOrderByAggregateInput = {
    rating?: SortOrder
    totalOrders?: SortOrder
  }

  export type providersMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    businessName?: SortOrder
    providerType?: SortOrder
    category?: SortOrder
    area?: SortOrder
    address?: SortOrder
    panNumber?: SortOrder
    aadhaarNumber?: SortOrder
    gstNumber?: SortOrder
    bankAccount?: SortOrder
    upiId?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    rating?: SortOrder
    totalOrders?: SortOrder
    isOnline?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type providersMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    businessName?: SortOrder
    providerType?: SortOrder
    category?: SortOrder
    area?: SortOrder
    address?: SortOrder
    panNumber?: SortOrder
    aadhaarNumber?: SortOrder
    gstNumber?: SortOrder
    bankAccount?: SortOrder
    upiId?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    rating?: SortOrder
    totalOrders?: SortOrder
    isOnline?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type providersSumOrderByAggregateInput = {
    rating?: SortOrder
    totalOrders?: SortOrder
  }

  export type EnumProviderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProviderType | EnumProviderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProviderType[] | ListEnumProviderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProviderType[] | ListEnumProviderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProviderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProviderTypeFilter<$PrismaModel>
    _max?: NestedEnumProviderTypeFilter<$PrismaModel>
  }

  export type report_schedulesCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    reportType?: SortOrder
    frequency?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type report_schedulesMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    reportType?: SortOrder
    frequency?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type report_schedulesMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    reportType?: SortOrder
    frequency?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrdersScalarRelationFilter = {
    is?: ordersWhereInput
    isNot?: ordersWhereInput
  }

  export type ProvidersNullableScalarRelationFilter = {
    is?: providersWhereInput | null
    isNot?: providersWhereInput | null
  }

  export type reviewsCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    reviewerId?: SortOrder
    revieweeId?: SortOrder
    providerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type reviewsAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type reviewsMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    reviewerId?: SortOrder
    revieweeId?: SortOrder
    providerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type reviewsMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    reviewerId?: SortOrder
    revieweeId?: SortOrder
    providerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type reviewsSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type OrdersListRelationFilter = {
    every?: ordersWhereInput
    some?: ordersWhereInput
    none?: ordersWhereInput
  }

  export type ordersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type servicesCountOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    price?: SortOrder
    basePrice?: SortOrder
    offerPercent?: SortOrder
    estimatedTime?: SortOrder
    warrantyMonths?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type servicesAvgOrderByAggregateInput = {
    price?: SortOrder
    basePrice?: SortOrder
    offerPercent?: SortOrder
    estimatedTime?: SortOrder
    warrantyMonths?: SortOrder
    duration?: SortOrder
  }

  export type servicesMaxOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    price?: SortOrder
    basePrice?: SortOrder
    offerPercent?: SortOrder
    estimatedTime?: SortOrder
    warrantyMonths?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type servicesMinOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    price?: SortOrder
    basePrice?: SortOrder
    offerPercent?: SortOrder
    estimatedTime?: SortOrder
    warrantyMonths?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type servicesSumOrderByAggregateInput = {
    price?: SortOrder
    basePrice?: SortOrder
    offerPercent?: SortOrder
    estimatedTime?: SortOrder
    warrantyMonths?: SortOrder
    duration?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ticketsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ticketsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ticketsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type WalletsScalarRelationFilter = {
    is?: walletsWhereInput
    isNot?: walletsWhereInput
  }

  export type transactionsCountOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
  }

  export type transactionsAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type transactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
  }

  export type transactionsMinOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
  }

  export type transactionsSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type user_payment_methodsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    upiId?: SortOrder
    cardNumber?: SortOrder
    cardName?: SortOrder
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
    last4?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_payment_methodsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    upiId?: SortOrder
    cardNumber?: SortOrder
    cardName?: SortOrder
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
    last4?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_payment_methodsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    upiId?: SortOrder
    cardNumber?: SortOrder
    cardName?: SortOrder
    expiryMonth?: SortOrder
    expiryYear?: SortOrder
    last4?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_verificationsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    idType?: SortOrder
    idNumber?: SortOrder
    idFrontImage?: SortOrder
    idBackImage?: SortOrder
    addressProofType?: SortOrder
    addressProofNumber?: SortOrder
    addressProofImage?: SortOrder
    verificationStatus?: SortOrder
    verifiedAt?: SortOrder
    verifiedBy?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_verificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    idType?: SortOrder
    idNumber?: SortOrder
    idFrontImage?: SortOrder
    idBackImage?: SortOrder
    addressProofType?: SortOrder
    addressProofNumber?: SortOrder
    addressProofImage?: SortOrder
    verificationStatus?: SortOrder
    verifiedAt?: SortOrder
    verifiedBy?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_verificationsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    idType?: SortOrder
    idNumber?: SortOrder
    idFrontImage?: SortOrder
    idBackImage?: SortOrder
    addressProofType?: SortOrder
    addressProofNumber?: SortOrder
    addressProofImage?: SortOrder
    verificationStatus?: SortOrder
    verifiedAt?: SortOrder
    verifiedBy?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type Admin_actionsListRelationFilter = {
    every?: admin_actionsWhereInput
    some?: admin_actionsWhereInput
    none?: admin_actionsWhereInput
  }

  export type MessagesListRelationFilter = {
    every?: messagesWhereInput
    some?: messagesWhereInput
    none?: messagesWhereInput
  }

  export type Notification_preferencesNullableScalarRelationFilter = {
    is?: notification_preferencesWhereInput | null
    isNot?: notification_preferencesWhereInput | null
  }

  export type Notification_tokensListRelationFilter = {
    every?: notification_tokensWhereInput
    some?: notification_tokensWhereInput
    none?: notification_tokensWhereInput
  }

  export type NotificationsListRelationFilter = {
    every?: notificationsWhereInput
    some?: notificationsWhereInput
    none?: notificationsWhereInput
  }

  export type OtpsListRelationFilter = {
    every?: otpsWhereInput
    some?: otpsWhereInput
    none?: otpsWhereInput
  }

  export type Payment_ordersListRelationFilter = {
    every?: payment_ordersWhereInput
    some?: payment_ordersWhereInput
    none?: payment_ordersWhereInput
  }

  export type ProfilesNullableScalarRelationFilter = {
    is?: profilesWhereInput | null
    isNot?: profilesWhereInput | null
  }

  export type Report_schedulesListRelationFilter = {
    every?: report_schedulesWhereInput
    some?: report_schedulesWhereInput
    none?: report_schedulesWhereInput
  }

  export type TicketsListRelationFilter = {
    every?: ticketsWhereInput
    some?: ticketsWhereInput
    none?: ticketsWhereInput
  }

  export type User_payment_methodsListRelationFilter = {
    every?: user_payment_methodsWhereInput
    some?: user_payment_methodsWhereInput
    none?: user_payment_methodsWhereInput
  }

  export type User_verificationsNullableScalarRelationFilter = {
    is?: user_verificationsWhereInput | null
    isNot?: user_verificationsWhereInput | null
  }

  export type WalletsNullableScalarRelationFilter = {
    is?: walletsWhereInput | null
    isNot?: walletsWhereInput | null
  }

  export type admin_actionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type messagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notification_tokensOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type otpsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type payment_ordersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type report_schedulesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ticketsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_payment_methodsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    userType?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cancellationsCount?: SortOrder
    isSuspect?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    cancellationsCount?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    userType?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cancellationsCount?: SortOrder
    isSuspect?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    userType?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    isBlocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cancellationsCount?: SortOrder
    isSuspect?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    cancellationsCount?: SortOrder
  }

  export type EnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type Virtual_numbersScalarRelationFilter = {
    is?: virtual_numbersWhereInput
    isNot?: virtual_numbersWhereInput
  }

  export type virtual_assignmentsCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    virtualNumberId?: SortOrder
    status?: SortOrder
    assignedAt?: SortOrder
    releasedAt?: SortOrder
  }

  export type virtual_assignmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    virtualNumberId?: SortOrder
    status?: SortOrder
    assignedAt?: SortOrder
    releasedAt?: SortOrder
  }

  export type virtual_assignmentsMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    virtualNumberId?: SortOrder
    status?: SortOrder
    assignedAt?: SortOrder
    releasedAt?: SortOrder
  }

  export type Virtual_assignmentsListRelationFilter = {
    every?: virtual_assignmentsWhereInput
    some?: virtual_assignmentsWhereInput
    none?: virtual_assignmentsWhereInput
  }

  export type virtual_assignmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type virtual_numbersCountOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    isAssigned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type virtual_numbersMaxOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    isAssigned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type virtual_numbersMinOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    isAssigned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionsListRelationFilter = {
    every?: transactionsWhereInput
    some?: transactionsWhereInput
    none?: transactionsWhereInput
  }

  export type transactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type walletsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type walletsAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type walletsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type walletsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type walletsSumOrderByAggregateInput = {
    balance?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type zonesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    polygon?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type zonesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type zonesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type usersCreateNestedOneWithoutAdmin_actionsInput = {
    create?: XOR<usersCreateWithoutAdmin_actionsInput, usersUncheckedCreateWithoutAdmin_actionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAdmin_actionsInput
    connect?: usersWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type usersUpdateOneRequiredWithoutAdmin_actionsNestedInput = {
    create?: XOR<usersCreateWithoutAdmin_actionsInput, usersUncheckedCreateWithoutAdmin_actionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAdmin_actionsInput
    upsert?: usersUpsertWithoutAdmin_actionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAdmin_actionsInput, usersUpdateWithoutAdmin_actionsInput>, usersUncheckedUpdateWithoutAdmin_actionsInput>
  }

  export type call_sessionsCreateNestedOneWithoutCall_logsInput = {
    create?: XOR<call_sessionsCreateWithoutCall_logsInput, call_sessionsUncheckedCreateWithoutCall_logsInput>
    connectOrCreate?: call_sessionsCreateOrConnectWithoutCall_logsInput
    connect?: call_sessionsWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type call_sessionsUpdateOneRequiredWithoutCall_logsNestedInput = {
    create?: XOR<call_sessionsCreateWithoutCall_logsInput, call_sessionsUncheckedCreateWithoutCall_logsInput>
    connectOrCreate?: call_sessionsCreateOrConnectWithoutCall_logsInput
    upsert?: call_sessionsUpsertWithoutCall_logsInput
    connect?: call_sessionsWhereUniqueInput
    update?: XOR<XOR<call_sessionsUpdateToOneWithWhereWithoutCall_logsInput, call_sessionsUpdateWithoutCall_logsInput>, call_sessionsUncheckedUpdateWithoutCall_logsInput>
  }

  export type call_logsCreateNestedManyWithoutCall_sessionsInput = {
    create?: XOR<call_logsCreateWithoutCall_sessionsInput, call_logsUncheckedCreateWithoutCall_sessionsInput> | call_logsCreateWithoutCall_sessionsInput[] | call_logsUncheckedCreateWithoutCall_sessionsInput[]
    connectOrCreate?: call_logsCreateOrConnectWithoutCall_sessionsInput | call_logsCreateOrConnectWithoutCall_sessionsInput[]
    createMany?: call_logsCreateManyCall_sessionsInputEnvelope
    connect?: call_logsWhereUniqueInput | call_logsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutCall_sessions_call_sessions_customerIdTousersInput = {
    create?: XOR<usersCreateWithoutCall_sessions_call_sessions_customerIdTousersInput, usersUncheckedCreateWithoutCall_sessions_call_sessions_customerIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutCall_sessions_call_sessions_customerIdTousersInput
    connect?: usersWhereUniqueInput
  }

  export type ordersCreateNestedOneWithoutCall_sessionsInput = {
    create?: XOR<ordersCreateWithoutCall_sessionsInput, ordersUncheckedCreateWithoutCall_sessionsInput>
    connectOrCreate?: ordersCreateOrConnectWithoutCall_sessionsInput
    connect?: ordersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutCall_sessions_call_sessions_providerIdTousersInput = {
    create?: XOR<usersCreateWithoutCall_sessions_call_sessions_providerIdTousersInput, usersUncheckedCreateWithoutCall_sessions_call_sessions_providerIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutCall_sessions_call_sessions_providerIdTousersInput
    connect?: usersWhereUniqueInput
  }

  export type call_logsUncheckedCreateNestedManyWithoutCall_sessionsInput = {
    create?: XOR<call_logsCreateWithoutCall_sessionsInput, call_logsUncheckedCreateWithoutCall_sessionsInput> | call_logsCreateWithoutCall_sessionsInput[] | call_logsUncheckedCreateWithoutCall_sessionsInput[]
    connectOrCreate?: call_logsCreateOrConnectWithoutCall_sessionsInput | call_logsCreateOrConnectWithoutCall_sessionsInput[]
    createMany?: call_logsCreateManyCall_sessionsInputEnvelope
    connect?: call_logsWhereUniqueInput | call_logsWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type call_logsUpdateManyWithoutCall_sessionsNestedInput = {
    create?: XOR<call_logsCreateWithoutCall_sessionsInput, call_logsUncheckedCreateWithoutCall_sessionsInput> | call_logsCreateWithoutCall_sessionsInput[] | call_logsUncheckedCreateWithoutCall_sessionsInput[]
    connectOrCreate?: call_logsCreateOrConnectWithoutCall_sessionsInput | call_logsCreateOrConnectWithoutCall_sessionsInput[]
    upsert?: call_logsUpsertWithWhereUniqueWithoutCall_sessionsInput | call_logsUpsertWithWhereUniqueWithoutCall_sessionsInput[]
    createMany?: call_logsCreateManyCall_sessionsInputEnvelope
    set?: call_logsWhereUniqueInput | call_logsWhereUniqueInput[]
    disconnect?: call_logsWhereUniqueInput | call_logsWhereUniqueInput[]
    delete?: call_logsWhereUniqueInput | call_logsWhereUniqueInput[]
    connect?: call_logsWhereUniqueInput | call_logsWhereUniqueInput[]
    update?: call_logsUpdateWithWhereUniqueWithoutCall_sessionsInput | call_logsUpdateWithWhereUniqueWithoutCall_sessionsInput[]
    updateMany?: call_logsUpdateManyWithWhereWithoutCall_sessionsInput | call_logsUpdateManyWithWhereWithoutCall_sessionsInput[]
    deleteMany?: call_logsScalarWhereInput | call_logsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutCall_sessions_call_sessions_customerIdTousersNestedInput = {
    create?: XOR<usersCreateWithoutCall_sessions_call_sessions_customerIdTousersInput, usersUncheckedCreateWithoutCall_sessions_call_sessions_customerIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutCall_sessions_call_sessions_customerIdTousersInput
    upsert?: usersUpsertWithoutCall_sessions_call_sessions_customerIdTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCall_sessions_call_sessions_customerIdTousersInput, usersUpdateWithoutCall_sessions_call_sessions_customerIdTousersInput>, usersUncheckedUpdateWithoutCall_sessions_call_sessions_customerIdTousersInput>
  }

  export type ordersUpdateOneWithoutCall_sessionsNestedInput = {
    create?: XOR<ordersCreateWithoutCall_sessionsInput, ordersUncheckedCreateWithoutCall_sessionsInput>
    connectOrCreate?: ordersCreateOrConnectWithoutCall_sessionsInput
    upsert?: ordersUpsertWithoutCall_sessionsInput
    disconnect?: ordersWhereInput | boolean
    delete?: ordersWhereInput | boolean
    connect?: ordersWhereUniqueInput
    update?: XOR<XOR<ordersUpdateToOneWithWhereWithoutCall_sessionsInput, ordersUpdateWithoutCall_sessionsInput>, ordersUncheckedUpdateWithoutCall_sessionsInput>
  }

  export type usersUpdateOneRequiredWithoutCall_sessions_call_sessions_providerIdTousersNestedInput = {
    create?: XOR<usersCreateWithoutCall_sessions_call_sessions_providerIdTousersInput, usersUncheckedCreateWithoutCall_sessions_call_sessions_providerIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutCall_sessions_call_sessions_providerIdTousersInput
    upsert?: usersUpsertWithoutCall_sessions_call_sessions_providerIdTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCall_sessions_call_sessions_providerIdTousersInput, usersUpdateWithoutCall_sessions_call_sessions_providerIdTousersInput>, usersUncheckedUpdateWithoutCall_sessions_call_sessions_providerIdTousersInput>
  }

  export type call_logsUncheckedUpdateManyWithoutCall_sessionsNestedInput = {
    create?: XOR<call_logsCreateWithoutCall_sessionsInput, call_logsUncheckedCreateWithoutCall_sessionsInput> | call_logsCreateWithoutCall_sessionsInput[] | call_logsUncheckedCreateWithoutCall_sessionsInput[]
    connectOrCreate?: call_logsCreateOrConnectWithoutCall_sessionsInput | call_logsCreateOrConnectWithoutCall_sessionsInput[]
    upsert?: call_logsUpsertWithWhereUniqueWithoutCall_sessionsInput | call_logsUpsertWithWhereUniqueWithoutCall_sessionsInput[]
    createMany?: call_logsCreateManyCall_sessionsInputEnvelope
    set?: call_logsWhereUniqueInput | call_logsWhereUniqueInput[]
    disconnect?: call_logsWhereUniqueInput | call_logsWhereUniqueInput[]
    delete?: call_logsWhereUniqueInput | call_logsWhereUniqueInput[]
    connect?: call_logsWhereUniqueInput | call_logsWhereUniqueInput[]
    update?: call_logsUpdateWithWhereUniqueWithoutCall_sessionsInput | call_logsUpdateWithWhereUniqueWithoutCall_sessionsInput[]
    updateMany?: call_logsUpdateManyWithWhereWithoutCall_sessionsInput | call_logsUpdateManyWithWhereWithoutCall_sessionsInput[]
    deleteMany?: call_logsScalarWhereInput | call_logsScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type usersCreateNestedOneWithoutMessages_messages_receiverIdTousersInput = {
    create?: XOR<usersCreateWithoutMessages_messages_receiverIdTousersInput, usersUncheckedCreateWithoutMessages_messages_receiverIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutMessages_messages_receiverIdTousersInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutMessages_messages_senderIdTousersInput = {
    create?: XOR<usersCreateWithoutMessages_messages_senderIdTousersInput, usersUncheckedCreateWithoutMessages_messages_senderIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutMessages_messages_senderIdTousersInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutMessages_messages_receiverIdTousersNestedInput = {
    create?: XOR<usersCreateWithoutMessages_messages_receiverIdTousersInput, usersUncheckedCreateWithoutMessages_messages_receiverIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutMessages_messages_receiverIdTousersInput
    upsert?: usersUpsertWithoutMessages_messages_receiverIdTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutMessages_messages_receiverIdTousersInput, usersUpdateWithoutMessages_messages_receiverIdTousersInput>, usersUncheckedUpdateWithoutMessages_messages_receiverIdTousersInput>
  }

  export type usersUpdateOneRequiredWithoutMessages_messages_senderIdTousersNestedInput = {
    create?: XOR<usersCreateWithoutMessages_messages_senderIdTousersInput, usersUncheckedCreateWithoutMessages_messages_senderIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutMessages_messages_senderIdTousersInput
    upsert?: usersUpsertWithoutMessages_messages_senderIdTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutMessages_messages_senderIdTousersInput, usersUpdateWithoutMessages_messages_senderIdTousersInput>, usersUncheckedUpdateWithoutMessages_messages_senderIdTousersInput>
  }

  export type usersCreateNestedOneWithoutNotification_preferencesInput = {
    create?: XOR<usersCreateWithoutNotification_preferencesInput, usersUncheckedCreateWithoutNotification_preferencesInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotification_preferencesInput
    connect?: usersWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type usersUpdateOneRequiredWithoutNotification_preferencesNestedInput = {
    create?: XOR<usersCreateWithoutNotification_preferencesInput, usersUncheckedCreateWithoutNotification_preferencesInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotification_preferencesInput
    upsert?: usersUpsertWithoutNotification_preferencesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutNotification_preferencesInput, usersUpdateWithoutNotification_preferencesInput>, usersUncheckedUpdateWithoutNotification_preferencesInput>
  }

  export type usersCreateNestedOneWithoutNotification_tokensInput = {
    create?: XOR<usersCreateWithoutNotification_tokensInput, usersUncheckedCreateWithoutNotification_tokensInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotification_tokensInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutNotification_tokensNestedInput = {
    create?: XOR<usersCreateWithoutNotification_tokensInput, usersUncheckedCreateWithoutNotification_tokensInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotification_tokensInput
    upsert?: usersUpsertWithoutNotification_tokensInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutNotification_tokensInput, usersUpdateWithoutNotification_tokensInput>, usersUncheckedUpdateWithoutNotification_tokensInput>
  }

  export type usersCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotificationsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotificationsInput
    upsert?: usersUpsertWithoutNotificationsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutNotificationsInput, usersUpdateWithoutNotificationsInput>, usersUncheckedUpdateWithoutNotificationsInput>
  }

  export type call_sessionsCreateNestedManyWithoutOrdersInput = {
    create?: XOR<call_sessionsCreateWithoutOrdersInput, call_sessionsUncheckedCreateWithoutOrdersInput> | call_sessionsCreateWithoutOrdersInput[] | call_sessionsUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: call_sessionsCreateOrConnectWithoutOrdersInput | call_sessionsCreateOrConnectWithoutOrdersInput[]
    createMany?: call_sessionsCreateManyOrdersInputEnvelope
    connect?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutOrders_orders_customerIdTousersInput = {
    create?: XOR<usersCreateWithoutOrders_orders_customerIdTousersInput, usersUncheckedCreateWithoutOrders_orders_customerIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutOrders_orders_customerIdTousersInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutOrders_orders_providerIdTousersInput = {
    create?: XOR<usersCreateWithoutOrders_orders_providerIdTousersInput, usersUncheckedCreateWithoutOrders_orders_providerIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutOrders_orders_providerIdTousersInput
    connect?: usersWhereUniqueInput
  }

  export type servicesCreateNestedOneWithoutOrdersInput = {
    create?: XOR<servicesCreateWithoutOrdersInput, servicesUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: servicesCreateOrConnectWithoutOrdersInput
    connect?: servicesWhereUniqueInput
  }

  export type reviewsCreateNestedOneWithoutOrdersInput = {
    create?: XOR<reviewsCreateWithoutOrdersInput, reviewsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: reviewsCreateOrConnectWithoutOrdersInput
    connect?: reviewsWhereUniqueInput
  }

  export type virtual_assignmentsCreateNestedOneWithoutOrdersInput = {
    create?: XOR<virtual_assignmentsCreateWithoutOrdersInput, virtual_assignmentsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: virtual_assignmentsCreateOrConnectWithoutOrdersInput
    connect?: virtual_assignmentsWhereUniqueInput
  }

  export type call_sessionsUncheckedCreateNestedManyWithoutOrdersInput = {
    create?: XOR<call_sessionsCreateWithoutOrdersInput, call_sessionsUncheckedCreateWithoutOrdersInput> | call_sessionsCreateWithoutOrdersInput[] | call_sessionsUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: call_sessionsCreateOrConnectWithoutOrdersInput | call_sessionsCreateOrConnectWithoutOrdersInput[]
    createMany?: call_sessionsCreateManyOrdersInputEnvelope
    connect?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
  }

  export type reviewsUncheckedCreateNestedOneWithoutOrdersInput = {
    create?: XOR<reviewsCreateWithoutOrdersInput, reviewsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: reviewsCreateOrConnectWithoutOrdersInput
    connect?: reviewsWhereUniqueInput
  }

  export type virtual_assignmentsUncheckedCreateNestedOneWithoutOrdersInput = {
    create?: XOR<virtual_assignmentsCreateWithoutOrdersInput, virtual_assignmentsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: virtual_assignmentsCreateOrConnectWithoutOrdersInput
    connect?: virtual_assignmentsWhereUniqueInput
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type call_sessionsUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<call_sessionsCreateWithoutOrdersInput, call_sessionsUncheckedCreateWithoutOrdersInput> | call_sessionsCreateWithoutOrdersInput[] | call_sessionsUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: call_sessionsCreateOrConnectWithoutOrdersInput | call_sessionsCreateOrConnectWithoutOrdersInput[]
    upsert?: call_sessionsUpsertWithWhereUniqueWithoutOrdersInput | call_sessionsUpsertWithWhereUniqueWithoutOrdersInput[]
    createMany?: call_sessionsCreateManyOrdersInputEnvelope
    set?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
    disconnect?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
    delete?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
    connect?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
    update?: call_sessionsUpdateWithWhereUniqueWithoutOrdersInput | call_sessionsUpdateWithWhereUniqueWithoutOrdersInput[]
    updateMany?: call_sessionsUpdateManyWithWhereWithoutOrdersInput | call_sessionsUpdateManyWithWhereWithoutOrdersInput[]
    deleteMany?: call_sessionsScalarWhereInput | call_sessionsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutOrders_orders_customerIdTousersNestedInput = {
    create?: XOR<usersCreateWithoutOrders_orders_customerIdTousersInput, usersUncheckedCreateWithoutOrders_orders_customerIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutOrders_orders_customerIdTousersInput
    upsert?: usersUpsertWithoutOrders_orders_customerIdTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutOrders_orders_customerIdTousersInput, usersUpdateWithoutOrders_orders_customerIdTousersInput>, usersUncheckedUpdateWithoutOrders_orders_customerIdTousersInput>
  }

  export type usersUpdateOneRequiredWithoutOrders_orders_providerIdTousersNestedInput = {
    create?: XOR<usersCreateWithoutOrders_orders_providerIdTousersInput, usersUncheckedCreateWithoutOrders_orders_providerIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutOrders_orders_providerIdTousersInput
    upsert?: usersUpsertWithoutOrders_orders_providerIdTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutOrders_orders_providerIdTousersInput, usersUpdateWithoutOrders_orders_providerIdTousersInput>, usersUncheckedUpdateWithoutOrders_orders_providerIdTousersInput>
  }

  export type servicesUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<servicesCreateWithoutOrdersInput, servicesUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: servicesCreateOrConnectWithoutOrdersInput
    upsert?: servicesUpsertWithoutOrdersInput
    connect?: servicesWhereUniqueInput
    update?: XOR<XOR<servicesUpdateToOneWithWhereWithoutOrdersInput, servicesUpdateWithoutOrdersInput>, servicesUncheckedUpdateWithoutOrdersInput>
  }

  export type reviewsUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<reviewsCreateWithoutOrdersInput, reviewsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: reviewsCreateOrConnectWithoutOrdersInput
    upsert?: reviewsUpsertWithoutOrdersInput
    disconnect?: reviewsWhereInput | boolean
    delete?: reviewsWhereInput | boolean
    connect?: reviewsWhereUniqueInput
    update?: XOR<XOR<reviewsUpdateToOneWithWhereWithoutOrdersInput, reviewsUpdateWithoutOrdersInput>, reviewsUncheckedUpdateWithoutOrdersInput>
  }

  export type virtual_assignmentsUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<virtual_assignmentsCreateWithoutOrdersInput, virtual_assignmentsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: virtual_assignmentsCreateOrConnectWithoutOrdersInput
    upsert?: virtual_assignmentsUpsertWithoutOrdersInput
    disconnect?: virtual_assignmentsWhereInput | boolean
    delete?: virtual_assignmentsWhereInput | boolean
    connect?: virtual_assignmentsWhereUniqueInput
    update?: XOR<XOR<virtual_assignmentsUpdateToOneWithWhereWithoutOrdersInput, virtual_assignmentsUpdateWithoutOrdersInput>, virtual_assignmentsUncheckedUpdateWithoutOrdersInput>
  }

  export type call_sessionsUncheckedUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<call_sessionsCreateWithoutOrdersInput, call_sessionsUncheckedCreateWithoutOrdersInput> | call_sessionsCreateWithoutOrdersInput[] | call_sessionsUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: call_sessionsCreateOrConnectWithoutOrdersInput | call_sessionsCreateOrConnectWithoutOrdersInput[]
    upsert?: call_sessionsUpsertWithWhereUniqueWithoutOrdersInput | call_sessionsUpsertWithWhereUniqueWithoutOrdersInput[]
    createMany?: call_sessionsCreateManyOrdersInputEnvelope
    set?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
    disconnect?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
    delete?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
    connect?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
    update?: call_sessionsUpdateWithWhereUniqueWithoutOrdersInput | call_sessionsUpdateWithWhereUniqueWithoutOrdersInput[]
    updateMany?: call_sessionsUpdateManyWithWhereWithoutOrdersInput | call_sessionsUpdateManyWithWhereWithoutOrdersInput[]
    deleteMany?: call_sessionsScalarWhereInput | call_sessionsScalarWhereInput[]
  }

  export type reviewsUncheckedUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<reviewsCreateWithoutOrdersInput, reviewsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: reviewsCreateOrConnectWithoutOrdersInput
    upsert?: reviewsUpsertWithoutOrdersInput
    disconnect?: reviewsWhereInput | boolean
    delete?: reviewsWhereInput | boolean
    connect?: reviewsWhereUniqueInput
    update?: XOR<XOR<reviewsUpdateToOneWithWhereWithoutOrdersInput, reviewsUpdateWithoutOrdersInput>, reviewsUncheckedUpdateWithoutOrdersInput>
  }

  export type virtual_assignmentsUncheckedUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<virtual_assignmentsCreateWithoutOrdersInput, virtual_assignmentsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: virtual_assignmentsCreateOrConnectWithoutOrdersInput
    upsert?: virtual_assignmentsUpsertWithoutOrdersInput
    disconnect?: virtual_assignmentsWhereInput | boolean
    delete?: virtual_assignmentsWhereInput | boolean
    connect?: virtual_assignmentsWhereUniqueInput
    update?: XOR<XOR<virtual_assignmentsUpdateToOneWithWhereWithoutOrdersInput, virtual_assignmentsUpdateWithoutOrdersInput>, virtual_assignmentsUncheckedUpdateWithoutOrdersInput>
  }

  export type usersCreateNestedOneWithoutOtpsInput = {
    create?: XOR<usersCreateWithoutOtpsInput, usersUncheckedCreateWithoutOtpsInput>
    connectOrCreate?: usersCreateOrConnectWithoutOtpsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutOtpsNestedInput = {
    create?: XOR<usersCreateWithoutOtpsInput, usersUncheckedCreateWithoutOtpsInput>
    connectOrCreate?: usersCreateOrConnectWithoutOtpsInput
    upsert?: usersUpsertWithoutOtpsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutOtpsInput, usersUpdateWithoutOtpsInput>, usersUncheckedUpdateWithoutOtpsInput>
  }

  export type usersCreateNestedOneWithoutPayment_ordersInput = {
    create?: XOR<usersCreateWithoutPayment_ordersInput, usersUncheckedCreateWithoutPayment_ordersInput>
    connectOrCreate?: usersCreateOrConnectWithoutPayment_ordersInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutPayment_ordersNestedInput = {
    create?: XOR<usersCreateWithoutPayment_ordersInput, usersUncheckedCreateWithoutPayment_ordersInput>
    connectOrCreate?: usersCreateOrConnectWithoutPayment_ordersInput
    upsert?: usersUpsertWithoutPayment_ordersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPayment_ordersInput, usersUpdateWithoutPayment_ordersInput>, usersUncheckedUpdateWithoutPayment_ordersInput>
  }

  export type usersCreateNestedOneWithoutProfilesInput = {
    create?: XOR<usersCreateWithoutProfilesInput, usersUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: usersCreateOrConnectWithoutProfilesInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutProfilesNestedInput = {
    create?: XOR<usersCreateWithoutProfilesInput, usersUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: usersCreateOrConnectWithoutProfilesInput
    upsert?: usersUpsertWithoutProfilesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutProfilesInput, usersUpdateWithoutProfilesInput>, usersUncheckedUpdateWithoutProfilesInput>
  }

  export type providersCreateNestedOneWithoutProvider_locationsInput = {
    create?: XOR<providersCreateWithoutProvider_locationsInput, providersUncheckedCreateWithoutProvider_locationsInput>
    connectOrCreate?: providersCreateOrConnectWithoutProvider_locationsInput
    connect?: providersWhereUniqueInput
  }

  export type zonesCreateNestedOneWithoutProvider_locationsInput = {
    create?: XOR<zonesCreateWithoutProvider_locationsInput, zonesUncheckedCreateWithoutProvider_locationsInput>
    connectOrCreate?: zonesCreateOrConnectWithoutProvider_locationsInput
    connect?: zonesWhereUniqueInput
  }

  export type providersUpdateOneRequiredWithoutProvider_locationsNestedInput = {
    create?: XOR<providersCreateWithoutProvider_locationsInput, providersUncheckedCreateWithoutProvider_locationsInput>
    connectOrCreate?: providersCreateOrConnectWithoutProvider_locationsInput
    upsert?: providersUpsertWithoutProvider_locationsInput
    connect?: providersWhereUniqueInput
    update?: XOR<XOR<providersUpdateToOneWithWhereWithoutProvider_locationsInput, providersUpdateWithoutProvider_locationsInput>, providersUncheckedUpdateWithoutProvider_locationsInput>
  }

  export type zonesUpdateOneWithoutProvider_locationsNestedInput = {
    create?: XOR<zonesCreateWithoutProvider_locationsInput, zonesUncheckedCreateWithoutProvider_locationsInput>
    connectOrCreate?: zonesCreateOrConnectWithoutProvider_locationsInput
    upsert?: zonesUpsertWithoutProvider_locationsInput
    disconnect?: zonesWhereInput | boolean
    delete?: zonesWhereInput | boolean
    connect?: zonesWhereUniqueInput
    update?: XOR<XOR<zonesUpdateToOneWithWhereWithoutProvider_locationsInput, zonesUpdateWithoutProvider_locationsInput>, zonesUncheckedUpdateWithoutProvider_locationsInput>
  }

  export type provider_locationsCreateNestedManyWithoutProvidersInput = {
    create?: XOR<provider_locationsCreateWithoutProvidersInput, provider_locationsUncheckedCreateWithoutProvidersInput> | provider_locationsCreateWithoutProvidersInput[] | provider_locationsUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: provider_locationsCreateOrConnectWithoutProvidersInput | provider_locationsCreateOrConnectWithoutProvidersInput[]
    createMany?: provider_locationsCreateManyProvidersInputEnvelope
    connect?: provider_locationsWhereUniqueInput | provider_locationsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutProvidersInput = {
    create?: XOR<usersCreateWithoutProvidersInput, usersUncheckedCreateWithoutProvidersInput>
    connectOrCreate?: usersCreateOrConnectWithoutProvidersInput
    connect?: usersWhereUniqueInput
  }

  export type reviewsCreateNestedManyWithoutProvidersInput = {
    create?: XOR<reviewsCreateWithoutProvidersInput, reviewsUncheckedCreateWithoutProvidersInput> | reviewsCreateWithoutProvidersInput[] | reviewsUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutProvidersInput | reviewsCreateOrConnectWithoutProvidersInput[]
    createMany?: reviewsCreateManyProvidersInputEnvelope
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
  }

  export type servicesCreateNestedManyWithoutProvidersInput = {
    create?: XOR<servicesCreateWithoutProvidersInput, servicesUncheckedCreateWithoutProvidersInput> | servicesCreateWithoutProvidersInput[] | servicesUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: servicesCreateOrConnectWithoutProvidersInput | servicesCreateOrConnectWithoutProvidersInput[]
    createMany?: servicesCreateManyProvidersInputEnvelope
    connect?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
  }

  export type provider_locationsUncheckedCreateNestedManyWithoutProvidersInput = {
    create?: XOR<provider_locationsCreateWithoutProvidersInput, provider_locationsUncheckedCreateWithoutProvidersInput> | provider_locationsCreateWithoutProvidersInput[] | provider_locationsUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: provider_locationsCreateOrConnectWithoutProvidersInput | provider_locationsCreateOrConnectWithoutProvidersInput[]
    createMany?: provider_locationsCreateManyProvidersInputEnvelope
    connect?: provider_locationsWhereUniqueInput | provider_locationsWhereUniqueInput[]
  }

  export type reviewsUncheckedCreateNestedManyWithoutProvidersInput = {
    create?: XOR<reviewsCreateWithoutProvidersInput, reviewsUncheckedCreateWithoutProvidersInput> | reviewsCreateWithoutProvidersInput[] | reviewsUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutProvidersInput | reviewsCreateOrConnectWithoutProvidersInput[]
    createMany?: reviewsCreateManyProvidersInputEnvelope
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
  }

  export type servicesUncheckedCreateNestedManyWithoutProvidersInput = {
    create?: XOR<servicesCreateWithoutProvidersInput, servicesUncheckedCreateWithoutProvidersInput> | servicesCreateWithoutProvidersInput[] | servicesUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: servicesCreateOrConnectWithoutProvidersInput | servicesCreateOrConnectWithoutProvidersInput[]
    createMany?: servicesCreateManyProvidersInputEnvelope
    connect?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
  }

  export type EnumProviderTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProviderType
  }

  export type provider_locationsUpdateManyWithoutProvidersNestedInput = {
    create?: XOR<provider_locationsCreateWithoutProvidersInput, provider_locationsUncheckedCreateWithoutProvidersInput> | provider_locationsCreateWithoutProvidersInput[] | provider_locationsUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: provider_locationsCreateOrConnectWithoutProvidersInput | provider_locationsCreateOrConnectWithoutProvidersInput[]
    upsert?: provider_locationsUpsertWithWhereUniqueWithoutProvidersInput | provider_locationsUpsertWithWhereUniqueWithoutProvidersInput[]
    createMany?: provider_locationsCreateManyProvidersInputEnvelope
    set?: provider_locationsWhereUniqueInput | provider_locationsWhereUniqueInput[]
    disconnect?: provider_locationsWhereUniqueInput | provider_locationsWhereUniqueInput[]
    delete?: provider_locationsWhereUniqueInput | provider_locationsWhereUniqueInput[]
    connect?: provider_locationsWhereUniqueInput | provider_locationsWhereUniqueInput[]
    update?: provider_locationsUpdateWithWhereUniqueWithoutProvidersInput | provider_locationsUpdateWithWhereUniqueWithoutProvidersInput[]
    updateMany?: provider_locationsUpdateManyWithWhereWithoutProvidersInput | provider_locationsUpdateManyWithWhereWithoutProvidersInput[]
    deleteMany?: provider_locationsScalarWhereInput | provider_locationsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutProvidersNestedInput = {
    create?: XOR<usersCreateWithoutProvidersInput, usersUncheckedCreateWithoutProvidersInput>
    connectOrCreate?: usersCreateOrConnectWithoutProvidersInput
    upsert?: usersUpsertWithoutProvidersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutProvidersInput, usersUpdateWithoutProvidersInput>, usersUncheckedUpdateWithoutProvidersInput>
  }

  export type reviewsUpdateManyWithoutProvidersNestedInput = {
    create?: XOR<reviewsCreateWithoutProvidersInput, reviewsUncheckedCreateWithoutProvidersInput> | reviewsCreateWithoutProvidersInput[] | reviewsUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutProvidersInput | reviewsCreateOrConnectWithoutProvidersInput[]
    upsert?: reviewsUpsertWithWhereUniqueWithoutProvidersInput | reviewsUpsertWithWhereUniqueWithoutProvidersInput[]
    createMany?: reviewsCreateManyProvidersInputEnvelope
    set?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    disconnect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    delete?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    update?: reviewsUpdateWithWhereUniqueWithoutProvidersInput | reviewsUpdateWithWhereUniqueWithoutProvidersInput[]
    updateMany?: reviewsUpdateManyWithWhereWithoutProvidersInput | reviewsUpdateManyWithWhereWithoutProvidersInput[]
    deleteMany?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
  }

  export type servicesUpdateManyWithoutProvidersNestedInput = {
    create?: XOR<servicesCreateWithoutProvidersInput, servicesUncheckedCreateWithoutProvidersInput> | servicesCreateWithoutProvidersInput[] | servicesUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: servicesCreateOrConnectWithoutProvidersInput | servicesCreateOrConnectWithoutProvidersInput[]
    upsert?: servicesUpsertWithWhereUniqueWithoutProvidersInput | servicesUpsertWithWhereUniqueWithoutProvidersInput[]
    createMany?: servicesCreateManyProvidersInputEnvelope
    set?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    disconnect?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    delete?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    connect?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    update?: servicesUpdateWithWhereUniqueWithoutProvidersInput | servicesUpdateWithWhereUniqueWithoutProvidersInput[]
    updateMany?: servicesUpdateManyWithWhereWithoutProvidersInput | servicesUpdateManyWithWhereWithoutProvidersInput[]
    deleteMany?: servicesScalarWhereInput | servicesScalarWhereInput[]
  }

  export type provider_locationsUncheckedUpdateManyWithoutProvidersNestedInput = {
    create?: XOR<provider_locationsCreateWithoutProvidersInput, provider_locationsUncheckedCreateWithoutProvidersInput> | provider_locationsCreateWithoutProvidersInput[] | provider_locationsUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: provider_locationsCreateOrConnectWithoutProvidersInput | provider_locationsCreateOrConnectWithoutProvidersInput[]
    upsert?: provider_locationsUpsertWithWhereUniqueWithoutProvidersInput | provider_locationsUpsertWithWhereUniqueWithoutProvidersInput[]
    createMany?: provider_locationsCreateManyProvidersInputEnvelope
    set?: provider_locationsWhereUniqueInput | provider_locationsWhereUniqueInput[]
    disconnect?: provider_locationsWhereUniqueInput | provider_locationsWhereUniqueInput[]
    delete?: provider_locationsWhereUniqueInput | provider_locationsWhereUniqueInput[]
    connect?: provider_locationsWhereUniqueInput | provider_locationsWhereUniqueInput[]
    update?: provider_locationsUpdateWithWhereUniqueWithoutProvidersInput | provider_locationsUpdateWithWhereUniqueWithoutProvidersInput[]
    updateMany?: provider_locationsUpdateManyWithWhereWithoutProvidersInput | provider_locationsUpdateManyWithWhereWithoutProvidersInput[]
    deleteMany?: provider_locationsScalarWhereInput | provider_locationsScalarWhereInput[]
  }

  export type reviewsUncheckedUpdateManyWithoutProvidersNestedInput = {
    create?: XOR<reviewsCreateWithoutProvidersInput, reviewsUncheckedCreateWithoutProvidersInput> | reviewsCreateWithoutProvidersInput[] | reviewsUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutProvidersInput | reviewsCreateOrConnectWithoutProvidersInput[]
    upsert?: reviewsUpsertWithWhereUniqueWithoutProvidersInput | reviewsUpsertWithWhereUniqueWithoutProvidersInput[]
    createMany?: reviewsCreateManyProvidersInputEnvelope
    set?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    disconnect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    delete?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    update?: reviewsUpdateWithWhereUniqueWithoutProvidersInput | reviewsUpdateWithWhereUniqueWithoutProvidersInput[]
    updateMany?: reviewsUpdateManyWithWhereWithoutProvidersInput | reviewsUpdateManyWithWhereWithoutProvidersInput[]
    deleteMany?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
  }

  export type servicesUncheckedUpdateManyWithoutProvidersNestedInput = {
    create?: XOR<servicesCreateWithoutProvidersInput, servicesUncheckedCreateWithoutProvidersInput> | servicesCreateWithoutProvidersInput[] | servicesUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: servicesCreateOrConnectWithoutProvidersInput | servicesCreateOrConnectWithoutProvidersInput[]
    upsert?: servicesUpsertWithWhereUniqueWithoutProvidersInput | servicesUpsertWithWhereUniqueWithoutProvidersInput[]
    createMany?: servicesCreateManyProvidersInputEnvelope
    set?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    disconnect?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    delete?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    connect?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    update?: servicesUpdateWithWhereUniqueWithoutProvidersInput | servicesUpdateWithWhereUniqueWithoutProvidersInput[]
    updateMany?: servicesUpdateManyWithWhereWithoutProvidersInput | servicesUpdateManyWithWhereWithoutProvidersInput[]
    deleteMany?: servicesScalarWhereInput | servicesScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutReport_schedulesInput = {
    create?: XOR<usersCreateWithoutReport_schedulesInput, usersUncheckedCreateWithoutReport_schedulesInput>
    connectOrCreate?: usersCreateOrConnectWithoutReport_schedulesInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutReport_schedulesNestedInput = {
    create?: XOR<usersCreateWithoutReport_schedulesInput, usersUncheckedCreateWithoutReport_schedulesInput>
    connectOrCreate?: usersCreateOrConnectWithoutReport_schedulesInput
    upsert?: usersUpsertWithoutReport_schedulesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutReport_schedulesInput, usersUpdateWithoutReport_schedulesInput>, usersUncheckedUpdateWithoutReport_schedulesInput>
  }

  export type ordersCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ordersCreateWithoutReviewsInput, ordersUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ordersCreateOrConnectWithoutReviewsInput
    connect?: ordersWhereUniqueInput
  }

  export type providersCreateNestedOneWithoutReviewsInput = {
    create?: XOR<providersCreateWithoutReviewsInput, providersUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: providersCreateOrConnectWithoutReviewsInput
    connect?: providersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutReviews_reviews_revieweeIdTousersInput = {
    create?: XOR<usersCreateWithoutReviews_reviews_revieweeIdTousersInput, usersUncheckedCreateWithoutReviews_reviews_revieweeIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutReviews_reviews_revieweeIdTousersInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutReviews_reviews_reviewerIdTousersInput = {
    create?: XOR<usersCreateWithoutReviews_reviews_reviewerIdTousersInput, usersUncheckedCreateWithoutReviews_reviews_reviewerIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutReviews_reviews_reviewerIdTousersInput
    connect?: usersWhereUniqueInput
  }

  export type ordersUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<ordersCreateWithoutReviewsInput, ordersUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ordersCreateOrConnectWithoutReviewsInput
    upsert?: ordersUpsertWithoutReviewsInput
    connect?: ordersWhereUniqueInput
    update?: XOR<XOR<ordersUpdateToOneWithWhereWithoutReviewsInput, ordersUpdateWithoutReviewsInput>, ordersUncheckedUpdateWithoutReviewsInput>
  }

  export type providersUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<providersCreateWithoutReviewsInput, providersUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: providersCreateOrConnectWithoutReviewsInput
    upsert?: providersUpsertWithoutReviewsInput
    disconnect?: providersWhereInput | boolean
    delete?: providersWhereInput | boolean
    connect?: providersWhereUniqueInput
    update?: XOR<XOR<providersUpdateToOneWithWhereWithoutReviewsInput, providersUpdateWithoutReviewsInput>, providersUncheckedUpdateWithoutReviewsInput>
  }

  export type usersUpdateOneRequiredWithoutReviews_reviews_revieweeIdTousersNestedInput = {
    create?: XOR<usersCreateWithoutReviews_reviews_revieweeIdTousersInput, usersUncheckedCreateWithoutReviews_reviews_revieweeIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutReviews_reviews_revieweeIdTousersInput
    upsert?: usersUpsertWithoutReviews_reviews_revieweeIdTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutReviews_reviews_revieweeIdTousersInput, usersUpdateWithoutReviews_reviews_revieweeIdTousersInput>, usersUncheckedUpdateWithoutReviews_reviews_revieweeIdTousersInput>
  }

  export type usersUpdateOneRequiredWithoutReviews_reviews_reviewerIdTousersNestedInput = {
    create?: XOR<usersCreateWithoutReviews_reviews_reviewerIdTousersInput, usersUncheckedCreateWithoutReviews_reviews_reviewerIdTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutReviews_reviews_reviewerIdTousersInput
    upsert?: usersUpsertWithoutReviews_reviews_reviewerIdTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutReviews_reviews_reviewerIdTousersInput, usersUpdateWithoutReviews_reviews_reviewerIdTousersInput>, usersUncheckedUpdateWithoutReviews_reviews_reviewerIdTousersInput>
  }

  export type ordersCreateNestedManyWithoutServicesInput = {
    create?: XOR<ordersCreateWithoutServicesInput, ordersUncheckedCreateWithoutServicesInput> | ordersCreateWithoutServicesInput[] | ordersUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutServicesInput | ordersCreateOrConnectWithoutServicesInput[]
    createMany?: ordersCreateManyServicesInputEnvelope
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
  }

  export type providersCreateNestedOneWithoutServicesInput = {
    create?: XOR<providersCreateWithoutServicesInput, providersUncheckedCreateWithoutServicesInput>
    connectOrCreate?: providersCreateOrConnectWithoutServicesInput
    connect?: providersWhereUniqueInput
  }

  export type ordersUncheckedCreateNestedManyWithoutServicesInput = {
    create?: XOR<ordersCreateWithoutServicesInput, ordersUncheckedCreateWithoutServicesInput> | ordersCreateWithoutServicesInput[] | ordersUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutServicesInput | ordersCreateOrConnectWithoutServicesInput[]
    createMany?: ordersCreateManyServicesInputEnvelope
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ordersUpdateManyWithoutServicesNestedInput = {
    create?: XOR<ordersCreateWithoutServicesInput, ordersUncheckedCreateWithoutServicesInput> | ordersCreateWithoutServicesInput[] | ordersUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutServicesInput | ordersCreateOrConnectWithoutServicesInput[]
    upsert?: ordersUpsertWithWhereUniqueWithoutServicesInput | ordersUpsertWithWhereUniqueWithoutServicesInput[]
    createMany?: ordersCreateManyServicesInputEnvelope
    set?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    disconnect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    delete?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    update?: ordersUpdateWithWhereUniqueWithoutServicesInput | ordersUpdateWithWhereUniqueWithoutServicesInput[]
    updateMany?: ordersUpdateManyWithWhereWithoutServicesInput | ordersUpdateManyWithWhereWithoutServicesInput[]
    deleteMany?: ordersScalarWhereInput | ordersScalarWhereInput[]
  }

  export type providersUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<providersCreateWithoutServicesInput, providersUncheckedCreateWithoutServicesInput>
    connectOrCreate?: providersCreateOrConnectWithoutServicesInput
    upsert?: providersUpsertWithoutServicesInput
    connect?: providersWhereUniqueInput
    update?: XOR<XOR<providersUpdateToOneWithWhereWithoutServicesInput, providersUpdateWithoutServicesInput>, providersUncheckedUpdateWithoutServicesInput>
  }

  export type ordersUncheckedUpdateManyWithoutServicesNestedInput = {
    create?: XOR<ordersCreateWithoutServicesInput, ordersUncheckedCreateWithoutServicesInput> | ordersCreateWithoutServicesInput[] | ordersUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutServicesInput | ordersCreateOrConnectWithoutServicesInput[]
    upsert?: ordersUpsertWithWhereUniqueWithoutServicesInput | ordersUpsertWithWhereUniqueWithoutServicesInput[]
    createMany?: ordersCreateManyServicesInputEnvelope
    set?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    disconnect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    delete?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    update?: ordersUpdateWithWhereUniqueWithoutServicesInput | ordersUpdateWithWhereUniqueWithoutServicesInput[]
    updateMany?: ordersUpdateManyWithWhereWithoutServicesInput | ordersUpdateManyWithWhereWithoutServicesInput[]
    deleteMany?: ordersScalarWhereInput | ordersScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutTicketsInput = {
    create?: XOR<usersCreateWithoutTicketsInput, usersUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTicketsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<usersCreateWithoutTicketsInput, usersUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTicketsInput
    upsert?: usersUpsertWithoutTicketsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTicketsInput, usersUpdateWithoutTicketsInput>, usersUncheckedUpdateWithoutTicketsInput>
  }

  export type walletsCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<walletsCreateWithoutTransactionsInput, walletsUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: walletsCreateOrConnectWithoutTransactionsInput
    connect?: walletsWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type NullableEnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod | null
  }

  export type walletsUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<walletsCreateWithoutTransactionsInput, walletsUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: walletsCreateOrConnectWithoutTransactionsInput
    upsert?: walletsUpsertWithoutTransactionsInput
    connect?: walletsWhereUniqueInput
    update?: XOR<XOR<walletsUpdateToOneWithWhereWithoutTransactionsInput, walletsUpdateWithoutTransactionsInput>, walletsUncheckedUpdateWithoutTransactionsInput>
  }

  export type usersCreateNestedOneWithoutUser_payment_methodsInput = {
    create?: XOR<usersCreateWithoutUser_payment_methodsInput, usersUncheckedCreateWithoutUser_payment_methodsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_payment_methodsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutUser_payment_methodsNestedInput = {
    create?: XOR<usersCreateWithoutUser_payment_methodsInput, usersUncheckedCreateWithoutUser_payment_methodsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_payment_methodsInput
    upsert?: usersUpsertWithoutUser_payment_methodsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_payment_methodsInput, usersUpdateWithoutUser_payment_methodsInput>, usersUncheckedUpdateWithoutUser_payment_methodsInput>
  }

  export type usersCreateNestedOneWithoutUser_verificationsInput = {
    create?: XOR<usersCreateWithoutUser_verificationsInput, usersUncheckedCreateWithoutUser_verificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_verificationsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutUser_verificationsNestedInput = {
    create?: XOR<usersCreateWithoutUser_verificationsInput, usersUncheckedCreateWithoutUser_verificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_verificationsInput
    upsert?: usersUpsertWithoutUser_verificationsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_verificationsInput, usersUpdateWithoutUser_verificationsInput>, usersUncheckedUpdateWithoutUser_verificationsInput>
  }

  export type admin_actionsCreateNestedManyWithoutUsersInput = {
    create?: XOR<admin_actionsCreateWithoutUsersInput, admin_actionsUncheckedCreateWithoutUsersInput> | admin_actionsCreateWithoutUsersInput[] | admin_actionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: admin_actionsCreateOrConnectWithoutUsersInput | admin_actionsCreateOrConnectWithoutUsersInput[]
    createMany?: admin_actionsCreateManyUsersInputEnvelope
    connect?: admin_actionsWhereUniqueInput | admin_actionsWhereUniqueInput[]
  }

  export type call_sessionsCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput = {
    create?: XOR<call_sessionsCreateWithoutUsers_call_sessions_customerIdTousersInput, call_sessionsUncheckedCreateWithoutUsers_call_sessions_customerIdTousersInput> | call_sessionsCreateWithoutUsers_call_sessions_customerIdTousersInput[] | call_sessionsUncheckedCreateWithoutUsers_call_sessions_customerIdTousersInput[]
    connectOrCreate?: call_sessionsCreateOrConnectWithoutUsers_call_sessions_customerIdTousersInput | call_sessionsCreateOrConnectWithoutUsers_call_sessions_customerIdTousersInput[]
    createMany?: call_sessionsCreateManyUsers_call_sessions_customerIdTousersInputEnvelope
    connect?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
  }

  export type call_sessionsCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput = {
    create?: XOR<call_sessionsCreateWithoutUsers_call_sessions_providerIdTousersInput, call_sessionsUncheckedCreateWithoutUsers_call_sessions_providerIdTousersInput> | call_sessionsCreateWithoutUsers_call_sessions_providerIdTousersInput[] | call_sessionsUncheckedCreateWithoutUsers_call_sessions_providerIdTousersInput[]
    connectOrCreate?: call_sessionsCreateOrConnectWithoutUsers_call_sessions_providerIdTousersInput | call_sessionsCreateOrConnectWithoutUsers_call_sessions_providerIdTousersInput[]
    createMany?: call_sessionsCreateManyUsers_call_sessions_providerIdTousersInputEnvelope
    connect?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
  }

  export type messagesCreateNestedManyWithoutUsers_messages_receiverIdTousersInput = {
    create?: XOR<messagesCreateWithoutUsers_messages_receiverIdTousersInput, messagesUncheckedCreateWithoutUsers_messages_receiverIdTousersInput> | messagesCreateWithoutUsers_messages_receiverIdTousersInput[] | messagesUncheckedCreateWithoutUsers_messages_receiverIdTousersInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUsers_messages_receiverIdTousersInput | messagesCreateOrConnectWithoutUsers_messages_receiverIdTousersInput[]
    createMany?: messagesCreateManyUsers_messages_receiverIdTousersInputEnvelope
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
  }

  export type messagesCreateNestedManyWithoutUsers_messages_senderIdTousersInput = {
    create?: XOR<messagesCreateWithoutUsers_messages_senderIdTousersInput, messagesUncheckedCreateWithoutUsers_messages_senderIdTousersInput> | messagesCreateWithoutUsers_messages_senderIdTousersInput[] | messagesUncheckedCreateWithoutUsers_messages_senderIdTousersInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUsers_messages_senderIdTousersInput | messagesCreateOrConnectWithoutUsers_messages_senderIdTousersInput[]
    createMany?: messagesCreateManyUsers_messages_senderIdTousersInputEnvelope
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
  }

  export type notification_preferencesCreateNestedOneWithoutUsersInput = {
    create?: XOR<notification_preferencesCreateWithoutUsersInput, notification_preferencesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: notification_preferencesCreateOrConnectWithoutUsersInput
    connect?: notification_preferencesWhereUniqueInput
  }

  export type notification_tokensCreateNestedManyWithoutUsersInput = {
    create?: XOR<notification_tokensCreateWithoutUsersInput, notification_tokensUncheckedCreateWithoutUsersInput> | notification_tokensCreateWithoutUsersInput[] | notification_tokensUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notification_tokensCreateOrConnectWithoutUsersInput | notification_tokensCreateOrConnectWithoutUsersInput[]
    createMany?: notification_tokensCreateManyUsersInputEnvelope
    connect?: notification_tokensWhereUniqueInput | notification_tokensWhereUniqueInput[]
  }

  export type notificationsCreateNestedManyWithoutUsersInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type ordersCreateNestedManyWithoutUsers_orders_customerIdTousersInput = {
    create?: XOR<ordersCreateWithoutUsers_orders_customerIdTousersInput, ordersUncheckedCreateWithoutUsers_orders_customerIdTousersInput> | ordersCreateWithoutUsers_orders_customerIdTousersInput[] | ordersUncheckedCreateWithoutUsers_orders_customerIdTousersInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutUsers_orders_customerIdTousersInput | ordersCreateOrConnectWithoutUsers_orders_customerIdTousersInput[]
    createMany?: ordersCreateManyUsers_orders_customerIdTousersInputEnvelope
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
  }

  export type ordersCreateNestedManyWithoutUsers_orders_providerIdTousersInput = {
    create?: XOR<ordersCreateWithoutUsers_orders_providerIdTousersInput, ordersUncheckedCreateWithoutUsers_orders_providerIdTousersInput> | ordersCreateWithoutUsers_orders_providerIdTousersInput[] | ordersUncheckedCreateWithoutUsers_orders_providerIdTousersInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutUsers_orders_providerIdTousersInput | ordersCreateOrConnectWithoutUsers_orders_providerIdTousersInput[]
    createMany?: ordersCreateManyUsers_orders_providerIdTousersInputEnvelope
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
  }

  export type otpsCreateNestedManyWithoutUsersInput = {
    create?: XOR<otpsCreateWithoutUsersInput, otpsUncheckedCreateWithoutUsersInput> | otpsCreateWithoutUsersInput[] | otpsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: otpsCreateOrConnectWithoutUsersInput | otpsCreateOrConnectWithoutUsersInput[]
    createMany?: otpsCreateManyUsersInputEnvelope
    connect?: otpsWhereUniqueInput | otpsWhereUniqueInput[]
  }

  export type payment_ordersCreateNestedManyWithoutUsersInput = {
    create?: XOR<payment_ordersCreateWithoutUsersInput, payment_ordersUncheckedCreateWithoutUsersInput> | payment_ordersCreateWithoutUsersInput[] | payment_ordersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: payment_ordersCreateOrConnectWithoutUsersInput | payment_ordersCreateOrConnectWithoutUsersInput[]
    createMany?: payment_ordersCreateManyUsersInputEnvelope
    connect?: payment_ordersWhereUniqueInput | payment_ordersWhereUniqueInput[]
  }

  export type profilesCreateNestedOneWithoutUsersInput = {
    create?: XOR<profilesCreateWithoutUsersInput, profilesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: profilesCreateOrConnectWithoutUsersInput
    connect?: profilesWhereUniqueInput
  }

  export type providersCreateNestedOneWithoutUsersInput = {
    create?: XOR<providersCreateWithoutUsersInput, providersUncheckedCreateWithoutUsersInput>
    connectOrCreate?: providersCreateOrConnectWithoutUsersInput
    connect?: providersWhereUniqueInput
  }

  export type report_schedulesCreateNestedManyWithoutUsersInput = {
    create?: XOR<report_schedulesCreateWithoutUsersInput, report_schedulesUncheckedCreateWithoutUsersInput> | report_schedulesCreateWithoutUsersInput[] | report_schedulesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: report_schedulesCreateOrConnectWithoutUsersInput | report_schedulesCreateOrConnectWithoutUsersInput[]
    createMany?: report_schedulesCreateManyUsersInputEnvelope
    connect?: report_schedulesWhereUniqueInput | report_schedulesWhereUniqueInput[]
  }

  export type reviewsCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput = {
    create?: XOR<reviewsCreateWithoutUsers_reviews_revieweeIdTousersInput, reviewsUncheckedCreateWithoutUsers_reviews_revieweeIdTousersInput> | reviewsCreateWithoutUsers_reviews_revieweeIdTousersInput[] | reviewsUncheckedCreateWithoutUsers_reviews_revieweeIdTousersInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutUsers_reviews_revieweeIdTousersInput | reviewsCreateOrConnectWithoutUsers_reviews_revieweeIdTousersInput[]
    createMany?: reviewsCreateManyUsers_reviews_revieweeIdTousersInputEnvelope
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
  }

  export type reviewsCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput = {
    create?: XOR<reviewsCreateWithoutUsers_reviews_reviewerIdTousersInput, reviewsUncheckedCreateWithoutUsers_reviews_reviewerIdTousersInput> | reviewsCreateWithoutUsers_reviews_reviewerIdTousersInput[] | reviewsUncheckedCreateWithoutUsers_reviews_reviewerIdTousersInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutUsers_reviews_reviewerIdTousersInput | reviewsCreateOrConnectWithoutUsers_reviews_reviewerIdTousersInput[]
    createMany?: reviewsCreateManyUsers_reviews_reviewerIdTousersInputEnvelope
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
  }

  export type ticketsCreateNestedManyWithoutUsersInput = {
    create?: XOR<ticketsCreateWithoutUsersInput, ticketsUncheckedCreateWithoutUsersInput> | ticketsCreateWithoutUsersInput[] | ticketsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ticketsCreateOrConnectWithoutUsersInput | ticketsCreateOrConnectWithoutUsersInput[]
    createMany?: ticketsCreateManyUsersInputEnvelope
    connect?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
  }

  export type user_payment_methodsCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_payment_methodsCreateWithoutUsersInput, user_payment_methodsUncheckedCreateWithoutUsersInput> | user_payment_methodsCreateWithoutUsersInput[] | user_payment_methodsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_payment_methodsCreateOrConnectWithoutUsersInput | user_payment_methodsCreateOrConnectWithoutUsersInput[]
    createMany?: user_payment_methodsCreateManyUsersInputEnvelope
    connect?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
  }

  export type user_verificationsCreateNestedOneWithoutUsersInput = {
    create?: XOR<user_verificationsCreateWithoutUsersInput, user_verificationsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: user_verificationsCreateOrConnectWithoutUsersInput
    connect?: user_verificationsWhereUniqueInput
  }

  export type walletsCreateNestedOneWithoutUsersInput = {
    create?: XOR<walletsCreateWithoutUsersInput, walletsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: walletsCreateOrConnectWithoutUsersInput
    connect?: walletsWhereUniqueInput
  }

  export type admin_actionsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<admin_actionsCreateWithoutUsersInput, admin_actionsUncheckedCreateWithoutUsersInput> | admin_actionsCreateWithoutUsersInput[] | admin_actionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: admin_actionsCreateOrConnectWithoutUsersInput | admin_actionsCreateOrConnectWithoutUsersInput[]
    createMany?: admin_actionsCreateManyUsersInputEnvelope
    connect?: admin_actionsWhereUniqueInput | admin_actionsWhereUniqueInput[]
  }

  export type call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput = {
    create?: XOR<call_sessionsCreateWithoutUsers_call_sessions_customerIdTousersInput, call_sessionsUncheckedCreateWithoutUsers_call_sessions_customerIdTousersInput> | call_sessionsCreateWithoutUsers_call_sessions_customerIdTousersInput[] | call_sessionsUncheckedCreateWithoutUsers_call_sessions_customerIdTousersInput[]
    connectOrCreate?: call_sessionsCreateOrConnectWithoutUsers_call_sessions_customerIdTousersInput | call_sessionsCreateOrConnectWithoutUsers_call_sessions_customerIdTousersInput[]
    createMany?: call_sessionsCreateManyUsers_call_sessions_customerIdTousersInputEnvelope
    connect?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
  }

  export type call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput = {
    create?: XOR<call_sessionsCreateWithoutUsers_call_sessions_providerIdTousersInput, call_sessionsUncheckedCreateWithoutUsers_call_sessions_providerIdTousersInput> | call_sessionsCreateWithoutUsers_call_sessions_providerIdTousersInput[] | call_sessionsUncheckedCreateWithoutUsers_call_sessions_providerIdTousersInput[]
    connectOrCreate?: call_sessionsCreateOrConnectWithoutUsers_call_sessions_providerIdTousersInput | call_sessionsCreateOrConnectWithoutUsers_call_sessions_providerIdTousersInput[]
    createMany?: call_sessionsCreateManyUsers_call_sessions_providerIdTousersInputEnvelope
    connect?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
  }

  export type messagesUncheckedCreateNestedManyWithoutUsers_messages_receiverIdTousersInput = {
    create?: XOR<messagesCreateWithoutUsers_messages_receiverIdTousersInput, messagesUncheckedCreateWithoutUsers_messages_receiverIdTousersInput> | messagesCreateWithoutUsers_messages_receiverIdTousersInput[] | messagesUncheckedCreateWithoutUsers_messages_receiverIdTousersInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUsers_messages_receiverIdTousersInput | messagesCreateOrConnectWithoutUsers_messages_receiverIdTousersInput[]
    createMany?: messagesCreateManyUsers_messages_receiverIdTousersInputEnvelope
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
  }

  export type messagesUncheckedCreateNestedManyWithoutUsers_messages_senderIdTousersInput = {
    create?: XOR<messagesCreateWithoutUsers_messages_senderIdTousersInput, messagesUncheckedCreateWithoutUsers_messages_senderIdTousersInput> | messagesCreateWithoutUsers_messages_senderIdTousersInput[] | messagesUncheckedCreateWithoutUsers_messages_senderIdTousersInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUsers_messages_senderIdTousersInput | messagesCreateOrConnectWithoutUsers_messages_senderIdTousersInput[]
    createMany?: messagesCreateManyUsers_messages_senderIdTousersInputEnvelope
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
  }

  export type notification_preferencesUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<notification_preferencesCreateWithoutUsersInput, notification_preferencesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: notification_preferencesCreateOrConnectWithoutUsersInput
    connect?: notification_preferencesWhereUniqueInput
  }

  export type notification_tokensUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<notification_tokensCreateWithoutUsersInput, notification_tokensUncheckedCreateWithoutUsersInput> | notification_tokensCreateWithoutUsersInput[] | notification_tokensUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notification_tokensCreateOrConnectWithoutUsersInput | notification_tokensCreateOrConnectWithoutUsersInput[]
    createMany?: notification_tokensCreateManyUsersInputEnvelope
    connect?: notification_tokensWhereUniqueInput | notification_tokensWhereUniqueInput[]
  }

  export type notificationsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type ordersUncheckedCreateNestedManyWithoutUsers_orders_customerIdTousersInput = {
    create?: XOR<ordersCreateWithoutUsers_orders_customerIdTousersInput, ordersUncheckedCreateWithoutUsers_orders_customerIdTousersInput> | ordersCreateWithoutUsers_orders_customerIdTousersInput[] | ordersUncheckedCreateWithoutUsers_orders_customerIdTousersInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutUsers_orders_customerIdTousersInput | ordersCreateOrConnectWithoutUsers_orders_customerIdTousersInput[]
    createMany?: ordersCreateManyUsers_orders_customerIdTousersInputEnvelope
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
  }

  export type ordersUncheckedCreateNestedManyWithoutUsers_orders_providerIdTousersInput = {
    create?: XOR<ordersCreateWithoutUsers_orders_providerIdTousersInput, ordersUncheckedCreateWithoutUsers_orders_providerIdTousersInput> | ordersCreateWithoutUsers_orders_providerIdTousersInput[] | ordersUncheckedCreateWithoutUsers_orders_providerIdTousersInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutUsers_orders_providerIdTousersInput | ordersCreateOrConnectWithoutUsers_orders_providerIdTousersInput[]
    createMany?: ordersCreateManyUsers_orders_providerIdTousersInputEnvelope
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
  }

  export type otpsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<otpsCreateWithoutUsersInput, otpsUncheckedCreateWithoutUsersInput> | otpsCreateWithoutUsersInput[] | otpsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: otpsCreateOrConnectWithoutUsersInput | otpsCreateOrConnectWithoutUsersInput[]
    createMany?: otpsCreateManyUsersInputEnvelope
    connect?: otpsWhereUniqueInput | otpsWhereUniqueInput[]
  }

  export type payment_ordersUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<payment_ordersCreateWithoutUsersInput, payment_ordersUncheckedCreateWithoutUsersInput> | payment_ordersCreateWithoutUsersInput[] | payment_ordersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: payment_ordersCreateOrConnectWithoutUsersInput | payment_ordersCreateOrConnectWithoutUsersInput[]
    createMany?: payment_ordersCreateManyUsersInputEnvelope
    connect?: payment_ordersWhereUniqueInput | payment_ordersWhereUniqueInput[]
  }

  export type profilesUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<profilesCreateWithoutUsersInput, profilesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: profilesCreateOrConnectWithoutUsersInput
    connect?: profilesWhereUniqueInput
  }

  export type providersUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<providersCreateWithoutUsersInput, providersUncheckedCreateWithoutUsersInput>
    connectOrCreate?: providersCreateOrConnectWithoutUsersInput
    connect?: providersWhereUniqueInput
  }

  export type report_schedulesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<report_schedulesCreateWithoutUsersInput, report_schedulesUncheckedCreateWithoutUsersInput> | report_schedulesCreateWithoutUsersInput[] | report_schedulesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: report_schedulesCreateOrConnectWithoutUsersInput | report_schedulesCreateOrConnectWithoutUsersInput[]
    createMany?: report_schedulesCreateManyUsersInputEnvelope
    connect?: report_schedulesWhereUniqueInput | report_schedulesWhereUniqueInput[]
  }

  export type reviewsUncheckedCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput = {
    create?: XOR<reviewsCreateWithoutUsers_reviews_revieweeIdTousersInput, reviewsUncheckedCreateWithoutUsers_reviews_revieweeIdTousersInput> | reviewsCreateWithoutUsers_reviews_revieweeIdTousersInput[] | reviewsUncheckedCreateWithoutUsers_reviews_revieweeIdTousersInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutUsers_reviews_revieweeIdTousersInput | reviewsCreateOrConnectWithoutUsers_reviews_revieweeIdTousersInput[]
    createMany?: reviewsCreateManyUsers_reviews_revieweeIdTousersInputEnvelope
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
  }

  export type reviewsUncheckedCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput = {
    create?: XOR<reviewsCreateWithoutUsers_reviews_reviewerIdTousersInput, reviewsUncheckedCreateWithoutUsers_reviews_reviewerIdTousersInput> | reviewsCreateWithoutUsers_reviews_reviewerIdTousersInput[] | reviewsUncheckedCreateWithoutUsers_reviews_reviewerIdTousersInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutUsers_reviews_reviewerIdTousersInput | reviewsCreateOrConnectWithoutUsers_reviews_reviewerIdTousersInput[]
    createMany?: reviewsCreateManyUsers_reviews_reviewerIdTousersInputEnvelope
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
  }

  export type ticketsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<ticketsCreateWithoutUsersInput, ticketsUncheckedCreateWithoutUsersInput> | ticketsCreateWithoutUsersInput[] | ticketsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ticketsCreateOrConnectWithoutUsersInput | ticketsCreateOrConnectWithoutUsersInput[]
    createMany?: ticketsCreateManyUsersInputEnvelope
    connect?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
  }

  export type user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_payment_methodsCreateWithoutUsersInput, user_payment_methodsUncheckedCreateWithoutUsersInput> | user_payment_methodsCreateWithoutUsersInput[] | user_payment_methodsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_payment_methodsCreateOrConnectWithoutUsersInput | user_payment_methodsCreateOrConnectWithoutUsersInput[]
    createMany?: user_payment_methodsCreateManyUsersInputEnvelope
    connect?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
  }

  export type user_verificationsUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<user_verificationsCreateWithoutUsersInput, user_verificationsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: user_verificationsCreateOrConnectWithoutUsersInput
    connect?: user_verificationsWhereUniqueInput
  }

  export type walletsUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<walletsCreateWithoutUsersInput, walletsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: walletsCreateOrConnectWithoutUsersInput
    connect?: walletsWhereUniqueInput
  }

  export type EnumUserTypeFieldUpdateOperationsInput = {
    set?: $Enums.UserType
  }

  export type admin_actionsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<admin_actionsCreateWithoutUsersInput, admin_actionsUncheckedCreateWithoutUsersInput> | admin_actionsCreateWithoutUsersInput[] | admin_actionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: admin_actionsCreateOrConnectWithoutUsersInput | admin_actionsCreateOrConnectWithoutUsersInput[]
    upsert?: admin_actionsUpsertWithWhereUniqueWithoutUsersInput | admin_actionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: admin_actionsCreateManyUsersInputEnvelope
    set?: admin_actionsWhereUniqueInput | admin_actionsWhereUniqueInput[]
    disconnect?: admin_actionsWhereUniqueInput | admin_actionsWhereUniqueInput[]
    delete?: admin_actionsWhereUniqueInput | admin_actionsWhereUniqueInput[]
    connect?: admin_actionsWhereUniqueInput | admin_actionsWhereUniqueInput[]
    update?: admin_actionsUpdateWithWhereUniqueWithoutUsersInput | admin_actionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: admin_actionsUpdateManyWithWhereWithoutUsersInput | admin_actionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: admin_actionsScalarWhereInput | admin_actionsScalarWhereInput[]
  }

  export type call_sessionsUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput = {
    create?: XOR<call_sessionsCreateWithoutUsers_call_sessions_customerIdTousersInput, call_sessionsUncheckedCreateWithoutUsers_call_sessions_customerIdTousersInput> | call_sessionsCreateWithoutUsers_call_sessions_customerIdTousersInput[] | call_sessionsUncheckedCreateWithoutUsers_call_sessions_customerIdTousersInput[]
    connectOrCreate?: call_sessionsCreateOrConnectWithoutUsers_call_sessions_customerIdTousersInput | call_sessionsCreateOrConnectWithoutUsers_call_sessions_customerIdTousersInput[]
    upsert?: call_sessionsUpsertWithWhereUniqueWithoutUsers_call_sessions_customerIdTousersInput | call_sessionsUpsertWithWhereUniqueWithoutUsers_call_sessions_customerIdTousersInput[]
    createMany?: call_sessionsCreateManyUsers_call_sessions_customerIdTousersInputEnvelope
    set?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
    disconnect?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
    delete?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
    connect?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
    update?: call_sessionsUpdateWithWhereUniqueWithoutUsers_call_sessions_customerIdTousersInput | call_sessionsUpdateWithWhereUniqueWithoutUsers_call_sessions_customerIdTousersInput[]
    updateMany?: call_sessionsUpdateManyWithWhereWithoutUsers_call_sessions_customerIdTousersInput | call_sessionsUpdateManyWithWhereWithoutUsers_call_sessions_customerIdTousersInput[]
    deleteMany?: call_sessionsScalarWhereInput | call_sessionsScalarWhereInput[]
  }

  export type call_sessionsUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput = {
    create?: XOR<call_sessionsCreateWithoutUsers_call_sessions_providerIdTousersInput, call_sessionsUncheckedCreateWithoutUsers_call_sessions_providerIdTousersInput> | call_sessionsCreateWithoutUsers_call_sessions_providerIdTousersInput[] | call_sessionsUncheckedCreateWithoutUsers_call_sessions_providerIdTousersInput[]
    connectOrCreate?: call_sessionsCreateOrConnectWithoutUsers_call_sessions_providerIdTousersInput | call_sessionsCreateOrConnectWithoutUsers_call_sessions_providerIdTousersInput[]
    upsert?: call_sessionsUpsertWithWhereUniqueWithoutUsers_call_sessions_providerIdTousersInput | call_sessionsUpsertWithWhereUniqueWithoutUsers_call_sessions_providerIdTousersInput[]
    createMany?: call_sessionsCreateManyUsers_call_sessions_providerIdTousersInputEnvelope
    set?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
    disconnect?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
    delete?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
    connect?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
    update?: call_sessionsUpdateWithWhereUniqueWithoutUsers_call_sessions_providerIdTousersInput | call_sessionsUpdateWithWhereUniqueWithoutUsers_call_sessions_providerIdTousersInput[]
    updateMany?: call_sessionsUpdateManyWithWhereWithoutUsers_call_sessions_providerIdTousersInput | call_sessionsUpdateManyWithWhereWithoutUsers_call_sessions_providerIdTousersInput[]
    deleteMany?: call_sessionsScalarWhereInput | call_sessionsScalarWhereInput[]
  }

  export type messagesUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput = {
    create?: XOR<messagesCreateWithoutUsers_messages_receiverIdTousersInput, messagesUncheckedCreateWithoutUsers_messages_receiverIdTousersInput> | messagesCreateWithoutUsers_messages_receiverIdTousersInput[] | messagesUncheckedCreateWithoutUsers_messages_receiverIdTousersInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUsers_messages_receiverIdTousersInput | messagesCreateOrConnectWithoutUsers_messages_receiverIdTousersInput[]
    upsert?: messagesUpsertWithWhereUniqueWithoutUsers_messages_receiverIdTousersInput | messagesUpsertWithWhereUniqueWithoutUsers_messages_receiverIdTousersInput[]
    createMany?: messagesCreateManyUsers_messages_receiverIdTousersInputEnvelope
    set?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    disconnect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    delete?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    update?: messagesUpdateWithWhereUniqueWithoutUsers_messages_receiverIdTousersInput | messagesUpdateWithWhereUniqueWithoutUsers_messages_receiverIdTousersInput[]
    updateMany?: messagesUpdateManyWithWhereWithoutUsers_messages_receiverIdTousersInput | messagesUpdateManyWithWhereWithoutUsers_messages_receiverIdTousersInput[]
    deleteMany?: messagesScalarWhereInput | messagesScalarWhereInput[]
  }

  export type messagesUpdateManyWithoutUsers_messages_senderIdTousersNestedInput = {
    create?: XOR<messagesCreateWithoutUsers_messages_senderIdTousersInput, messagesUncheckedCreateWithoutUsers_messages_senderIdTousersInput> | messagesCreateWithoutUsers_messages_senderIdTousersInput[] | messagesUncheckedCreateWithoutUsers_messages_senderIdTousersInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUsers_messages_senderIdTousersInput | messagesCreateOrConnectWithoutUsers_messages_senderIdTousersInput[]
    upsert?: messagesUpsertWithWhereUniqueWithoutUsers_messages_senderIdTousersInput | messagesUpsertWithWhereUniqueWithoutUsers_messages_senderIdTousersInput[]
    createMany?: messagesCreateManyUsers_messages_senderIdTousersInputEnvelope
    set?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    disconnect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    delete?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    update?: messagesUpdateWithWhereUniqueWithoutUsers_messages_senderIdTousersInput | messagesUpdateWithWhereUniqueWithoutUsers_messages_senderIdTousersInput[]
    updateMany?: messagesUpdateManyWithWhereWithoutUsers_messages_senderIdTousersInput | messagesUpdateManyWithWhereWithoutUsers_messages_senderIdTousersInput[]
    deleteMany?: messagesScalarWhereInput | messagesScalarWhereInput[]
  }

  export type notification_preferencesUpdateOneWithoutUsersNestedInput = {
    create?: XOR<notification_preferencesCreateWithoutUsersInput, notification_preferencesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: notification_preferencesCreateOrConnectWithoutUsersInput
    upsert?: notification_preferencesUpsertWithoutUsersInput
    disconnect?: notification_preferencesWhereInput | boolean
    delete?: notification_preferencesWhereInput | boolean
    connect?: notification_preferencesWhereUniqueInput
    update?: XOR<XOR<notification_preferencesUpdateToOneWithWhereWithoutUsersInput, notification_preferencesUpdateWithoutUsersInput>, notification_preferencesUncheckedUpdateWithoutUsersInput>
  }

  export type notification_tokensUpdateManyWithoutUsersNestedInput = {
    create?: XOR<notification_tokensCreateWithoutUsersInput, notification_tokensUncheckedCreateWithoutUsersInput> | notification_tokensCreateWithoutUsersInput[] | notification_tokensUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notification_tokensCreateOrConnectWithoutUsersInput | notification_tokensCreateOrConnectWithoutUsersInput[]
    upsert?: notification_tokensUpsertWithWhereUniqueWithoutUsersInput | notification_tokensUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: notification_tokensCreateManyUsersInputEnvelope
    set?: notification_tokensWhereUniqueInput | notification_tokensWhereUniqueInput[]
    disconnect?: notification_tokensWhereUniqueInput | notification_tokensWhereUniqueInput[]
    delete?: notification_tokensWhereUniqueInput | notification_tokensWhereUniqueInput[]
    connect?: notification_tokensWhereUniqueInput | notification_tokensWhereUniqueInput[]
    update?: notification_tokensUpdateWithWhereUniqueWithoutUsersInput | notification_tokensUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: notification_tokensUpdateManyWithWhereWithoutUsersInput | notification_tokensUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: notification_tokensScalarWhereInput | notification_tokensScalarWhereInput[]
  }

  export type notificationsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutUsersInput | notificationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutUsersInput | notificationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutUsersInput | notificationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type ordersUpdateManyWithoutUsers_orders_customerIdTousersNestedInput = {
    create?: XOR<ordersCreateWithoutUsers_orders_customerIdTousersInput, ordersUncheckedCreateWithoutUsers_orders_customerIdTousersInput> | ordersCreateWithoutUsers_orders_customerIdTousersInput[] | ordersUncheckedCreateWithoutUsers_orders_customerIdTousersInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutUsers_orders_customerIdTousersInput | ordersCreateOrConnectWithoutUsers_orders_customerIdTousersInput[]
    upsert?: ordersUpsertWithWhereUniqueWithoutUsers_orders_customerIdTousersInput | ordersUpsertWithWhereUniqueWithoutUsers_orders_customerIdTousersInput[]
    createMany?: ordersCreateManyUsers_orders_customerIdTousersInputEnvelope
    set?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    disconnect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    delete?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    update?: ordersUpdateWithWhereUniqueWithoutUsers_orders_customerIdTousersInput | ordersUpdateWithWhereUniqueWithoutUsers_orders_customerIdTousersInput[]
    updateMany?: ordersUpdateManyWithWhereWithoutUsers_orders_customerIdTousersInput | ordersUpdateManyWithWhereWithoutUsers_orders_customerIdTousersInput[]
    deleteMany?: ordersScalarWhereInput | ordersScalarWhereInput[]
  }

  export type ordersUpdateManyWithoutUsers_orders_providerIdTousersNestedInput = {
    create?: XOR<ordersCreateWithoutUsers_orders_providerIdTousersInput, ordersUncheckedCreateWithoutUsers_orders_providerIdTousersInput> | ordersCreateWithoutUsers_orders_providerIdTousersInput[] | ordersUncheckedCreateWithoutUsers_orders_providerIdTousersInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutUsers_orders_providerIdTousersInput | ordersCreateOrConnectWithoutUsers_orders_providerIdTousersInput[]
    upsert?: ordersUpsertWithWhereUniqueWithoutUsers_orders_providerIdTousersInput | ordersUpsertWithWhereUniqueWithoutUsers_orders_providerIdTousersInput[]
    createMany?: ordersCreateManyUsers_orders_providerIdTousersInputEnvelope
    set?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    disconnect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    delete?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    update?: ordersUpdateWithWhereUniqueWithoutUsers_orders_providerIdTousersInput | ordersUpdateWithWhereUniqueWithoutUsers_orders_providerIdTousersInput[]
    updateMany?: ordersUpdateManyWithWhereWithoutUsers_orders_providerIdTousersInput | ordersUpdateManyWithWhereWithoutUsers_orders_providerIdTousersInput[]
    deleteMany?: ordersScalarWhereInput | ordersScalarWhereInput[]
  }

  export type otpsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<otpsCreateWithoutUsersInput, otpsUncheckedCreateWithoutUsersInput> | otpsCreateWithoutUsersInput[] | otpsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: otpsCreateOrConnectWithoutUsersInput | otpsCreateOrConnectWithoutUsersInput[]
    upsert?: otpsUpsertWithWhereUniqueWithoutUsersInput | otpsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: otpsCreateManyUsersInputEnvelope
    set?: otpsWhereUniqueInput | otpsWhereUniqueInput[]
    disconnect?: otpsWhereUniqueInput | otpsWhereUniqueInput[]
    delete?: otpsWhereUniqueInput | otpsWhereUniqueInput[]
    connect?: otpsWhereUniqueInput | otpsWhereUniqueInput[]
    update?: otpsUpdateWithWhereUniqueWithoutUsersInput | otpsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: otpsUpdateManyWithWhereWithoutUsersInput | otpsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: otpsScalarWhereInput | otpsScalarWhereInput[]
  }

  export type payment_ordersUpdateManyWithoutUsersNestedInput = {
    create?: XOR<payment_ordersCreateWithoutUsersInput, payment_ordersUncheckedCreateWithoutUsersInput> | payment_ordersCreateWithoutUsersInput[] | payment_ordersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: payment_ordersCreateOrConnectWithoutUsersInput | payment_ordersCreateOrConnectWithoutUsersInput[]
    upsert?: payment_ordersUpsertWithWhereUniqueWithoutUsersInput | payment_ordersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: payment_ordersCreateManyUsersInputEnvelope
    set?: payment_ordersWhereUniqueInput | payment_ordersWhereUniqueInput[]
    disconnect?: payment_ordersWhereUniqueInput | payment_ordersWhereUniqueInput[]
    delete?: payment_ordersWhereUniqueInput | payment_ordersWhereUniqueInput[]
    connect?: payment_ordersWhereUniqueInput | payment_ordersWhereUniqueInput[]
    update?: payment_ordersUpdateWithWhereUniqueWithoutUsersInput | payment_ordersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: payment_ordersUpdateManyWithWhereWithoutUsersInput | payment_ordersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: payment_ordersScalarWhereInput | payment_ordersScalarWhereInput[]
  }

  export type profilesUpdateOneWithoutUsersNestedInput = {
    create?: XOR<profilesCreateWithoutUsersInput, profilesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: profilesCreateOrConnectWithoutUsersInput
    upsert?: profilesUpsertWithoutUsersInput
    disconnect?: profilesWhereInput | boolean
    delete?: profilesWhereInput | boolean
    connect?: profilesWhereUniqueInput
    update?: XOR<XOR<profilesUpdateToOneWithWhereWithoutUsersInput, profilesUpdateWithoutUsersInput>, profilesUncheckedUpdateWithoutUsersInput>
  }

  export type providersUpdateOneWithoutUsersNestedInput = {
    create?: XOR<providersCreateWithoutUsersInput, providersUncheckedCreateWithoutUsersInput>
    connectOrCreate?: providersCreateOrConnectWithoutUsersInput
    upsert?: providersUpsertWithoutUsersInput
    disconnect?: providersWhereInput | boolean
    delete?: providersWhereInput | boolean
    connect?: providersWhereUniqueInput
    update?: XOR<XOR<providersUpdateToOneWithWhereWithoutUsersInput, providersUpdateWithoutUsersInput>, providersUncheckedUpdateWithoutUsersInput>
  }

  export type report_schedulesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<report_schedulesCreateWithoutUsersInput, report_schedulesUncheckedCreateWithoutUsersInput> | report_schedulesCreateWithoutUsersInput[] | report_schedulesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: report_schedulesCreateOrConnectWithoutUsersInput | report_schedulesCreateOrConnectWithoutUsersInput[]
    upsert?: report_schedulesUpsertWithWhereUniqueWithoutUsersInput | report_schedulesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: report_schedulesCreateManyUsersInputEnvelope
    set?: report_schedulesWhereUniqueInput | report_schedulesWhereUniqueInput[]
    disconnect?: report_schedulesWhereUniqueInput | report_schedulesWhereUniqueInput[]
    delete?: report_schedulesWhereUniqueInput | report_schedulesWhereUniqueInput[]
    connect?: report_schedulesWhereUniqueInput | report_schedulesWhereUniqueInput[]
    update?: report_schedulesUpdateWithWhereUniqueWithoutUsersInput | report_schedulesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: report_schedulesUpdateManyWithWhereWithoutUsersInput | report_schedulesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: report_schedulesScalarWhereInput | report_schedulesScalarWhereInput[]
  }

  export type reviewsUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput = {
    create?: XOR<reviewsCreateWithoutUsers_reviews_revieweeIdTousersInput, reviewsUncheckedCreateWithoutUsers_reviews_revieweeIdTousersInput> | reviewsCreateWithoutUsers_reviews_revieweeIdTousersInput[] | reviewsUncheckedCreateWithoutUsers_reviews_revieweeIdTousersInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutUsers_reviews_revieweeIdTousersInput | reviewsCreateOrConnectWithoutUsers_reviews_revieweeIdTousersInput[]
    upsert?: reviewsUpsertWithWhereUniqueWithoutUsers_reviews_revieweeIdTousersInput | reviewsUpsertWithWhereUniqueWithoutUsers_reviews_revieweeIdTousersInput[]
    createMany?: reviewsCreateManyUsers_reviews_revieweeIdTousersInputEnvelope
    set?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    disconnect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    delete?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    update?: reviewsUpdateWithWhereUniqueWithoutUsers_reviews_revieweeIdTousersInput | reviewsUpdateWithWhereUniqueWithoutUsers_reviews_revieweeIdTousersInput[]
    updateMany?: reviewsUpdateManyWithWhereWithoutUsers_reviews_revieweeIdTousersInput | reviewsUpdateManyWithWhereWithoutUsers_reviews_revieweeIdTousersInput[]
    deleteMany?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
  }

  export type reviewsUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput = {
    create?: XOR<reviewsCreateWithoutUsers_reviews_reviewerIdTousersInput, reviewsUncheckedCreateWithoutUsers_reviews_reviewerIdTousersInput> | reviewsCreateWithoutUsers_reviews_reviewerIdTousersInput[] | reviewsUncheckedCreateWithoutUsers_reviews_reviewerIdTousersInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutUsers_reviews_reviewerIdTousersInput | reviewsCreateOrConnectWithoutUsers_reviews_reviewerIdTousersInput[]
    upsert?: reviewsUpsertWithWhereUniqueWithoutUsers_reviews_reviewerIdTousersInput | reviewsUpsertWithWhereUniqueWithoutUsers_reviews_reviewerIdTousersInput[]
    createMany?: reviewsCreateManyUsers_reviews_reviewerIdTousersInputEnvelope
    set?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    disconnect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    delete?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    update?: reviewsUpdateWithWhereUniqueWithoutUsers_reviews_reviewerIdTousersInput | reviewsUpdateWithWhereUniqueWithoutUsers_reviews_reviewerIdTousersInput[]
    updateMany?: reviewsUpdateManyWithWhereWithoutUsers_reviews_reviewerIdTousersInput | reviewsUpdateManyWithWhereWithoutUsers_reviews_reviewerIdTousersInput[]
    deleteMany?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
  }

  export type ticketsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ticketsCreateWithoutUsersInput, ticketsUncheckedCreateWithoutUsersInput> | ticketsCreateWithoutUsersInput[] | ticketsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ticketsCreateOrConnectWithoutUsersInput | ticketsCreateOrConnectWithoutUsersInput[]
    upsert?: ticketsUpsertWithWhereUniqueWithoutUsersInput | ticketsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ticketsCreateManyUsersInputEnvelope
    set?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    disconnect?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    delete?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    connect?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    update?: ticketsUpdateWithWhereUniqueWithoutUsersInput | ticketsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ticketsUpdateManyWithWhereWithoutUsersInput | ticketsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ticketsScalarWhereInput | ticketsScalarWhereInput[]
  }

  export type user_payment_methodsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_payment_methodsCreateWithoutUsersInput, user_payment_methodsUncheckedCreateWithoutUsersInput> | user_payment_methodsCreateWithoutUsersInput[] | user_payment_methodsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_payment_methodsCreateOrConnectWithoutUsersInput | user_payment_methodsCreateOrConnectWithoutUsersInput[]
    upsert?: user_payment_methodsUpsertWithWhereUniqueWithoutUsersInput | user_payment_methodsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_payment_methodsCreateManyUsersInputEnvelope
    set?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
    disconnect?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
    delete?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
    connect?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
    update?: user_payment_methodsUpdateWithWhereUniqueWithoutUsersInput | user_payment_methodsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_payment_methodsUpdateManyWithWhereWithoutUsersInput | user_payment_methodsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_payment_methodsScalarWhereInput | user_payment_methodsScalarWhereInput[]
  }

  export type user_verificationsUpdateOneWithoutUsersNestedInput = {
    create?: XOR<user_verificationsCreateWithoutUsersInput, user_verificationsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: user_verificationsCreateOrConnectWithoutUsersInput
    upsert?: user_verificationsUpsertWithoutUsersInput
    disconnect?: user_verificationsWhereInput | boolean
    delete?: user_verificationsWhereInput | boolean
    connect?: user_verificationsWhereUniqueInput
    update?: XOR<XOR<user_verificationsUpdateToOneWithWhereWithoutUsersInput, user_verificationsUpdateWithoutUsersInput>, user_verificationsUncheckedUpdateWithoutUsersInput>
  }

  export type walletsUpdateOneWithoutUsersNestedInput = {
    create?: XOR<walletsCreateWithoutUsersInput, walletsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: walletsCreateOrConnectWithoutUsersInput
    upsert?: walletsUpsertWithoutUsersInput
    disconnect?: walletsWhereInput | boolean
    delete?: walletsWhereInput | boolean
    connect?: walletsWhereUniqueInput
    update?: XOR<XOR<walletsUpdateToOneWithWhereWithoutUsersInput, walletsUpdateWithoutUsersInput>, walletsUncheckedUpdateWithoutUsersInput>
  }

  export type admin_actionsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<admin_actionsCreateWithoutUsersInput, admin_actionsUncheckedCreateWithoutUsersInput> | admin_actionsCreateWithoutUsersInput[] | admin_actionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: admin_actionsCreateOrConnectWithoutUsersInput | admin_actionsCreateOrConnectWithoutUsersInput[]
    upsert?: admin_actionsUpsertWithWhereUniqueWithoutUsersInput | admin_actionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: admin_actionsCreateManyUsersInputEnvelope
    set?: admin_actionsWhereUniqueInput | admin_actionsWhereUniqueInput[]
    disconnect?: admin_actionsWhereUniqueInput | admin_actionsWhereUniqueInput[]
    delete?: admin_actionsWhereUniqueInput | admin_actionsWhereUniqueInput[]
    connect?: admin_actionsWhereUniqueInput | admin_actionsWhereUniqueInput[]
    update?: admin_actionsUpdateWithWhereUniqueWithoutUsersInput | admin_actionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: admin_actionsUpdateManyWithWhereWithoutUsersInput | admin_actionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: admin_actionsScalarWhereInput | admin_actionsScalarWhereInput[]
  }

  export type call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput = {
    create?: XOR<call_sessionsCreateWithoutUsers_call_sessions_customerIdTousersInput, call_sessionsUncheckedCreateWithoutUsers_call_sessions_customerIdTousersInput> | call_sessionsCreateWithoutUsers_call_sessions_customerIdTousersInput[] | call_sessionsUncheckedCreateWithoutUsers_call_sessions_customerIdTousersInput[]
    connectOrCreate?: call_sessionsCreateOrConnectWithoutUsers_call_sessions_customerIdTousersInput | call_sessionsCreateOrConnectWithoutUsers_call_sessions_customerIdTousersInput[]
    upsert?: call_sessionsUpsertWithWhereUniqueWithoutUsers_call_sessions_customerIdTousersInput | call_sessionsUpsertWithWhereUniqueWithoutUsers_call_sessions_customerIdTousersInput[]
    createMany?: call_sessionsCreateManyUsers_call_sessions_customerIdTousersInputEnvelope
    set?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
    disconnect?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
    delete?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
    connect?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
    update?: call_sessionsUpdateWithWhereUniqueWithoutUsers_call_sessions_customerIdTousersInput | call_sessionsUpdateWithWhereUniqueWithoutUsers_call_sessions_customerIdTousersInput[]
    updateMany?: call_sessionsUpdateManyWithWhereWithoutUsers_call_sessions_customerIdTousersInput | call_sessionsUpdateManyWithWhereWithoutUsers_call_sessions_customerIdTousersInput[]
    deleteMany?: call_sessionsScalarWhereInput | call_sessionsScalarWhereInput[]
  }

  export type call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput = {
    create?: XOR<call_sessionsCreateWithoutUsers_call_sessions_providerIdTousersInput, call_sessionsUncheckedCreateWithoutUsers_call_sessions_providerIdTousersInput> | call_sessionsCreateWithoutUsers_call_sessions_providerIdTousersInput[] | call_sessionsUncheckedCreateWithoutUsers_call_sessions_providerIdTousersInput[]
    connectOrCreate?: call_sessionsCreateOrConnectWithoutUsers_call_sessions_providerIdTousersInput | call_sessionsCreateOrConnectWithoutUsers_call_sessions_providerIdTousersInput[]
    upsert?: call_sessionsUpsertWithWhereUniqueWithoutUsers_call_sessions_providerIdTousersInput | call_sessionsUpsertWithWhereUniqueWithoutUsers_call_sessions_providerIdTousersInput[]
    createMany?: call_sessionsCreateManyUsers_call_sessions_providerIdTousersInputEnvelope
    set?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
    disconnect?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
    delete?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
    connect?: call_sessionsWhereUniqueInput | call_sessionsWhereUniqueInput[]
    update?: call_sessionsUpdateWithWhereUniqueWithoutUsers_call_sessions_providerIdTousersInput | call_sessionsUpdateWithWhereUniqueWithoutUsers_call_sessions_providerIdTousersInput[]
    updateMany?: call_sessionsUpdateManyWithWhereWithoutUsers_call_sessions_providerIdTousersInput | call_sessionsUpdateManyWithWhereWithoutUsers_call_sessions_providerIdTousersInput[]
    deleteMany?: call_sessionsScalarWhereInput | call_sessionsScalarWhereInput[]
  }

  export type messagesUncheckedUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput = {
    create?: XOR<messagesCreateWithoutUsers_messages_receiverIdTousersInput, messagesUncheckedCreateWithoutUsers_messages_receiverIdTousersInput> | messagesCreateWithoutUsers_messages_receiverIdTousersInput[] | messagesUncheckedCreateWithoutUsers_messages_receiverIdTousersInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUsers_messages_receiverIdTousersInput | messagesCreateOrConnectWithoutUsers_messages_receiverIdTousersInput[]
    upsert?: messagesUpsertWithWhereUniqueWithoutUsers_messages_receiverIdTousersInput | messagesUpsertWithWhereUniqueWithoutUsers_messages_receiverIdTousersInput[]
    createMany?: messagesCreateManyUsers_messages_receiverIdTousersInputEnvelope
    set?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    disconnect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    delete?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    update?: messagesUpdateWithWhereUniqueWithoutUsers_messages_receiverIdTousersInput | messagesUpdateWithWhereUniqueWithoutUsers_messages_receiverIdTousersInput[]
    updateMany?: messagesUpdateManyWithWhereWithoutUsers_messages_receiverIdTousersInput | messagesUpdateManyWithWhereWithoutUsers_messages_receiverIdTousersInput[]
    deleteMany?: messagesScalarWhereInput | messagesScalarWhereInput[]
  }

  export type messagesUncheckedUpdateManyWithoutUsers_messages_senderIdTousersNestedInput = {
    create?: XOR<messagesCreateWithoutUsers_messages_senderIdTousersInput, messagesUncheckedCreateWithoutUsers_messages_senderIdTousersInput> | messagesCreateWithoutUsers_messages_senderIdTousersInput[] | messagesUncheckedCreateWithoutUsers_messages_senderIdTousersInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUsers_messages_senderIdTousersInput | messagesCreateOrConnectWithoutUsers_messages_senderIdTousersInput[]
    upsert?: messagesUpsertWithWhereUniqueWithoutUsers_messages_senderIdTousersInput | messagesUpsertWithWhereUniqueWithoutUsers_messages_senderIdTousersInput[]
    createMany?: messagesCreateManyUsers_messages_senderIdTousersInputEnvelope
    set?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    disconnect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    delete?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    update?: messagesUpdateWithWhereUniqueWithoutUsers_messages_senderIdTousersInput | messagesUpdateWithWhereUniqueWithoutUsers_messages_senderIdTousersInput[]
    updateMany?: messagesUpdateManyWithWhereWithoutUsers_messages_senderIdTousersInput | messagesUpdateManyWithWhereWithoutUsers_messages_senderIdTousersInput[]
    deleteMany?: messagesScalarWhereInput | messagesScalarWhereInput[]
  }

  export type notification_preferencesUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<notification_preferencesCreateWithoutUsersInput, notification_preferencesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: notification_preferencesCreateOrConnectWithoutUsersInput
    upsert?: notification_preferencesUpsertWithoutUsersInput
    disconnect?: notification_preferencesWhereInput | boolean
    delete?: notification_preferencesWhereInput | boolean
    connect?: notification_preferencesWhereUniqueInput
    update?: XOR<XOR<notification_preferencesUpdateToOneWithWhereWithoutUsersInput, notification_preferencesUpdateWithoutUsersInput>, notification_preferencesUncheckedUpdateWithoutUsersInput>
  }

  export type notification_tokensUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<notification_tokensCreateWithoutUsersInput, notification_tokensUncheckedCreateWithoutUsersInput> | notification_tokensCreateWithoutUsersInput[] | notification_tokensUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notification_tokensCreateOrConnectWithoutUsersInput | notification_tokensCreateOrConnectWithoutUsersInput[]
    upsert?: notification_tokensUpsertWithWhereUniqueWithoutUsersInput | notification_tokensUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: notification_tokensCreateManyUsersInputEnvelope
    set?: notification_tokensWhereUniqueInput | notification_tokensWhereUniqueInput[]
    disconnect?: notification_tokensWhereUniqueInput | notification_tokensWhereUniqueInput[]
    delete?: notification_tokensWhereUniqueInput | notification_tokensWhereUniqueInput[]
    connect?: notification_tokensWhereUniqueInput | notification_tokensWhereUniqueInput[]
    update?: notification_tokensUpdateWithWhereUniqueWithoutUsersInput | notification_tokensUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: notification_tokensUpdateManyWithWhereWithoutUsersInput | notification_tokensUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: notification_tokensScalarWhereInput | notification_tokensScalarWhereInput[]
  }

  export type notificationsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutUsersInput | notificationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutUsersInput | notificationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutUsersInput | notificationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type ordersUncheckedUpdateManyWithoutUsers_orders_customerIdTousersNestedInput = {
    create?: XOR<ordersCreateWithoutUsers_orders_customerIdTousersInput, ordersUncheckedCreateWithoutUsers_orders_customerIdTousersInput> | ordersCreateWithoutUsers_orders_customerIdTousersInput[] | ordersUncheckedCreateWithoutUsers_orders_customerIdTousersInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutUsers_orders_customerIdTousersInput | ordersCreateOrConnectWithoutUsers_orders_customerIdTousersInput[]
    upsert?: ordersUpsertWithWhereUniqueWithoutUsers_orders_customerIdTousersInput | ordersUpsertWithWhereUniqueWithoutUsers_orders_customerIdTousersInput[]
    createMany?: ordersCreateManyUsers_orders_customerIdTousersInputEnvelope
    set?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    disconnect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    delete?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    update?: ordersUpdateWithWhereUniqueWithoutUsers_orders_customerIdTousersInput | ordersUpdateWithWhereUniqueWithoutUsers_orders_customerIdTousersInput[]
    updateMany?: ordersUpdateManyWithWhereWithoutUsers_orders_customerIdTousersInput | ordersUpdateManyWithWhereWithoutUsers_orders_customerIdTousersInput[]
    deleteMany?: ordersScalarWhereInput | ordersScalarWhereInput[]
  }

  export type ordersUncheckedUpdateManyWithoutUsers_orders_providerIdTousersNestedInput = {
    create?: XOR<ordersCreateWithoutUsers_orders_providerIdTousersInput, ordersUncheckedCreateWithoutUsers_orders_providerIdTousersInput> | ordersCreateWithoutUsers_orders_providerIdTousersInput[] | ordersUncheckedCreateWithoutUsers_orders_providerIdTousersInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutUsers_orders_providerIdTousersInput | ordersCreateOrConnectWithoutUsers_orders_providerIdTousersInput[]
    upsert?: ordersUpsertWithWhereUniqueWithoutUsers_orders_providerIdTousersInput | ordersUpsertWithWhereUniqueWithoutUsers_orders_providerIdTousersInput[]
    createMany?: ordersCreateManyUsers_orders_providerIdTousersInputEnvelope
    set?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    disconnect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    delete?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    update?: ordersUpdateWithWhereUniqueWithoutUsers_orders_providerIdTousersInput | ordersUpdateWithWhereUniqueWithoutUsers_orders_providerIdTousersInput[]
    updateMany?: ordersUpdateManyWithWhereWithoutUsers_orders_providerIdTousersInput | ordersUpdateManyWithWhereWithoutUsers_orders_providerIdTousersInput[]
    deleteMany?: ordersScalarWhereInput | ordersScalarWhereInput[]
  }

  export type otpsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<otpsCreateWithoutUsersInput, otpsUncheckedCreateWithoutUsersInput> | otpsCreateWithoutUsersInput[] | otpsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: otpsCreateOrConnectWithoutUsersInput | otpsCreateOrConnectWithoutUsersInput[]
    upsert?: otpsUpsertWithWhereUniqueWithoutUsersInput | otpsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: otpsCreateManyUsersInputEnvelope
    set?: otpsWhereUniqueInput | otpsWhereUniqueInput[]
    disconnect?: otpsWhereUniqueInput | otpsWhereUniqueInput[]
    delete?: otpsWhereUniqueInput | otpsWhereUniqueInput[]
    connect?: otpsWhereUniqueInput | otpsWhereUniqueInput[]
    update?: otpsUpdateWithWhereUniqueWithoutUsersInput | otpsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: otpsUpdateManyWithWhereWithoutUsersInput | otpsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: otpsScalarWhereInput | otpsScalarWhereInput[]
  }

  export type payment_ordersUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<payment_ordersCreateWithoutUsersInput, payment_ordersUncheckedCreateWithoutUsersInput> | payment_ordersCreateWithoutUsersInput[] | payment_ordersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: payment_ordersCreateOrConnectWithoutUsersInput | payment_ordersCreateOrConnectWithoutUsersInput[]
    upsert?: payment_ordersUpsertWithWhereUniqueWithoutUsersInput | payment_ordersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: payment_ordersCreateManyUsersInputEnvelope
    set?: payment_ordersWhereUniqueInput | payment_ordersWhereUniqueInput[]
    disconnect?: payment_ordersWhereUniqueInput | payment_ordersWhereUniqueInput[]
    delete?: payment_ordersWhereUniqueInput | payment_ordersWhereUniqueInput[]
    connect?: payment_ordersWhereUniqueInput | payment_ordersWhereUniqueInput[]
    update?: payment_ordersUpdateWithWhereUniqueWithoutUsersInput | payment_ordersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: payment_ordersUpdateManyWithWhereWithoutUsersInput | payment_ordersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: payment_ordersScalarWhereInput | payment_ordersScalarWhereInput[]
  }

  export type profilesUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<profilesCreateWithoutUsersInput, profilesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: profilesCreateOrConnectWithoutUsersInput
    upsert?: profilesUpsertWithoutUsersInput
    disconnect?: profilesWhereInput | boolean
    delete?: profilesWhereInput | boolean
    connect?: profilesWhereUniqueInput
    update?: XOR<XOR<profilesUpdateToOneWithWhereWithoutUsersInput, profilesUpdateWithoutUsersInput>, profilesUncheckedUpdateWithoutUsersInput>
  }

  export type providersUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<providersCreateWithoutUsersInput, providersUncheckedCreateWithoutUsersInput>
    connectOrCreate?: providersCreateOrConnectWithoutUsersInput
    upsert?: providersUpsertWithoutUsersInput
    disconnect?: providersWhereInput | boolean
    delete?: providersWhereInput | boolean
    connect?: providersWhereUniqueInput
    update?: XOR<XOR<providersUpdateToOneWithWhereWithoutUsersInput, providersUpdateWithoutUsersInput>, providersUncheckedUpdateWithoutUsersInput>
  }

  export type report_schedulesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<report_schedulesCreateWithoutUsersInput, report_schedulesUncheckedCreateWithoutUsersInput> | report_schedulesCreateWithoutUsersInput[] | report_schedulesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: report_schedulesCreateOrConnectWithoutUsersInput | report_schedulesCreateOrConnectWithoutUsersInput[]
    upsert?: report_schedulesUpsertWithWhereUniqueWithoutUsersInput | report_schedulesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: report_schedulesCreateManyUsersInputEnvelope
    set?: report_schedulesWhereUniqueInput | report_schedulesWhereUniqueInput[]
    disconnect?: report_schedulesWhereUniqueInput | report_schedulesWhereUniqueInput[]
    delete?: report_schedulesWhereUniqueInput | report_schedulesWhereUniqueInput[]
    connect?: report_schedulesWhereUniqueInput | report_schedulesWhereUniqueInput[]
    update?: report_schedulesUpdateWithWhereUniqueWithoutUsersInput | report_schedulesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: report_schedulesUpdateManyWithWhereWithoutUsersInput | report_schedulesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: report_schedulesScalarWhereInput | report_schedulesScalarWhereInput[]
  }

  export type reviewsUncheckedUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput = {
    create?: XOR<reviewsCreateWithoutUsers_reviews_revieweeIdTousersInput, reviewsUncheckedCreateWithoutUsers_reviews_revieweeIdTousersInput> | reviewsCreateWithoutUsers_reviews_revieweeIdTousersInput[] | reviewsUncheckedCreateWithoutUsers_reviews_revieweeIdTousersInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutUsers_reviews_revieweeIdTousersInput | reviewsCreateOrConnectWithoutUsers_reviews_revieweeIdTousersInput[]
    upsert?: reviewsUpsertWithWhereUniqueWithoutUsers_reviews_revieweeIdTousersInput | reviewsUpsertWithWhereUniqueWithoutUsers_reviews_revieweeIdTousersInput[]
    createMany?: reviewsCreateManyUsers_reviews_revieweeIdTousersInputEnvelope
    set?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    disconnect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    delete?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    update?: reviewsUpdateWithWhereUniqueWithoutUsers_reviews_revieweeIdTousersInput | reviewsUpdateWithWhereUniqueWithoutUsers_reviews_revieweeIdTousersInput[]
    updateMany?: reviewsUpdateManyWithWhereWithoutUsers_reviews_revieweeIdTousersInput | reviewsUpdateManyWithWhereWithoutUsers_reviews_revieweeIdTousersInput[]
    deleteMany?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
  }

  export type reviewsUncheckedUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput = {
    create?: XOR<reviewsCreateWithoutUsers_reviews_reviewerIdTousersInput, reviewsUncheckedCreateWithoutUsers_reviews_reviewerIdTousersInput> | reviewsCreateWithoutUsers_reviews_reviewerIdTousersInput[] | reviewsUncheckedCreateWithoutUsers_reviews_reviewerIdTousersInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutUsers_reviews_reviewerIdTousersInput | reviewsCreateOrConnectWithoutUsers_reviews_reviewerIdTousersInput[]
    upsert?: reviewsUpsertWithWhereUniqueWithoutUsers_reviews_reviewerIdTousersInput | reviewsUpsertWithWhereUniqueWithoutUsers_reviews_reviewerIdTousersInput[]
    createMany?: reviewsCreateManyUsers_reviews_reviewerIdTousersInputEnvelope
    set?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    disconnect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    delete?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    update?: reviewsUpdateWithWhereUniqueWithoutUsers_reviews_reviewerIdTousersInput | reviewsUpdateWithWhereUniqueWithoutUsers_reviews_reviewerIdTousersInput[]
    updateMany?: reviewsUpdateManyWithWhereWithoutUsers_reviews_reviewerIdTousersInput | reviewsUpdateManyWithWhereWithoutUsers_reviews_reviewerIdTousersInput[]
    deleteMany?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
  }

  export type ticketsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<ticketsCreateWithoutUsersInput, ticketsUncheckedCreateWithoutUsersInput> | ticketsCreateWithoutUsersInput[] | ticketsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: ticketsCreateOrConnectWithoutUsersInput | ticketsCreateOrConnectWithoutUsersInput[]
    upsert?: ticketsUpsertWithWhereUniqueWithoutUsersInput | ticketsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: ticketsCreateManyUsersInputEnvelope
    set?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    disconnect?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    delete?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    connect?: ticketsWhereUniqueInput | ticketsWhereUniqueInput[]
    update?: ticketsUpdateWithWhereUniqueWithoutUsersInput | ticketsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: ticketsUpdateManyWithWhereWithoutUsersInput | ticketsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: ticketsScalarWhereInput | ticketsScalarWhereInput[]
  }

  export type user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_payment_methodsCreateWithoutUsersInput, user_payment_methodsUncheckedCreateWithoutUsersInput> | user_payment_methodsCreateWithoutUsersInput[] | user_payment_methodsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_payment_methodsCreateOrConnectWithoutUsersInput | user_payment_methodsCreateOrConnectWithoutUsersInput[]
    upsert?: user_payment_methodsUpsertWithWhereUniqueWithoutUsersInput | user_payment_methodsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_payment_methodsCreateManyUsersInputEnvelope
    set?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
    disconnect?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
    delete?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
    connect?: user_payment_methodsWhereUniqueInput | user_payment_methodsWhereUniqueInput[]
    update?: user_payment_methodsUpdateWithWhereUniqueWithoutUsersInput | user_payment_methodsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_payment_methodsUpdateManyWithWhereWithoutUsersInput | user_payment_methodsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_payment_methodsScalarWhereInput | user_payment_methodsScalarWhereInput[]
  }

  export type user_verificationsUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<user_verificationsCreateWithoutUsersInput, user_verificationsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: user_verificationsCreateOrConnectWithoutUsersInput
    upsert?: user_verificationsUpsertWithoutUsersInput
    disconnect?: user_verificationsWhereInput | boolean
    delete?: user_verificationsWhereInput | boolean
    connect?: user_verificationsWhereUniqueInput
    update?: XOR<XOR<user_verificationsUpdateToOneWithWhereWithoutUsersInput, user_verificationsUpdateWithoutUsersInput>, user_verificationsUncheckedUpdateWithoutUsersInput>
  }

  export type walletsUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<walletsCreateWithoutUsersInput, walletsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: walletsCreateOrConnectWithoutUsersInput
    upsert?: walletsUpsertWithoutUsersInput
    disconnect?: walletsWhereInput | boolean
    delete?: walletsWhereInput | boolean
    connect?: walletsWhereUniqueInput
    update?: XOR<XOR<walletsUpdateToOneWithWhereWithoutUsersInput, walletsUpdateWithoutUsersInput>, walletsUncheckedUpdateWithoutUsersInput>
  }

  export type ordersCreateNestedOneWithoutVirtual_assignmentsInput = {
    create?: XOR<ordersCreateWithoutVirtual_assignmentsInput, ordersUncheckedCreateWithoutVirtual_assignmentsInput>
    connectOrCreate?: ordersCreateOrConnectWithoutVirtual_assignmentsInput
    connect?: ordersWhereUniqueInput
  }

  export type virtual_numbersCreateNestedOneWithoutVirtual_assignmentsInput = {
    create?: XOR<virtual_numbersCreateWithoutVirtual_assignmentsInput, virtual_numbersUncheckedCreateWithoutVirtual_assignmentsInput>
    connectOrCreate?: virtual_numbersCreateOrConnectWithoutVirtual_assignmentsInput
    connect?: virtual_numbersWhereUniqueInput
  }

  export type ordersUpdateOneRequiredWithoutVirtual_assignmentsNestedInput = {
    create?: XOR<ordersCreateWithoutVirtual_assignmentsInput, ordersUncheckedCreateWithoutVirtual_assignmentsInput>
    connectOrCreate?: ordersCreateOrConnectWithoutVirtual_assignmentsInput
    upsert?: ordersUpsertWithoutVirtual_assignmentsInput
    connect?: ordersWhereUniqueInput
    update?: XOR<XOR<ordersUpdateToOneWithWhereWithoutVirtual_assignmentsInput, ordersUpdateWithoutVirtual_assignmentsInput>, ordersUncheckedUpdateWithoutVirtual_assignmentsInput>
  }

  export type virtual_numbersUpdateOneRequiredWithoutVirtual_assignmentsNestedInput = {
    create?: XOR<virtual_numbersCreateWithoutVirtual_assignmentsInput, virtual_numbersUncheckedCreateWithoutVirtual_assignmentsInput>
    connectOrCreate?: virtual_numbersCreateOrConnectWithoutVirtual_assignmentsInput
    upsert?: virtual_numbersUpsertWithoutVirtual_assignmentsInput
    connect?: virtual_numbersWhereUniqueInput
    update?: XOR<XOR<virtual_numbersUpdateToOneWithWhereWithoutVirtual_assignmentsInput, virtual_numbersUpdateWithoutVirtual_assignmentsInput>, virtual_numbersUncheckedUpdateWithoutVirtual_assignmentsInput>
  }

  export type virtual_assignmentsCreateNestedManyWithoutVirtual_numbersInput = {
    create?: XOR<virtual_assignmentsCreateWithoutVirtual_numbersInput, virtual_assignmentsUncheckedCreateWithoutVirtual_numbersInput> | virtual_assignmentsCreateWithoutVirtual_numbersInput[] | virtual_assignmentsUncheckedCreateWithoutVirtual_numbersInput[]
    connectOrCreate?: virtual_assignmentsCreateOrConnectWithoutVirtual_numbersInput | virtual_assignmentsCreateOrConnectWithoutVirtual_numbersInput[]
    createMany?: virtual_assignmentsCreateManyVirtual_numbersInputEnvelope
    connect?: virtual_assignmentsWhereUniqueInput | virtual_assignmentsWhereUniqueInput[]
  }

  export type virtual_assignmentsUncheckedCreateNestedManyWithoutVirtual_numbersInput = {
    create?: XOR<virtual_assignmentsCreateWithoutVirtual_numbersInput, virtual_assignmentsUncheckedCreateWithoutVirtual_numbersInput> | virtual_assignmentsCreateWithoutVirtual_numbersInput[] | virtual_assignmentsUncheckedCreateWithoutVirtual_numbersInput[]
    connectOrCreate?: virtual_assignmentsCreateOrConnectWithoutVirtual_numbersInput | virtual_assignmentsCreateOrConnectWithoutVirtual_numbersInput[]
    createMany?: virtual_assignmentsCreateManyVirtual_numbersInputEnvelope
    connect?: virtual_assignmentsWhereUniqueInput | virtual_assignmentsWhereUniqueInput[]
  }

  export type virtual_assignmentsUpdateManyWithoutVirtual_numbersNestedInput = {
    create?: XOR<virtual_assignmentsCreateWithoutVirtual_numbersInput, virtual_assignmentsUncheckedCreateWithoutVirtual_numbersInput> | virtual_assignmentsCreateWithoutVirtual_numbersInput[] | virtual_assignmentsUncheckedCreateWithoutVirtual_numbersInput[]
    connectOrCreate?: virtual_assignmentsCreateOrConnectWithoutVirtual_numbersInput | virtual_assignmentsCreateOrConnectWithoutVirtual_numbersInput[]
    upsert?: virtual_assignmentsUpsertWithWhereUniqueWithoutVirtual_numbersInput | virtual_assignmentsUpsertWithWhereUniqueWithoutVirtual_numbersInput[]
    createMany?: virtual_assignmentsCreateManyVirtual_numbersInputEnvelope
    set?: virtual_assignmentsWhereUniqueInput | virtual_assignmentsWhereUniqueInput[]
    disconnect?: virtual_assignmentsWhereUniqueInput | virtual_assignmentsWhereUniqueInput[]
    delete?: virtual_assignmentsWhereUniqueInput | virtual_assignmentsWhereUniqueInput[]
    connect?: virtual_assignmentsWhereUniqueInput | virtual_assignmentsWhereUniqueInput[]
    update?: virtual_assignmentsUpdateWithWhereUniqueWithoutVirtual_numbersInput | virtual_assignmentsUpdateWithWhereUniqueWithoutVirtual_numbersInput[]
    updateMany?: virtual_assignmentsUpdateManyWithWhereWithoutVirtual_numbersInput | virtual_assignmentsUpdateManyWithWhereWithoutVirtual_numbersInput[]
    deleteMany?: virtual_assignmentsScalarWhereInput | virtual_assignmentsScalarWhereInput[]
  }

  export type virtual_assignmentsUncheckedUpdateManyWithoutVirtual_numbersNestedInput = {
    create?: XOR<virtual_assignmentsCreateWithoutVirtual_numbersInput, virtual_assignmentsUncheckedCreateWithoutVirtual_numbersInput> | virtual_assignmentsCreateWithoutVirtual_numbersInput[] | virtual_assignmentsUncheckedCreateWithoutVirtual_numbersInput[]
    connectOrCreate?: virtual_assignmentsCreateOrConnectWithoutVirtual_numbersInput | virtual_assignmentsCreateOrConnectWithoutVirtual_numbersInput[]
    upsert?: virtual_assignmentsUpsertWithWhereUniqueWithoutVirtual_numbersInput | virtual_assignmentsUpsertWithWhereUniqueWithoutVirtual_numbersInput[]
    createMany?: virtual_assignmentsCreateManyVirtual_numbersInputEnvelope
    set?: virtual_assignmentsWhereUniqueInput | virtual_assignmentsWhereUniqueInput[]
    disconnect?: virtual_assignmentsWhereUniqueInput | virtual_assignmentsWhereUniqueInput[]
    delete?: virtual_assignmentsWhereUniqueInput | virtual_assignmentsWhereUniqueInput[]
    connect?: virtual_assignmentsWhereUniqueInput | virtual_assignmentsWhereUniqueInput[]
    update?: virtual_assignmentsUpdateWithWhereUniqueWithoutVirtual_numbersInput | virtual_assignmentsUpdateWithWhereUniqueWithoutVirtual_numbersInput[]
    updateMany?: virtual_assignmentsUpdateManyWithWhereWithoutVirtual_numbersInput | virtual_assignmentsUpdateManyWithWhereWithoutVirtual_numbersInput[]
    deleteMany?: virtual_assignmentsScalarWhereInput | virtual_assignmentsScalarWhereInput[]
  }

  export type transactionsCreateNestedManyWithoutWalletsInput = {
    create?: XOR<transactionsCreateWithoutWalletsInput, transactionsUncheckedCreateWithoutWalletsInput> | transactionsCreateWithoutWalletsInput[] | transactionsUncheckedCreateWithoutWalletsInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutWalletsInput | transactionsCreateOrConnectWithoutWalletsInput[]
    createMany?: transactionsCreateManyWalletsInputEnvelope
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutWalletsInput = {
    create?: XOR<usersCreateWithoutWalletsInput, usersUncheckedCreateWithoutWalletsInput>
    connectOrCreate?: usersCreateOrConnectWithoutWalletsInput
    connect?: usersWhereUniqueInput
  }

  export type transactionsUncheckedCreateNestedManyWithoutWalletsInput = {
    create?: XOR<transactionsCreateWithoutWalletsInput, transactionsUncheckedCreateWithoutWalletsInput> | transactionsCreateWithoutWalletsInput[] | transactionsUncheckedCreateWithoutWalletsInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutWalletsInput | transactionsCreateOrConnectWithoutWalletsInput[]
    createMany?: transactionsCreateManyWalletsInputEnvelope
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
  }

  export type transactionsUpdateManyWithoutWalletsNestedInput = {
    create?: XOR<transactionsCreateWithoutWalletsInput, transactionsUncheckedCreateWithoutWalletsInput> | transactionsCreateWithoutWalletsInput[] | transactionsUncheckedCreateWithoutWalletsInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutWalletsInput | transactionsCreateOrConnectWithoutWalletsInput[]
    upsert?: transactionsUpsertWithWhereUniqueWithoutWalletsInput | transactionsUpsertWithWhereUniqueWithoutWalletsInput[]
    createMany?: transactionsCreateManyWalletsInputEnvelope
    set?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    disconnect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    delete?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    update?: transactionsUpdateWithWhereUniqueWithoutWalletsInput | transactionsUpdateWithWhereUniqueWithoutWalletsInput[]
    updateMany?: transactionsUpdateManyWithWhereWithoutWalletsInput | transactionsUpdateManyWithWhereWithoutWalletsInput[]
    deleteMany?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutWalletsNestedInput = {
    create?: XOR<usersCreateWithoutWalletsInput, usersUncheckedCreateWithoutWalletsInput>
    connectOrCreate?: usersCreateOrConnectWithoutWalletsInput
    upsert?: usersUpsertWithoutWalletsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutWalletsInput, usersUpdateWithoutWalletsInput>, usersUncheckedUpdateWithoutWalletsInput>
  }

  export type transactionsUncheckedUpdateManyWithoutWalletsNestedInput = {
    create?: XOR<transactionsCreateWithoutWalletsInput, transactionsUncheckedCreateWithoutWalletsInput> | transactionsCreateWithoutWalletsInput[] | transactionsUncheckedCreateWithoutWalletsInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutWalletsInput | transactionsCreateOrConnectWithoutWalletsInput[]
    upsert?: transactionsUpsertWithWhereUniqueWithoutWalletsInput | transactionsUpsertWithWhereUniqueWithoutWalletsInput[]
    createMany?: transactionsCreateManyWalletsInputEnvelope
    set?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    disconnect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    delete?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    update?: transactionsUpdateWithWhereUniqueWithoutWalletsInput | transactionsUpdateWithWhereUniqueWithoutWalletsInput[]
    updateMany?: transactionsUpdateManyWithWhereWithoutWalletsInput | transactionsUpdateManyWithWhereWithoutWalletsInput[]
    deleteMany?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
  }

  export type provider_locationsCreateNestedManyWithoutZonesInput = {
    create?: XOR<provider_locationsCreateWithoutZonesInput, provider_locationsUncheckedCreateWithoutZonesInput> | provider_locationsCreateWithoutZonesInput[] | provider_locationsUncheckedCreateWithoutZonesInput[]
    connectOrCreate?: provider_locationsCreateOrConnectWithoutZonesInput | provider_locationsCreateOrConnectWithoutZonesInput[]
    createMany?: provider_locationsCreateManyZonesInputEnvelope
    connect?: provider_locationsWhereUniqueInput | provider_locationsWhereUniqueInput[]
  }

  export type provider_locationsUncheckedCreateNestedManyWithoutZonesInput = {
    create?: XOR<provider_locationsCreateWithoutZonesInput, provider_locationsUncheckedCreateWithoutZonesInput> | provider_locationsCreateWithoutZonesInput[] | provider_locationsUncheckedCreateWithoutZonesInput[]
    connectOrCreate?: provider_locationsCreateOrConnectWithoutZonesInput | provider_locationsCreateOrConnectWithoutZonesInput[]
    createMany?: provider_locationsCreateManyZonesInputEnvelope
    connect?: provider_locationsWhereUniqueInput | provider_locationsWhereUniqueInput[]
  }

  export type provider_locationsUpdateManyWithoutZonesNestedInput = {
    create?: XOR<provider_locationsCreateWithoutZonesInput, provider_locationsUncheckedCreateWithoutZonesInput> | provider_locationsCreateWithoutZonesInput[] | provider_locationsUncheckedCreateWithoutZonesInput[]
    connectOrCreate?: provider_locationsCreateOrConnectWithoutZonesInput | provider_locationsCreateOrConnectWithoutZonesInput[]
    upsert?: provider_locationsUpsertWithWhereUniqueWithoutZonesInput | provider_locationsUpsertWithWhereUniqueWithoutZonesInput[]
    createMany?: provider_locationsCreateManyZonesInputEnvelope
    set?: provider_locationsWhereUniqueInput | provider_locationsWhereUniqueInput[]
    disconnect?: provider_locationsWhereUniqueInput | provider_locationsWhereUniqueInput[]
    delete?: provider_locationsWhereUniqueInput | provider_locationsWhereUniqueInput[]
    connect?: provider_locationsWhereUniqueInput | provider_locationsWhereUniqueInput[]
    update?: provider_locationsUpdateWithWhereUniqueWithoutZonesInput | provider_locationsUpdateWithWhereUniqueWithoutZonesInput[]
    updateMany?: provider_locationsUpdateManyWithWhereWithoutZonesInput | provider_locationsUpdateManyWithWhereWithoutZonesInput[]
    deleteMany?: provider_locationsScalarWhereInput | provider_locationsScalarWhereInput[]
  }

  export type provider_locationsUncheckedUpdateManyWithoutZonesNestedInput = {
    create?: XOR<provider_locationsCreateWithoutZonesInput, provider_locationsUncheckedCreateWithoutZonesInput> | provider_locationsCreateWithoutZonesInput[] | provider_locationsUncheckedCreateWithoutZonesInput[]
    connectOrCreate?: provider_locationsCreateOrConnectWithoutZonesInput | provider_locationsCreateOrConnectWithoutZonesInput[]
    upsert?: provider_locationsUpsertWithWhereUniqueWithoutZonesInput | provider_locationsUpsertWithWhereUniqueWithoutZonesInput[]
    createMany?: provider_locationsCreateManyZonesInputEnvelope
    set?: provider_locationsWhereUniqueInput | provider_locationsWhereUniqueInput[]
    disconnect?: provider_locationsWhereUniqueInput | provider_locationsWhereUniqueInput[]
    delete?: provider_locationsWhereUniqueInput | provider_locationsWhereUniqueInput[]
    connect?: provider_locationsWhereUniqueInput | provider_locationsWhereUniqueInput[]
    update?: provider_locationsUpdateWithWhereUniqueWithoutZonesInput | provider_locationsUpdateWithWhereUniqueWithoutZonesInput[]
    updateMany?: provider_locationsUpdateManyWithWhereWithoutZonesInput | provider_locationsUpdateManyWithWhereWithoutZonesInput[]
    deleteMany?: provider_locationsScalarWhereInput | provider_locationsScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumProviderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProviderType | EnumProviderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProviderType[] | ListEnumProviderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProviderType[] | ListEnumProviderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderTypeFilter<$PrismaModel> | $Enums.ProviderType
  }

  export type NestedEnumProviderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProviderType | EnumProviderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProviderType[] | ListEnumProviderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProviderType[] | ListEnumProviderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProviderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProviderTypeFilter<$PrismaModel>
    _max?: NestedEnumProviderTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type NestedEnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type usersCreateWithoutAdmin_actionsInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    call_sessions_call_sessions_customerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersCreateNestedManyWithoutUsersInput
    profiles?: profilesCreateNestedOneWithoutUsersInput
    providers?: providersCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutAdmin_actionsInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsUncheckedCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersUncheckedCreateNestedManyWithoutUsersInput
    profiles?: profilesUncheckedCreateNestedOneWithoutUsersInput
    providers?: providersUncheckedCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesUncheckedCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsUncheckedCreateNestedOneWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutAdmin_actionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAdmin_actionsInput, usersUncheckedCreateWithoutAdmin_actionsInput>
  }

  export type usersUpsertWithoutAdmin_actionsInput = {
    update: XOR<usersUpdateWithoutAdmin_actionsInput, usersUncheckedUpdateWithoutAdmin_actionsInput>
    create: XOR<usersCreateWithoutAdmin_actionsInput, usersUncheckedCreateWithoutAdmin_actionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAdmin_actionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAdmin_actionsInput, usersUncheckedUpdateWithoutAdmin_actionsInput>
  }

  export type usersUpdateWithoutAdmin_actionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUpdateManyWithoutUsersNestedInput
    profiles?: profilesUpdateOneWithoutUsersNestedInput
    providers?: providersUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutAdmin_actionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUncheckedUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUncheckedUpdateManyWithoutUsersNestedInput
    profiles?: profilesUncheckedUpdateOneWithoutUsersNestedInput
    providers?: providersUncheckedUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUncheckedUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUncheckedUpdateOneWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type call_sessionsCreateWithoutCall_logsInput = {
    id: string
    twilioCallSid?: string | null
    customerPhone: string
    providerPhone: string
    status?: string
    duration?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    users_call_sessions_customerIdTousers: usersCreateNestedOneWithoutCall_sessions_call_sessions_customerIdTousersInput
    orders?: ordersCreateNestedOneWithoutCall_sessionsInput
    users_call_sessions_providerIdTousers: usersCreateNestedOneWithoutCall_sessions_call_sessions_providerIdTousersInput
  }

  export type call_sessionsUncheckedCreateWithoutCall_logsInput = {
    id: string
    customerId: string
    providerId: string
    orderId?: string | null
    twilioCallSid?: string | null
    customerPhone: string
    providerPhone: string
    status?: string
    duration?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type call_sessionsCreateOrConnectWithoutCall_logsInput = {
    where: call_sessionsWhereUniqueInput
    create: XOR<call_sessionsCreateWithoutCall_logsInput, call_sessionsUncheckedCreateWithoutCall_logsInput>
  }

  export type call_sessionsUpsertWithoutCall_logsInput = {
    update: XOR<call_sessionsUpdateWithoutCall_logsInput, call_sessionsUncheckedUpdateWithoutCall_logsInput>
    create: XOR<call_sessionsCreateWithoutCall_logsInput, call_sessionsUncheckedCreateWithoutCall_logsInput>
    where?: call_sessionsWhereInput
  }

  export type call_sessionsUpdateToOneWithWhereWithoutCall_logsInput = {
    where?: call_sessionsWhereInput
    data: XOR<call_sessionsUpdateWithoutCall_logsInput, call_sessionsUncheckedUpdateWithoutCall_logsInput>
  }

  export type call_sessionsUpdateWithoutCall_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_call_sessions_customerIdTousers?: usersUpdateOneRequiredWithoutCall_sessions_call_sessions_customerIdTousersNestedInput
    orders?: ordersUpdateOneWithoutCall_sessionsNestedInput
    users_call_sessions_providerIdTousers?: usersUpdateOneRequiredWithoutCall_sessions_call_sessions_providerIdTousersNestedInput
  }

  export type call_sessionsUncheckedUpdateWithoutCall_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type call_logsCreateWithoutCall_sessionsInput = {
    id: string
    status: string
    duration?: number | null
    timestamp?: Date | string
  }

  export type call_logsUncheckedCreateWithoutCall_sessionsInput = {
    id: string
    status: string
    duration?: number | null
    timestamp?: Date | string
  }

  export type call_logsCreateOrConnectWithoutCall_sessionsInput = {
    where: call_logsWhereUniqueInput
    create: XOR<call_logsCreateWithoutCall_sessionsInput, call_logsUncheckedCreateWithoutCall_sessionsInput>
  }

  export type call_logsCreateManyCall_sessionsInputEnvelope = {
    data: call_logsCreateManyCall_sessionsInput | call_logsCreateManyCall_sessionsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutCall_sessions_call_sessions_customerIdTousersInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersCreateNestedManyWithoutUsersInput
    profiles?: profilesCreateNestedOneWithoutUsersInput
    providers?: providersCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutCall_sessions_call_sessions_customerIdTousersInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsUncheckedCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsUncheckedCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersUncheckedCreateNestedManyWithoutUsersInput
    profiles?: profilesUncheckedCreateNestedOneWithoutUsersInput
    providers?: providersUncheckedCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesUncheckedCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsUncheckedCreateNestedOneWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutCall_sessions_call_sessions_customerIdTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCall_sessions_call_sessions_customerIdTousersInput, usersUncheckedCreateWithoutCall_sessions_call_sessions_customerIdTousersInput>
  }

  export type ordersCreateWithoutCall_sessionsInput = {
    id: string
    status?: $Enums.OrderStatus
    totalAmount: number
    commission?: number
    serviceDate: Date | string
    address: string
    notes?: string | null
    cancelledBy?: string | null
    cancelReason?: string | null
    cancelledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    users_orders_customerIdTousers: usersCreateNestedOneWithoutOrders_orders_customerIdTousersInput
    users_orders_providerIdTousers: usersCreateNestedOneWithoutOrders_orders_providerIdTousersInput
    services: servicesCreateNestedOneWithoutOrdersInput
    reviews?: reviewsCreateNestedOneWithoutOrdersInput
    virtual_assignments?: virtual_assignmentsCreateNestedOneWithoutOrdersInput
  }

  export type ordersUncheckedCreateWithoutCall_sessionsInput = {
    id: string
    customerId: string
    providerId: string
    serviceId: string
    status?: $Enums.OrderStatus
    totalAmount: number
    commission?: number
    serviceDate: Date | string
    address: string
    notes?: string | null
    cancelledBy?: string | null
    cancelReason?: string | null
    cancelledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    reviews?: reviewsUncheckedCreateNestedOneWithoutOrdersInput
    virtual_assignments?: virtual_assignmentsUncheckedCreateNestedOneWithoutOrdersInput
  }

  export type ordersCreateOrConnectWithoutCall_sessionsInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutCall_sessionsInput, ordersUncheckedCreateWithoutCall_sessionsInput>
  }

  export type usersCreateWithoutCall_sessions_call_sessions_providerIdTousersInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    messages_messages_receiverIdTousers?: messagesCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersCreateNestedManyWithoutUsersInput
    profiles?: profilesCreateNestedOneWithoutUsersInput
    providers?: providersCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutCall_sessions_call_sessions_providerIdTousersInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsUncheckedCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    messages_messages_receiverIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsUncheckedCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersUncheckedCreateNestedManyWithoutUsersInput
    profiles?: profilesUncheckedCreateNestedOneWithoutUsersInput
    providers?: providersUncheckedCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesUncheckedCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsUncheckedCreateNestedOneWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutCall_sessions_call_sessions_providerIdTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCall_sessions_call_sessions_providerIdTousersInput, usersUncheckedCreateWithoutCall_sessions_call_sessions_providerIdTousersInput>
  }

  export type call_logsUpsertWithWhereUniqueWithoutCall_sessionsInput = {
    where: call_logsWhereUniqueInput
    update: XOR<call_logsUpdateWithoutCall_sessionsInput, call_logsUncheckedUpdateWithoutCall_sessionsInput>
    create: XOR<call_logsCreateWithoutCall_sessionsInput, call_logsUncheckedCreateWithoutCall_sessionsInput>
  }

  export type call_logsUpdateWithWhereUniqueWithoutCall_sessionsInput = {
    where: call_logsWhereUniqueInput
    data: XOR<call_logsUpdateWithoutCall_sessionsInput, call_logsUncheckedUpdateWithoutCall_sessionsInput>
  }

  export type call_logsUpdateManyWithWhereWithoutCall_sessionsInput = {
    where: call_logsScalarWhereInput
    data: XOR<call_logsUpdateManyMutationInput, call_logsUncheckedUpdateManyWithoutCall_sessionsInput>
  }

  export type call_logsScalarWhereInput = {
    AND?: call_logsScalarWhereInput | call_logsScalarWhereInput[]
    OR?: call_logsScalarWhereInput[]
    NOT?: call_logsScalarWhereInput | call_logsScalarWhereInput[]
    id?: StringFilter<"call_logs"> | string
    callSessionId?: StringFilter<"call_logs"> | string
    status?: StringFilter<"call_logs"> | string
    duration?: IntNullableFilter<"call_logs"> | number | null
    timestamp?: DateTimeFilter<"call_logs"> | Date | string
  }

  export type usersUpsertWithoutCall_sessions_call_sessions_customerIdTousersInput = {
    update: XOR<usersUpdateWithoutCall_sessions_call_sessions_customerIdTousersInput, usersUncheckedUpdateWithoutCall_sessions_call_sessions_customerIdTousersInput>
    create: XOR<usersCreateWithoutCall_sessions_call_sessions_customerIdTousersInput, usersUncheckedCreateWithoutCall_sessions_call_sessions_customerIdTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCall_sessions_call_sessions_customerIdTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCall_sessions_call_sessions_customerIdTousersInput, usersUncheckedUpdateWithoutCall_sessions_call_sessions_customerIdTousersInput>
  }

  export type usersUpdateWithoutCall_sessions_call_sessions_customerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUpdateManyWithoutUsersNestedInput
    profiles?: profilesUpdateOneWithoutUsersNestedInput
    providers?: providersUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutCall_sessions_call_sessions_customerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUncheckedUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUncheckedUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUncheckedUpdateManyWithoutUsersNestedInput
    profiles?: profilesUncheckedUpdateOneWithoutUsersNestedInput
    providers?: providersUncheckedUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUncheckedUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUncheckedUpdateOneWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type ordersUpsertWithoutCall_sessionsInput = {
    update: XOR<ordersUpdateWithoutCall_sessionsInput, ordersUncheckedUpdateWithoutCall_sessionsInput>
    create: XOR<ordersCreateWithoutCall_sessionsInput, ordersUncheckedCreateWithoutCall_sessionsInput>
    where?: ordersWhereInput
  }

  export type ordersUpdateToOneWithWhereWithoutCall_sessionsInput = {
    where?: ordersWhereInput
    data: XOR<ordersUpdateWithoutCall_sessionsInput, ordersUncheckedUpdateWithoutCall_sessionsInput>
  }

  export type ordersUpdateWithoutCall_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_orders_customerIdTousers?: usersUpdateOneRequiredWithoutOrders_orders_customerIdTousersNestedInput
    users_orders_providerIdTousers?: usersUpdateOneRequiredWithoutOrders_orders_providerIdTousersNestedInput
    services?: servicesUpdateOneRequiredWithoutOrdersNestedInput
    reviews?: reviewsUpdateOneWithoutOrdersNestedInput
    virtual_assignments?: virtual_assignmentsUpdateOneWithoutOrdersNestedInput
  }

  export type ordersUncheckedUpdateWithoutCall_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: reviewsUncheckedUpdateOneWithoutOrdersNestedInput
    virtual_assignments?: virtual_assignmentsUncheckedUpdateOneWithoutOrdersNestedInput
  }

  export type usersUpsertWithoutCall_sessions_call_sessions_providerIdTousersInput = {
    update: XOR<usersUpdateWithoutCall_sessions_call_sessions_providerIdTousersInput, usersUncheckedUpdateWithoutCall_sessions_call_sessions_providerIdTousersInput>
    create: XOR<usersCreateWithoutCall_sessions_call_sessions_providerIdTousersInput, usersUncheckedCreateWithoutCall_sessions_call_sessions_providerIdTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCall_sessions_call_sessions_providerIdTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCall_sessions_call_sessions_providerIdTousersInput, usersUncheckedUpdateWithoutCall_sessions_call_sessions_providerIdTousersInput>
  }

  export type usersUpdateWithoutCall_sessions_call_sessions_providerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUpdateManyWithoutUsersNestedInput
    profiles?: profilesUpdateOneWithoutUsersNestedInput
    providers?: providersUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutCall_sessions_call_sessions_providerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUncheckedUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUncheckedUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUncheckedUpdateManyWithoutUsersNestedInput
    profiles?: profilesUncheckedUpdateOneWithoutUsersNestedInput
    providers?: providersUncheckedUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUncheckedUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUncheckedUpdateOneWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutMessages_messages_receiverIdTousersInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_senderIdTousers?: messagesCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersCreateNestedManyWithoutUsersInput
    profiles?: profilesCreateNestedOneWithoutUsersInput
    providers?: providersCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutMessages_messages_receiverIdTousersInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsUncheckedCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_senderIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsUncheckedCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersUncheckedCreateNestedManyWithoutUsersInput
    profiles?: profilesUncheckedCreateNestedOneWithoutUsersInput
    providers?: providersUncheckedCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesUncheckedCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsUncheckedCreateNestedOneWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutMessages_messages_receiverIdTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutMessages_messages_receiverIdTousersInput, usersUncheckedCreateWithoutMessages_messages_receiverIdTousersInput>
  }

  export type usersCreateWithoutMessages_messages_senderIdTousersInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    notification_preferences?: notification_preferencesCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersCreateNestedManyWithoutUsersInput
    profiles?: profilesCreateNestedOneWithoutUsersInput
    providers?: providersCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutMessages_messages_senderIdTousersInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsUncheckedCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsUncheckedCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersUncheckedCreateNestedManyWithoutUsersInput
    profiles?: profilesUncheckedCreateNestedOneWithoutUsersInput
    providers?: providersUncheckedCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesUncheckedCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsUncheckedCreateNestedOneWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutMessages_messages_senderIdTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutMessages_messages_senderIdTousersInput, usersUncheckedCreateWithoutMessages_messages_senderIdTousersInput>
  }

  export type usersUpsertWithoutMessages_messages_receiverIdTousersInput = {
    update: XOR<usersUpdateWithoutMessages_messages_receiverIdTousersInput, usersUncheckedUpdateWithoutMessages_messages_receiverIdTousersInput>
    create: XOR<usersCreateWithoutMessages_messages_receiverIdTousersInput, usersUncheckedCreateWithoutMessages_messages_receiverIdTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutMessages_messages_receiverIdTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutMessages_messages_receiverIdTousersInput, usersUncheckedUpdateWithoutMessages_messages_receiverIdTousersInput>
  }

  export type usersUpdateWithoutMessages_messages_receiverIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUpdateManyWithoutUsersNestedInput
    profiles?: profilesUpdateOneWithoutUsersNestedInput
    providers?: providersUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutMessages_messages_receiverIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUncheckedUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUncheckedUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUncheckedUpdateManyWithoutUsersNestedInput
    profiles?: profilesUncheckedUpdateOneWithoutUsersNestedInput
    providers?: providersUncheckedUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUncheckedUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUncheckedUpdateOneWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersUpsertWithoutMessages_messages_senderIdTousersInput = {
    update: XOR<usersUpdateWithoutMessages_messages_senderIdTousersInput, usersUncheckedUpdateWithoutMessages_messages_senderIdTousersInput>
    create: XOR<usersCreateWithoutMessages_messages_senderIdTousersInput, usersUncheckedCreateWithoutMessages_messages_senderIdTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutMessages_messages_senderIdTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutMessages_messages_senderIdTousersInput, usersUncheckedUpdateWithoutMessages_messages_senderIdTousersInput>
  }

  export type usersUpdateWithoutMessages_messages_senderIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    notification_preferences?: notification_preferencesUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUpdateManyWithoutUsersNestedInput
    profiles?: profilesUpdateOneWithoutUsersNestedInput
    providers?: providersUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutMessages_messages_senderIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUncheckedUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUncheckedUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUncheckedUpdateManyWithoutUsersNestedInput
    profiles?: profilesUncheckedUpdateOneWithoutUsersNestedInput
    providers?: providersUncheckedUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUncheckedUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUncheckedUpdateOneWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutNotification_preferencesInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_tokens?: notification_tokensCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersCreateNestedManyWithoutUsersInput
    profiles?: profilesCreateNestedOneWithoutUsersInput
    providers?: providersCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutNotification_preferencesInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsUncheckedCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_tokens?: notification_tokensUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsUncheckedCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersUncheckedCreateNestedManyWithoutUsersInput
    profiles?: profilesUncheckedCreateNestedOneWithoutUsersInput
    providers?: providersUncheckedCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesUncheckedCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsUncheckedCreateNestedOneWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutNotification_preferencesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNotification_preferencesInput, usersUncheckedCreateWithoutNotification_preferencesInput>
  }

  export type usersUpsertWithoutNotification_preferencesInput = {
    update: XOR<usersUpdateWithoutNotification_preferencesInput, usersUncheckedUpdateWithoutNotification_preferencesInput>
    create: XOR<usersCreateWithoutNotification_preferencesInput, usersUncheckedCreateWithoutNotification_preferencesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutNotification_preferencesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutNotification_preferencesInput, usersUncheckedUpdateWithoutNotification_preferencesInput>
  }

  export type usersUpdateWithoutNotification_preferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_tokens?: notification_tokensUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUpdateManyWithoutUsersNestedInput
    profiles?: profilesUpdateOneWithoutUsersNestedInput
    providers?: providersUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutNotification_preferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUncheckedUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_tokens?: notification_tokensUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUncheckedUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUncheckedUpdateManyWithoutUsersNestedInput
    profiles?: profilesUncheckedUpdateOneWithoutUsersNestedInput
    providers?: providersUncheckedUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUncheckedUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUncheckedUpdateOneWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutNotification_tokensInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesCreateNestedOneWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersCreateNestedManyWithoutUsersInput
    profiles?: profilesCreateNestedOneWithoutUsersInput
    providers?: providersCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutNotification_tokensInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsUncheckedCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedOneWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsUncheckedCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersUncheckedCreateNestedManyWithoutUsersInput
    profiles?: profilesUncheckedCreateNestedOneWithoutUsersInput
    providers?: providersUncheckedCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesUncheckedCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsUncheckedCreateNestedOneWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutNotification_tokensInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNotification_tokensInput, usersUncheckedCreateWithoutNotification_tokensInput>
  }

  export type usersUpsertWithoutNotification_tokensInput = {
    update: XOR<usersUpdateWithoutNotification_tokensInput, usersUncheckedUpdateWithoutNotification_tokensInput>
    create: XOR<usersCreateWithoutNotification_tokensInput, usersUncheckedCreateWithoutNotification_tokensInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutNotification_tokensInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutNotification_tokensInput, usersUncheckedUpdateWithoutNotification_tokensInput>
  }

  export type usersUpdateWithoutNotification_tokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUpdateOneWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUpdateManyWithoutUsersNestedInput
    profiles?: profilesUpdateOneWithoutUsersNestedInput
    providers?: providersUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutNotification_tokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUncheckedUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateOneWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUncheckedUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUncheckedUpdateManyWithoutUsersNestedInput
    profiles?: profilesUncheckedUpdateOneWithoutUsersNestedInput
    providers?: providersUncheckedUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUncheckedUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUncheckedUpdateOneWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutNotificationsInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersCreateNestedManyWithoutUsersInput
    profiles?: profilesCreateNestedOneWithoutUsersInput
    providers?: providersCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutNotificationsInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsUncheckedCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensUncheckedCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsUncheckedCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersUncheckedCreateNestedManyWithoutUsersInput
    profiles?: profilesUncheckedCreateNestedOneWithoutUsersInput
    providers?: providersUncheckedCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesUncheckedCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsUncheckedCreateNestedOneWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutNotificationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
  }

  export type usersUpsertWithoutNotificationsInput = {
    update: XOR<usersUpdateWithoutNotificationsInput, usersUncheckedUpdateWithoutNotificationsInput>
    create: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutNotificationsInput, usersUncheckedUpdateWithoutNotificationsInput>
  }

  export type usersUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUpdateManyWithoutUsersNestedInput
    profiles?: profilesUpdateOneWithoutUsersNestedInput
    providers?: providersUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUncheckedUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUncheckedUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUncheckedUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUncheckedUpdateManyWithoutUsersNestedInput
    profiles?: profilesUncheckedUpdateOneWithoutUsersNestedInput
    providers?: providersUncheckedUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUncheckedUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUncheckedUpdateOneWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type call_sessionsCreateWithoutOrdersInput = {
    id: string
    twilioCallSid?: string | null
    customerPhone: string
    providerPhone: string
    status?: string
    duration?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    call_logs?: call_logsCreateNestedManyWithoutCall_sessionsInput
    users_call_sessions_customerIdTousers: usersCreateNestedOneWithoutCall_sessions_call_sessions_customerIdTousersInput
    users_call_sessions_providerIdTousers: usersCreateNestedOneWithoutCall_sessions_call_sessions_providerIdTousersInput
  }

  export type call_sessionsUncheckedCreateWithoutOrdersInput = {
    id: string
    customerId: string
    providerId: string
    twilioCallSid?: string | null
    customerPhone: string
    providerPhone: string
    status?: string
    duration?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    call_logs?: call_logsUncheckedCreateNestedManyWithoutCall_sessionsInput
  }

  export type call_sessionsCreateOrConnectWithoutOrdersInput = {
    where: call_sessionsWhereUniqueInput
    create: XOR<call_sessionsCreateWithoutOrdersInput, call_sessionsUncheckedCreateWithoutOrdersInput>
  }

  export type call_sessionsCreateManyOrdersInputEnvelope = {
    data: call_sessionsCreateManyOrdersInput | call_sessionsCreateManyOrdersInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutOrders_orders_customerIdTousersInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    orders_orders_providerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersCreateNestedManyWithoutUsersInput
    profiles?: profilesCreateNestedOneWithoutUsersInput
    providers?: providersCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutOrders_orders_customerIdTousersInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsUncheckedCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    orders_orders_providerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsUncheckedCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersUncheckedCreateNestedManyWithoutUsersInput
    profiles?: profilesUncheckedCreateNestedOneWithoutUsersInput
    providers?: providersUncheckedCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesUncheckedCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsUncheckedCreateNestedOneWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutOrders_orders_customerIdTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutOrders_orders_customerIdTousersInput, usersUncheckedCreateWithoutOrders_orders_customerIdTousersInput>
  }

  export type usersCreateWithoutOrders_orders_providerIdTousersInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    otps?: otpsCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersCreateNestedManyWithoutUsersInput
    profiles?: profilesCreateNestedOneWithoutUsersInput
    providers?: providersCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutOrders_orders_providerIdTousersInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsUncheckedCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    otps?: otpsUncheckedCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersUncheckedCreateNestedManyWithoutUsersInput
    profiles?: profilesUncheckedCreateNestedOneWithoutUsersInput
    providers?: providersUncheckedCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesUncheckedCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsUncheckedCreateNestedOneWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutOrders_orders_providerIdTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutOrders_orders_providerIdTousersInput, usersUncheckedCreateWithoutOrders_orders_providerIdTousersInput>
  }

  export type servicesCreateWithoutOrdersInput = {
    id: string
    name: string
    description: string
    category: string
    price: number
    basePrice?: number | null
    offerPercent?: number | null
    estimatedTime?: number | null
    warrantyMonths?: number | null
    duration: number
    status?: string
    isActive?: boolean
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    providers: providersCreateNestedOneWithoutServicesInput
  }

  export type servicesUncheckedCreateWithoutOrdersInput = {
    id: string
    providerId: string
    name: string
    description: string
    category: string
    price: number
    basePrice?: number | null
    offerPercent?: number | null
    estimatedTime?: number | null
    warrantyMonths?: number | null
    duration: number
    status?: string
    isActive?: boolean
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type servicesCreateOrConnectWithoutOrdersInput = {
    where: servicesWhereUniqueInput
    create: XOR<servicesCreateWithoutOrdersInput, servicesUncheckedCreateWithoutOrdersInput>
  }

  export type reviewsCreateWithoutOrdersInput = {
    id: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    providers?: providersCreateNestedOneWithoutReviewsInput
    users_reviews_revieweeIdTousers: usersCreateNestedOneWithoutReviews_reviews_revieweeIdTousersInput
    users_reviews_reviewerIdTousers: usersCreateNestedOneWithoutReviews_reviews_reviewerIdTousersInput
  }

  export type reviewsUncheckedCreateWithoutOrdersInput = {
    id: string
    reviewerId: string
    revieweeId: string
    providerId?: string | null
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type reviewsCreateOrConnectWithoutOrdersInput = {
    where: reviewsWhereUniqueInput
    create: XOR<reviewsCreateWithoutOrdersInput, reviewsUncheckedCreateWithoutOrdersInput>
  }

  export type virtual_assignmentsCreateWithoutOrdersInput = {
    id: string
    status?: string
    assignedAt?: Date | string
    releasedAt?: Date | string | null
    virtual_numbers: virtual_numbersCreateNestedOneWithoutVirtual_assignmentsInput
  }

  export type virtual_assignmentsUncheckedCreateWithoutOrdersInput = {
    id: string
    virtualNumberId: string
    status?: string
    assignedAt?: Date | string
    releasedAt?: Date | string | null
  }

  export type virtual_assignmentsCreateOrConnectWithoutOrdersInput = {
    where: virtual_assignmentsWhereUniqueInput
    create: XOR<virtual_assignmentsCreateWithoutOrdersInput, virtual_assignmentsUncheckedCreateWithoutOrdersInput>
  }

  export type call_sessionsUpsertWithWhereUniqueWithoutOrdersInput = {
    where: call_sessionsWhereUniqueInput
    update: XOR<call_sessionsUpdateWithoutOrdersInput, call_sessionsUncheckedUpdateWithoutOrdersInput>
    create: XOR<call_sessionsCreateWithoutOrdersInput, call_sessionsUncheckedCreateWithoutOrdersInput>
  }

  export type call_sessionsUpdateWithWhereUniqueWithoutOrdersInput = {
    where: call_sessionsWhereUniqueInput
    data: XOR<call_sessionsUpdateWithoutOrdersInput, call_sessionsUncheckedUpdateWithoutOrdersInput>
  }

  export type call_sessionsUpdateManyWithWhereWithoutOrdersInput = {
    where: call_sessionsScalarWhereInput
    data: XOR<call_sessionsUpdateManyMutationInput, call_sessionsUncheckedUpdateManyWithoutOrdersInput>
  }

  export type call_sessionsScalarWhereInput = {
    AND?: call_sessionsScalarWhereInput | call_sessionsScalarWhereInput[]
    OR?: call_sessionsScalarWhereInput[]
    NOT?: call_sessionsScalarWhereInput | call_sessionsScalarWhereInput[]
    id?: StringFilter<"call_sessions"> | string
    customerId?: StringFilter<"call_sessions"> | string
    providerId?: StringFilter<"call_sessions"> | string
    orderId?: StringNullableFilter<"call_sessions"> | string | null
    twilioCallSid?: StringNullableFilter<"call_sessions"> | string | null
    customerPhone?: StringFilter<"call_sessions"> | string
    providerPhone?: StringFilter<"call_sessions"> | string
    status?: StringFilter<"call_sessions"> | string
    duration?: IntNullableFilter<"call_sessions"> | number | null
    startedAt?: DateTimeNullableFilter<"call_sessions"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"call_sessions"> | Date | string | null
    createdAt?: DateTimeFilter<"call_sessions"> | Date | string
    updatedAt?: DateTimeFilter<"call_sessions"> | Date | string
  }

  export type usersUpsertWithoutOrders_orders_customerIdTousersInput = {
    update: XOR<usersUpdateWithoutOrders_orders_customerIdTousersInput, usersUncheckedUpdateWithoutOrders_orders_customerIdTousersInput>
    create: XOR<usersCreateWithoutOrders_orders_customerIdTousersInput, usersUncheckedCreateWithoutOrders_orders_customerIdTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutOrders_orders_customerIdTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutOrders_orders_customerIdTousersInput, usersUncheckedUpdateWithoutOrders_orders_customerIdTousersInput>
  }

  export type usersUpdateWithoutOrders_orders_customerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    orders_orders_providerIdTousers?: ordersUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUpdateManyWithoutUsersNestedInput
    profiles?: profilesUpdateOneWithoutUsersNestedInput
    providers?: providersUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutOrders_orders_customerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUncheckedUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    orders_orders_providerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUncheckedUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUncheckedUpdateManyWithoutUsersNestedInput
    profiles?: profilesUncheckedUpdateOneWithoutUsersNestedInput
    providers?: providersUncheckedUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUncheckedUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUncheckedUpdateOneWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersUpsertWithoutOrders_orders_providerIdTousersInput = {
    update: XOR<usersUpdateWithoutOrders_orders_providerIdTousersInput, usersUncheckedUpdateWithoutOrders_orders_providerIdTousersInput>
    create: XOR<usersCreateWithoutOrders_orders_providerIdTousersInput, usersUncheckedCreateWithoutOrders_orders_providerIdTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutOrders_orders_providerIdTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutOrders_orders_providerIdTousersInput, usersUncheckedUpdateWithoutOrders_orders_providerIdTousersInput>
  }

  export type usersUpdateWithoutOrders_orders_providerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    otps?: otpsUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUpdateManyWithoutUsersNestedInput
    profiles?: profilesUpdateOneWithoutUsersNestedInput
    providers?: providersUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutOrders_orders_providerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUncheckedUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    otps?: otpsUncheckedUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUncheckedUpdateManyWithoutUsersNestedInput
    profiles?: profilesUncheckedUpdateOneWithoutUsersNestedInput
    providers?: providersUncheckedUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUncheckedUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUncheckedUpdateOneWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type servicesUpsertWithoutOrdersInput = {
    update: XOR<servicesUpdateWithoutOrdersInput, servicesUncheckedUpdateWithoutOrdersInput>
    create: XOR<servicesCreateWithoutOrdersInput, servicesUncheckedCreateWithoutOrdersInput>
    where?: servicesWhereInput
  }

  export type servicesUpdateToOneWithWhereWithoutOrdersInput = {
    where?: servicesWhereInput
    data: XOR<servicesUpdateWithoutOrdersInput, servicesUncheckedUpdateWithoutOrdersInput>
  }

  export type servicesUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    offerPercent?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedTime?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyMonths?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providers?: providersUpdateOneRequiredWithoutServicesNestedInput
  }

  export type servicesUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    offerPercent?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedTime?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyMonths?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewsUpsertWithoutOrdersInput = {
    update: XOR<reviewsUpdateWithoutOrdersInput, reviewsUncheckedUpdateWithoutOrdersInput>
    create: XOR<reviewsCreateWithoutOrdersInput, reviewsUncheckedCreateWithoutOrdersInput>
    where?: reviewsWhereInput
  }

  export type reviewsUpdateToOneWithWhereWithoutOrdersInput = {
    where?: reviewsWhereInput
    data: XOR<reviewsUpdateWithoutOrdersInput, reviewsUncheckedUpdateWithoutOrdersInput>
  }

  export type reviewsUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providers?: providersUpdateOneWithoutReviewsNestedInput
    users_reviews_revieweeIdTousers?: usersUpdateOneRequiredWithoutReviews_reviews_revieweeIdTousersNestedInput
    users_reviews_reviewerIdTousers?: usersUpdateOneRequiredWithoutReviews_reviews_reviewerIdTousersNestedInput
  }

  export type reviewsUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type virtual_assignmentsUpsertWithoutOrdersInput = {
    update: XOR<virtual_assignmentsUpdateWithoutOrdersInput, virtual_assignmentsUncheckedUpdateWithoutOrdersInput>
    create: XOR<virtual_assignmentsCreateWithoutOrdersInput, virtual_assignmentsUncheckedCreateWithoutOrdersInput>
    where?: virtual_assignmentsWhereInput
  }

  export type virtual_assignmentsUpdateToOneWithWhereWithoutOrdersInput = {
    where?: virtual_assignmentsWhereInput
    data: XOR<virtual_assignmentsUpdateWithoutOrdersInput, virtual_assignmentsUncheckedUpdateWithoutOrdersInput>
  }

  export type virtual_assignmentsUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    virtual_numbers?: virtual_numbersUpdateOneRequiredWithoutVirtual_assignmentsNestedInput
  }

  export type virtual_assignmentsUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualNumberId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateWithoutOtpsInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    payment_orders?: payment_ordersCreateNestedManyWithoutUsersInput
    profiles?: profilesCreateNestedOneWithoutUsersInput
    providers?: providersCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutOtpsInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsUncheckedCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    payment_orders?: payment_ordersUncheckedCreateNestedManyWithoutUsersInput
    profiles?: profilesUncheckedCreateNestedOneWithoutUsersInput
    providers?: providersUncheckedCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesUncheckedCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsUncheckedCreateNestedOneWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutOtpsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutOtpsInput, usersUncheckedCreateWithoutOtpsInput>
  }

  export type usersUpsertWithoutOtpsInput = {
    update: XOR<usersUpdateWithoutOtpsInput, usersUncheckedUpdateWithoutOtpsInput>
    create: XOR<usersCreateWithoutOtpsInput, usersUncheckedCreateWithoutOtpsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutOtpsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutOtpsInput, usersUncheckedUpdateWithoutOtpsInput>
  }

  export type usersUpdateWithoutOtpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    payment_orders?: payment_ordersUpdateManyWithoutUsersNestedInput
    profiles?: profilesUpdateOneWithoutUsersNestedInput
    providers?: providersUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutOtpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUncheckedUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    payment_orders?: payment_ordersUncheckedUpdateManyWithoutUsersNestedInput
    profiles?: profilesUncheckedUpdateOneWithoutUsersNestedInput
    providers?: providersUncheckedUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUncheckedUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUncheckedUpdateOneWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutPayment_ordersInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsCreateNestedManyWithoutUsersInput
    profiles?: profilesCreateNestedOneWithoutUsersInput
    providers?: providersCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutPayment_ordersInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsUncheckedCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsUncheckedCreateNestedManyWithoutUsersInput
    profiles?: profilesUncheckedCreateNestedOneWithoutUsersInput
    providers?: providersUncheckedCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesUncheckedCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsUncheckedCreateNestedOneWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutPayment_ordersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPayment_ordersInput, usersUncheckedCreateWithoutPayment_ordersInput>
  }

  export type usersUpsertWithoutPayment_ordersInput = {
    update: XOR<usersUpdateWithoutPayment_ordersInput, usersUncheckedUpdateWithoutPayment_ordersInput>
    create: XOR<usersCreateWithoutPayment_ordersInput, usersUncheckedCreateWithoutPayment_ordersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutPayment_ordersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutPayment_ordersInput, usersUncheckedUpdateWithoutPayment_ordersInput>
  }

  export type usersUpdateWithoutPayment_ordersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUpdateManyWithoutUsersNestedInput
    profiles?: profilesUpdateOneWithoutUsersNestedInput
    providers?: providersUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutPayment_ordersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUncheckedUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUncheckedUpdateManyWithoutUsersNestedInput
    profiles?: profilesUncheckedUpdateOneWithoutUsersNestedInput
    providers?: providersUncheckedUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUncheckedUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUncheckedUpdateOneWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutProfilesInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersCreateNestedManyWithoutUsersInput
    providers?: providersCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutProfilesInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsUncheckedCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsUncheckedCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersUncheckedCreateNestedManyWithoutUsersInput
    providers?: providersUncheckedCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesUncheckedCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsUncheckedCreateNestedOneWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutProfilesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutProfilesInput, usersUncheckedCreateWithoutProfilesInput>
  }

  export type usersUpsertWithoutProfilesInput = {
    update: XOR<usersUpdateWithoutProfilesInput, usersUncheckedUpdateWithoutProfilesInput>
    create: XOR<usersCreateWithoutProfilesInput, usersUncheckedCreateWithoutProfilesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutProfilesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutProfilesInput, usersUncheckedUpdateWithoutProfilesInput>
  }

  export type usersUpdateWithoutProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUpdateManyWithoutUsersNestedInput
    providers?: providersUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUncheckedUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUncheckedUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUncheckedUpdateManyWithoutUsersNestedInput
    providers?: providersUncheckedUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUncheckedUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUncheckedUpdateOneWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type providersCreateWithoutProvider_locationsInput = {
    id: string
    businessName: string
    providerType: $Enums.ProviderType
    category: string
    area: string
    address: string
    panNumber: string
    aadhaarNumber: string
    gstNumber?: string | null
    bankAccount?: string | null
    upiId?: string | null
    isVerified?: boolean
    isActive?: boolean
    rating?: number
    totalOrders?: number
    isOnline?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    users: usersCreateNestedOneWithoutProvidersInput
    reviews?: reviewsCreateNestedManyWithoutProvidersInput
    services?: servicesCreateNestedManyWithoutProvidersInput
  }

  export type providersUncheckedCreateWithoutProvider_locationsInput = {
    id: string
    userId: string
    businessName: string
    providerType: $Enums.ProviderType
    category: string
    area: string
    address: string
    panNumber: string
    aadhaarNumber: string
    gstNumber?: string | null
    bankAccount?: string | null
    upiId?: string | null
    isVerified?: boolean
    isActive?: boolean
    rating?: number
    totalOrders?: number
    isOnline?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    reviews?: reviewsUncheckedCreateNestedManyWithoutProvidersInput
    services?: servicesUncheckedCreateNestedManyWithoutProvidersInput
  }

  export type providersCreateOrConnectWithoutProvider_locationsInput = {
    where: providersWhereUniqueInput
    create: XOR<providersCreateWithoutProvider_locationsInput, providersUncheckedCreateWithoutProvider_locationsInput>
  }

  export type zonesCreateWithoutProvider_locationsInput = {
    id: string
    name: string
    city: string
    polygon: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type zonesUncheckedCreateWithoutProvider_locationsInput = {
    id: string
    name: string
    city: string
    polygon: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type zonesCreateOrConnectWithoutProvider_locationsInput = {
    where: zonesWhereUniqueInput
    create: XOR<zonesCreateWithoutProvider_locationsInput, zonesUncheckedCreateWithoutProvider_locationsInput>
  }

  export type providersUpsertWithoutProvider_locationsInput = {
    update: XOR<providersUpdateWithoutProvider_locationsInput, providersUncheckedUpdateWithoutProvider_locationsInput>
    create: XOR<providersCreateWithoutProvider_locationsInput, providersUncheckedCreateWithoutProvider_locationsInput>
    where?: providersWhereInput
  }

  export type providersUpdateToOneWithWhereWithoutProvider_locationsInput = {
    where?: providersWhereInput
    data: XOR<providersUpdateWithoutProvider_locationsInput, providersUncheckedUpdateWithoutProvider_locationsInput>
  }

  export type providersUpdateWithoutProvider_locationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    category?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    panNumber?: StringFieldUpdateOperationsInput | string
    aadhaarNumber?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutProvidersNestedInput
    reviews?: reviewsUpdateManyWithoutProvidersNestedInput
    services?: servicesUpdateManyWithoutProvidersNestedInput
  }

  export type providersUncheckedUpdateWithoutProvider_locationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    category?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    panNumber?: StringFieldUpdateOperationsInput | string
    aadhaarNumber?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: reviewsUncheckedUpdateManyWithoutProvidersNestedInput
    services?: servicesUncheckedUpdateManyWithoutProvidersNestedInput
  }

  export type zonesUpsertWithoutProvider_locationsInput = {
    update: XOR<zonesUpdateWithoutProvider_locationsInput, zonesUncheckedUpdateWithoutProvider_locationsInput>
    create: XOR<zonesCreateWithoutProvider_locationsInput, zonesUncheckedCreateWithoutProvider_locationsInput>
    where?: zonesWhereInput
  }

  export type zonesUpdateToOneWithWhereWithoutProvider_locationsInput = {
    where?: zonesWhereInput
    data: XOR<zonesUpdateWithoutProvider_locationsInput, zonesUncheckedUpdateWithoutProvider_locationsInput>
  }

  export type zonesUpdateWithoutProvider_locationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    polygon?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type zonesUncheckedUpdateWithoutProvider_locationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    polygon?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type provider_locationsCreateWithoutProvidersInput = {
    id: string
    lat: number
    lng: number
    address?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    zones?: zonesCreateNestedOneWithoutProvider_locationsInput
  }

  export type provider_locationsUncheckedCreateWithoutProvidersInput = {
    id: string
    lat: number
    lng: number
    address?: string | null
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type provider_locationsCreateOrConnectWithoutProvidersInput = {
    where: provider_locationsWhereUniqueInput
    create: XOR<provider_locationsCreateWithoutProvidersInput, provider_locationsUncheckedCreateWithoutProvidersInput>
  }

  export type provider_locationsCreateManyProvidersInputEnvelope = {
    data: provider_locationsCreateManyProvidersInput | provider_locationsCreateManyProvidersInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutProvidersInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersCreateNestedManyWithoutUsersInput
    profiles?: profilesCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutProvidersInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsUncheckedCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsUncheckedCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersUncheckedCreateNestedManyWithoutUsersInput
    profiles?: profilesUncheckedCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesUncheckedCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsUncheckedCreateNestedOneWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutProvidersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutProvidersInput, usersUncheckedCreateWithoutProvidersInput>
  }

  export type reviewsCreateWithoutProvidersInput = {
    id: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    orders: ordersCreateNestedOneWithoutReviewsInput
    users_reviews_revieweeIdTousers: usersCreateNestedOneWithoutReviews_reviews_revieweeIdTousersInput
    users_reviews_reviewerIdTousers: usersCreateNestedOneWithoutReviews_reviews_reviewerIdTousersInput
  }

  export type reviewsUncheckedCreateWithoutProvidersInput = {
    id: string
    orderId: string
    reviewerId: string
    revieweeId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type reviewsCreateOrConnectWithoutProvidersInput = {
    where: reviewsWhereUniqueInput
    create: XOR<reviewsCreateWithoutProvidersInput, reviewsUncheckedCreateWithoutProvidersInput>
  }

  export type reviewsCreateManyProvidersInputEnvelope = {
    data: reviewsCreateManyProvidersInput | reviewsCreateManyProvidersInput[]
    skipDuplicates?: boolean
  }

  export type servicesCreateWithoutProvidersInput = {
    id: string
    name: string
    description: string
    category: string
    price: number
    basePrice?: number | null
    offerPercent?: number | null
    estimatedTime?: number | null
    warrantyMonths?: number | null
    duration: number
    status?: string
    isActive?: boolean
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    orders?: ordersCreateNestedManyWithoutServicesInput
  }

  export type servicesUncheckedCreateWithoutProvidersInput = {
    id: string
    name: string
    description: string
    category: string
    price: number
    basePrice?: number | null
    offerPercent?: number | null
    estimatedTime?: number | null
    warrantyMonths?: number | null
    duration: number
    status?: string
    isActive?: boolean
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    orders?: ordersUncheckedCreateNestedManyWithoutServicesInput
  }

  export type servicesCreateOrConnectWithoutProvidersInput = {
    where: servicesWhereUniqueInput
    create: XOR<servicesCreateWithoutProvidersInput, servicesUncheckedCreateWithoutProvidersInput>
  }

  export type servicesCreateManyProvidersInputEnvelope = {
    data: servicesCreateManyProvidersInput | servicesCreateManyProvidersInput[]
    skipDuplicates?: boolean
  }

  export type provider_locationsUpsertWithWhereUniqueWithoutProvidersInput = {
    where: provider_locationsWhereUniqueInput
    update: XOR<provider_locationsUpdateWithoutProvidersInput, provider_locationsUncheckedUpdateWithoutProvidersInput>
    create: XOR<provider_locationsCreateWithoutProvidersInput, provider_locationsUncheckedCreateWithoutProvidersInput>
  }

  export type provider_locationsUpdateWithWhereUniqueWithoutProvidersInput = {
    where: provider_locationsWhereUniqueInput
    data: XOR<provider_locationsUpdateWithoutProvidersInput, provider_locationsUncheckedUpdateWithoutProvidersInput>
  }

  export type provider_locationsUpdateManyWithWhereWithoutProvidersInput = {
    where: provider_locationsScalarWhereInput
    data: XOR<provider_locationsUpdateManyMutationInput, provider_locationsUncheckedUpdateManyWithoutProvidersInput>
  }

  export type provider_locationsScalarWhereInput = {
    AND?: provider_locationsScalarWhereInput | provider_locationsScalarWhereInput[]
    OR?: provider_locationsScalarWhereInput[]
    NOT?: provider_locationsScalarWhereInput | provider_locationsScalarWhereInput[]
    id?: StringFilter<"provider_locations"> | string
    providerId?: StringFilter<"provider_locations"> | string
    lat?: FloatFilter<"provider_locations"> | number
    lng?: FloatFilter<"provider_locations"> | number
    address?: StringNullableFilter<"provider_locations"> | string | null
    zoneId?: StringNullableFilter<"provider_locations"> | string | null
    createdAt?: DateTimeFilter<"provider_locations"> | Date | string
    updatedAt?: DateTimeFilter<"provider_locations"> | Date | string
  }

  export type usersUpsertWithoutProvidersInput = {
    update: XOR<usersUpdateWithoutProvidersInput, usersUncheckedUpdateWithoutProvidersInput>
    create: XOR<usersCreateWithoutProvidersInput, usersUncheckedCreateWithoutProvidersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutProvidersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutProvidersInput, usersUncheckedUpdateWithoutProvidersInput>
  }

  export type usersUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUpdateManyWithoutUsersNestedInput
    profiles?: profilesUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUncheckedUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUncheckedUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUncheckedUpdateManyWithoutUsersNestedInput
    profiles?: profilesUncheckedUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUncheckedUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUncheckedUpdateOneWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type reviewsUpsertWithWhereUniqueWithoutProvidersInput = {
    where: reviewsWhereUniqueInput
    update: XOR<reviewsUpdateWithoutProvidersInput, reviewsUncheckedUpdateWithoutProvidersInput>
    create: XOR<reviewsCreateWithoutProvidersInput, reviewsUncheckedCreateWithoutProvidersInput>
  }

  export type reviewsUpdateWithWhereUniqueWithoutProvidersInput = {
    where: reviewsWhereUniqueInput
    data: XOR<reviewsUpdateWithoutProvidersInput, reviewsUncheckedUpdateWithoutProvidersInput>
  }

  export type reviewsUpdateManyWithWhereWithoutProvidersInput = {
    where: reviewsScalarWhereInput
    data: XOR<reviewsUpdateManyMutationInput, reviewsUncheckedUpdateManyWithoutProvidersInput>
  }

  export type reviewsScalarWhereInput = {
    AND?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
    OR?: reviewsScalarWhereInput[]
    NOT?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
    id?: StringFilter<"reviews"> | string
    orderId?: StringFilter<"reviews"> | string
    reviewerId?: StringFilter<"reviews"> | string
    revieweeId?: StringFilter<"reviews"> | string
    providerId?: StringNullableFilter<"reviews"> | string | null
    rating?: IntFilter<"reviews"> | number
    comment?: StringNullableFilter<"reviews"> | string | null
    createdAt?: DateTimeFilter<"reviews"> | Date | string
  }

  export type servicesUpsertWithWhereUniqueWithoutProvidersInput = {
    where: servicesWhereUniqueInput
    update: XOR<servicesUpdateWithoutProvidersInput, servicesUncheckedUpdateWithoutProvidersInput>
    create: XOR<servicesCreateWithoutProvidersInput, servicesUncheckedCreateWithoutProvidersInput>
  }

  export type servicesUpdateWithWhereUniqueWithoutProvidersInput = {
    where: servicesWhereUniqueInput
    data: XOR<servicesUpdateWithoutProvidersInput, servicesUncheckedUpdateWithoutProvidersInput>
  }

  export type servicesUpdateManyWithWhereWithoutProvidersInput = {
    where: servicesScalarWhereInput
    data: XOR<servicesUpdateManyMutationInput, servicesUncheckedUpdateManyWithoutProvidersInput>
  }

  export type servicesScalarWhereInput = {
    AND?: servicesScalarWhereInput | servicesScalarWhereInput[]
    OR?: servicesScalarWhereInput[]
    NOT?: servicesScalarWhereInput | servicesScalarWhereInput[]
    id?: StringFilter<"services"> | string
    providerId?: StringFilter<"services"> | string
    name?: StringFilter<"services"> | string
    description?: StringFilter<"services"> | string
    category?: StringFilter<"services"> | string
    price?: FloatFilter<"services"> | number
    basePrice?: FloatNullableFilter<"services"> | number | null
    offerPercent?: IntNullableFilter<"services"> | number | null
    estimatedTime?: IntNullableFilter<"services"> | number | null
    warrantyMonths?: IntNullableFilter<"services"> | number | null
    duration?: IntFilter<"services"> | number
    status?: StringFilter<"services"> | string
    isActive?: BoolFilter<"services"> | boolean
    rejectionReason?: StringNullableFilter<"services"> | string | null
    createdAt?: DateTimeFilter<"services"> | Date | string
    updatedAt?: DateTimeFilter<"services"> | Date | string
  }

  export type usersCreateWithoutReport_schedulesInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersCreateNestedManyWithoutUsersInput
    profiles?: profilesCreateNestedOneWithoutUsersInput
    providers?: providersCreateNestedOneWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutReport_schedulesInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsUncheckedCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsUncheckedCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersUncheckedCreateNestedManyWithoutUsersInput
    profiles?: profilesUncheckedCreateNestedOneWithoutUsersInput
    providers?: providersUncheckedCreateNestedOneWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsUncheckedCreateNestedOneWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutReport_schedulesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutReport_schedulesInput, usersUncheckedCreateWithoutReport_schedulesInput>
  }

  export type usersUpsertWithoutReport_schedulesInput = {
    update: XOR<usersUpdateWithoutReport_schedulesInput, usersUncheckedUpdateWithoutReport_schedulesInput>
    create: XOR<usersCreateWithoutReport_schedulesInput, usersUncheckedCreateWithoutReport_schedulesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutReport_schedulesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutReport_schedulesInput, usersUncheckedUpdateWithoutReport_schedulesInput>
  }

  export type usersUpdateWithoutReport_schedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUpdateManyWithoutUsersNestedInput
    profiles?: profilesUpdateOneWithoutUsersNestedInput
    providers?: providersUpdateOneWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutReport_schedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUncheckedUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUncheckedUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUncheckedUpdateManyWithoutUsersNestedInput
    profiles?: profilesUncheckedUpdateOneWithoutUsersNestedInput
    providers?: providersUncheckedUpdateOneWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUncheckedUpdateOneWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type ordersCreateWithoutReviewsInput = {
    id: string
    status?: $Enums.OrderStatus
    totalAmount: number
    commission?: number
    serviceDate: Date | string
    address: string
    notes?: string | null
    cancelledBy?: string | null
    cancelReason?: string | null
    cancelledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    call_sessions?: call_sessionsCreateNestedManyWithoutOrdersInput
    users_orders_customerIdTousers: usersCreateNestedOneWithoutOrders_orders_customerIdTousersInput
    users_orders_providerIdTousers: usersCreateNestedOneWithoutOrders_orders_providerIdTousersInput
    services: servicesCreateNestedOneWithoutOrdersInput
    virtual_assignments?: virtual_assignmentsCreateNestedOneWithoutOrdersInput
  }

  export type ordersUncheckedCreateWithoutReviewsInput = {
    id: string
    customerId: string
    providerId: string
    serviceId: string
    status?: $Enums.OrderStatus
    totalAmount: number
    commission?: number
    serviceDate: Date | string
    address: string
    notes?: string | null
    cancelledBy?: string | null
    cancelReason?: string | null
    cancelledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    call_sessions?: call_sessionsUncheckedCreateNestedManyWithoutOrdersInput
    virtual_assignments?: virtual_assignmentsUncheckedCreateNestedOneWithoutOrdersInput
  }

  export type ordersCreateOrConnectWithoutReviewsInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutReviewsInput, ordersUncheckedCreateWithoutReviewsInput>
  }

  export type providersCreateWithoutReviewsInput = {
    id: string
    businessName: string
    providerType: $Enums.ProviderType
    category: string
    area: string
    address: string
    panNumber: string
    aadhaarNumber: string
    gstNumber?: string | null
    bankAccount?: string | null
    upiId?: string | null
    isVerified?: boolean
    isActive?: boolean
    rating?: number
    totalOrders?: number
    isOnline?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    provider_locations?: provider_locationsCreateNestedManyWithoutProvidersInput
    users: usersCreateNestedOneWithoutProvidersInput
    services?: servicesCreateNestedManyWithoutProvidersInput
  }

  export type providersUncheckedCreateWithoutReviewsInput = {
    id: string
    userId: string
    businessName: string
    providerType: $Enums.ProviderType
    category: string
    area: string
    address: string
    panNumber: string
    aadhaarNumber: string
    gstNumber?: string | null
    bankAccount?: string | null
    upiId?: string | null
    isVerified?: boolean
    isActive?: boolean
    rating?: number
    totalOrders?: number
    isOnline?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    provider_locations?: provider_locationsUncheckedCreateNestedManyWithoutProvidersInput
    services?: servicesUncheckedCreateNestedManyWithoutProvidersInput
  }

  export type providersCreateOrConnectWithoutReviewsInput = {
    where: providersWhereUniqueInput
    create: XOR<providersCreateWithoutReviewsInput, providersUncheckedCreateWithoutReviewsInput>
  }

  export type usersCreateWithoutReviews_reviews_revieweeIdTousersInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersCreateNestedManyWithoutUsersInput
    profiles?: profilesCreateNestedOneWithoutUsersInput
    providers?: providersCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesCreateNestedManyWithoutUsersInput
    reviews_reviews_reviewerIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutReviews_reviews_revieweeIdTousersInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsUncheckedCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsUncheckedCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersUncheckedCreateNestedManyWithoutUsersInput
    profiles?: profilesUncheckedCreateNestedOneWithoutUsersInput
    providers?: providersUncheckedCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesUncheckedCreateNestedManyWithoutUsersInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsUncheckedCreateNestedOneWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutReviews_reviews_revieweeIdTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutReviews_reviews_revieweeIdTousersInput, usersUncheckedCreateWithoutReviews_reviews_revieweeIdTousersInput>
  }

  export type usersCreateWithoutReviews_reviews_reviewerIdTousersInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersCreateNestedManyWithoutUsersInput
    profiles?: profilesCreateNestedOneWithoutUsersInput
    providers?: providersCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    tickets?: ticketsCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutReviews_reviews_reviewerIdTousersInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsUncheckedCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsUncheckedCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersUncheckedCreateNestedManyWithoutUsersInput
    profiles?: profilesUncheckedCreateNestedOneWithoutUsersInput
    providers?: providersUncheckedCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesUncheckedCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsUncheckedCreateNestedOneWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutReviews_reviews_reviewerIdTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutReviews_reviews_reviewerIdTousersInput, usersUncheckedCreateWithoutReviews_reviews_reviewerIdTousersInput>
  }

  export type ordersUpsertWithoutReviewsInput = {
    update: XOR<ordersUpdateWithoutReviewsInput, ordersUncheckedUpdateWithoutReviewsInput>
    create: XOR<ordersCreateWithoutReviewsInput, ordersUncheckedCreateWithoutReviewsInput>
    where?: ordersWhereInput
  }

  export type ordersUpdateToOneWithWhereWithoutReviewsInput = {
    where?: ordersWhereInput
    data: XOR<ordersUpdateWithoutReviewsInput, ordersUncheckedUpdateWithoutReviewsInput>
  }

  export type ordersUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    call_sessions?: call_sessionsUpdateManyWithoutOrdersNestedInput
    users_orders_customerIdTousers?: usersUpdateOneRequiredWithoutOrders_orders_customerIdTousersNestedInput
    users_orders_providerIdTousers?: usersUpdateOneRequiredWithoutOrders_orders_providerIdTousersNestedInput
    services?: servicesUpdateOneRequiredWithoutOrdersNestedInput
    virtual_assignments?: virtual_assignmentsUpdateOneWithoutOrdersNestedInput
  }

  export type ordersUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    call_sessions?: call_sessionsUncheckedUpdateManyWithoutOrdersNestedInput
    virtual_assignments?: virtual_assignmentsUncheckedUpdateOneWithoutOrdersNestedInput
  }

  export type providersUpsertWithoutReviewsInput = {
    update: XOR<providersUpdateWithoutReviewsInput, providersUncheckedUpdateWithoutReviewsInput>
    create: XOR<providersCreateWithoutReviewsInput, providersUncheckedCreateWithoutReviewsInput>
    where?: providersWhereInput
  }

  export type providersUpdateToOneWithWhereWithoutReviewsInput = {
    where?: providersWhereInput
    data: XOR<providersUpdateWithoutReviewsInput, providersUncheckedUpdateWithoutReviewsInput>
  }

  export type providersUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    category?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    panNumber?: StringFieldUpdateOperationsInput | string
    aadhaarNumber?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_locations?: provider_locationsUpdateManyWithoutProvidersNestedInput
    users?: usersUpdateOneRequiredWithoutProvidersNestedInput
    services?: servicesUpdateManyWithoutProvidersNestedInput
  }

  export type providersUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    category?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    panNumber?: StringFieldUpdateOperationsInput | string
    aadhaarNumber?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_locations?: provider_locationsUncheckedUpdateManyWithoutProvidersNestedInput
    services?: servicesUncheckedUpdateManyWithoutProvidersNestedInput
  }

  export type usersUpsertWithoutReviews_reviews_revieweeIdTousersInput = {
    update: XOR<usersUpdateWithoutReviews_reviews_revieweeIdTousersInput, usersUncheckedUpdateWithoutReviews_reviews_revieweeIdTousersInput>
    create: XOR<usersCreateWithoutReviews_reviews_revieweeIdTousersInput, usersUncheckedCreateWithoutReviews_reviews_revieweeIdTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutReviews_reviews_revieweeIdTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutReviews_reviews_revieweeIdTousersInput, usersUncheckedUpdateWithoutReviews_reviews_revieweeIdTousersInput>
  }

  export type usersUpdateWithoutReviews_reviews_revieweeIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUpdateManyWithoutUsersNestedInput
    profiles?: profilesUpdateOneWithoutUsersNestedInput
    providers?: providersUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUpdateManyWithoutUsersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutReviews_reviews_revieweeIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUncheckedUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUncheckedUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUncheckedUpdateManyWithoutUsersNestedInput
    profiles?: profilesUncheckedUpdateOneWithoutUsersNestedInput
    providers?: providersUncheckedUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUncheckedUpdateManyWithoutUsersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUncheckedUpdateOneWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersUpsertWithoutReviews_reviews_reviewerIdTousersInput = {
    update: XOR<usersUpdateWithoutReviews_reviews_reviewerIdTousersInput, usersUncheckedUpdateWithoutReviews_reviews_reviewerIdTousersInput>
    create: XOR<usersCreateWithoutReviews_reviews_reviewerIdTousersInput, usersUncheckedCreateWithoutReviews_reviews_reviewerIdTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutReviews_reviews_reviewerIdTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutReviews_reviews_reviewerIdTousersInput, usersUncheckedUpdateWithoutReviews_reviews_reviewerIdTousersInput>
  }

  export type usersUpdateWithoutReviews_reviews_reviewerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUpdateManyWithoutUsersNestedInput
    profiles?: profilesUpdateOneWithoutUsersNestedInput
    providers?: providersUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    tickets?: ticketsUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutReviews_reviews_reviewerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUncheckedUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUncheckedUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUncheckedUpdateManyWithoutUsersNestedInput
    profiles?: profilesUncheckedUpdateOneWithoutUsersNestedInput
    providers?: providersUncheckedUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUncheckedUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUncheckedUpdateOneWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type ordersCreateWithoutServicesInput = {
    id: string
    status?: $Enums.OrderStatus
    totalAmount: number
    commission?: number
    serviceDate: Date | string
    address: string
    notes?: string | null
    cancelledBy?: string | null
    cancelReason?: string | null
    cancelledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    call_sessions?: call_sessionsCreateNestedManyWithoutOrdersInput
    users_orders_customerIdTousers: usersCreateNestedOneWithoutOrders_orders_customerIdTousersInput
    users_orders_providerIdTousers: usersCreateNestedOneWithoutOrders_orders_providerIdTousersInput
    reviews?: reviewsCreateNestedOneWithoutOrdersInput
    virtual_assignments?: virtual_assignmentsCreateNestedOneWithoutOrdersInput
  }

  export type ordersUncheckedCreateWithoutServicesInput = {
    id: string
    customerId: string
    providerId: string
    status?: $Enums.OrderStatus
    totalAmount: number
    commission?: number
    serviceDate: Date | string
    address: string
    notes?: string | null
    cancelledBy?: string | null
    cancelReason?: string | null
    cancelledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    call_sessions?: call_sessionsUncheckedCreateNestedManyWithoutOrdersInput
    reviews?: reviewsUncheckedCreateNestedOneWithoutOrdersInput
    virtual_assignments?: virtual_assignmentsUncheckedCreateNestedOneWithoutOrdersInput
  }

  export type ordersCreateOrConnectWithoutServicesInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutServicesInput, ordersUncheckedCreateWithoutServicesInput>
  }

  export type ordersCreateManyServicesInputEnvelope = {
    data: ordersCreateManyServicesInput | ordersCreateManyServicesInput[]
    skipDuplicates?: boolean
  }

  export type providersCreateWithoutServicesInput = {
    id: string
    businessName: string
    providerType: $Enums.ProviderType
    category: string
    area: string
    address: string
    panNumber: string
    aadhaarNumber: string
    gstNumber?: string | null
    bankAccount?: string | null
    upiId?: string | null
    isVerified?: boolean
    isActive?: boolean
    rating?: number
    totalOrders?: number
    isOnline?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    provider_locations?: provider_locationsCreateNestedManyWithoutProvidersInput
    users: usersCreateNestedOneWithoutProvidersInput
    reviews?: reviewsCreateNestedManyWithoutProvidersInput
  }

  export type providersUncheckedCreateWithoutServicesInput = {
    id: string
    userId: string
    businessName: string
    providerType: $Enums.ProviderType
    category: string
    area: string
    address: string
    panNumber: string
    aadhaarNumber: string
    gstNumber?: string | null
    bankAccount?: string | null
    upiId?: string | null
    isVerified?: boolean
    isActive?: boolean
    rating?: number
    totalOrders?: number
    isOnline?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    provider_locations?: provider_locationsUncheckedCreateNestedManyWithoutProvidersInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutProvidersInput
  }

  export type providersCreateOrConnectWithoutServicesInput = {
    where: providersWhereUniqueInput
    create: XOR<providersCreateWithoutServicesInput, providersUncheckedCreateWithoutServicesInput>
  }

  export type ordersUpsertWithWhereUniqueWithoutServicesInput = {
    where: ordersWhereUniqueInput
    update: XOR<ordersUpdateWithoutServicesInput, ordersUncheckedUpdateWithoutServicesInput>
    create: XOR<ordersCreateWithoutServicesInput, ordersUncheckedCreateWithoutServicesInput>
  }

  export type ordersUpdateWithWhereUniqueWithoutServicesInput = {
    where: ordersWhereUniqueInput
    data: XOR<ordersUpdateWithoutServicesInput, ordersUncheckedUpdateWithoutServicesInput>
  }

  export type ordersUpdateManyWithWhereWithoutServicesInput = {
    where: ordersScalarWhereInput
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyWithoutServicesInput>
  }

  export type ordersScalarWhereInput = {
    AND?: ordersScalarWhereInput | ordersScalarWhereInput[]
    OR?: ordersScalarWhereInput[]
    NOT?: ordersScalarWhereInput | ordersScalarWhereInput[]
    id?: StringFilter<"orders"> | string
    customerId?: StringFilter<"orders"> | string
    providerId?: StringFilter<"orders"> | string
    serviceId?: StringFilter<"orders"> | string
    status?: EnumOrderStatusFilter<"orders"> | $Enums.OrderStatus
    totalAmount?: FloatFilter<"orders"> | number
    commission?: FloatFilter<"orders"> | number
    serviceDate?: DateTimeFilter<"orders"> | Date | string
    address?: StringFilter<"orders"> | string
    notes?: StringNullableFilter<"orders"> | string | null
    cancelledBy?: StringNullableFilter<"orders"> | string | null
    cancelReason?: StringNullableFilter<"orders"> | string | null
    cancelledAt?: DateTimeNullableFilter<"orders"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"orders"> | Date | string | null
    createdAt?: DateTimeFilter<"orders"> | Date | string
    updatedAt?: DateTimeFilter<"orders"> | Date | string
  }

  export type providersUpsertWithoutServicesInput = {
    update: XOR<providersUpdateWithoutServicesInput, providersUncheckedUpdateWithoutServicesInput>
    create: XOR<providersCreateWithoutServicesInput, providersUncheckedCreateWithoutServicesInput>
    where?: providersWhereInput
  }

  export type providersUpdateToOneWithWhereWithoutServicesInput = {
    where?: providersWhereInput
    data: XOR<providersUpdateWithoutServicesInput, providersUncheckedUpdateWithoutServicesInput>
  }

  export type providersUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    category?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    panNumber?: StringFieldUpdateOperationsInput | string
    aadhaarNumber?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_locations?: provider_locationsUpdateManyWithoutProvidersNestedInput
    users?: usersUpdateOneRequiredWithoutProvidersNestedInput
    reviews?: reviewsUpdateManyWithoutProvidersNestedInput
  }

  export type providersUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    category?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    panNumber?: StringFieldUpdateOperationsInput | string
    aadhaarNumber?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_locations?: provider_locationsUncheckedUpdateManyWithoutProvidersNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutProvidersNestedInput
  }

  export type usersCreateWithoutTicketsInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersCreateNestedManyWithoutUsersInput
    profiles?: profilesCreateNestedOneWithoutUsersInput
    providers?: providersCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutTicketsInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsUncheckedCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsUncheckedCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersUncheckedCreateNestedManyWithoutUsersInput
    profiles?: profilesUncheckedCreateNestedOneWithoutUsersInput
    providers?: providersUncheckedCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesUncheckedCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsUncheckedCreateNestedOneWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutTicketsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTicketsInput, usersUncheckedCreateWithoutTicketsInput>
  }

  export type usersUpsertWithoutTicketsInput = {
    update: XOR<usersUpdateWithoutTicketsInput, usersUncheckedUpdateWithoutTicketsInput>
    create: XOR<usersCreateWithoutTicketsInput, usersUncheckedCreateWithoutTicketsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTicketsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTicketsInput, usersUncheckedUpdateWithoutTicketsInput>
  }

  export type usersUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUpdateManyWithoutUsersNestedInput
    profiles?: profilesUpdateOneWithoutUsersNestedInput
    providers?: providersUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUncheckedUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUncheckedUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUncheckedUpdateManyWithoutUsersNestedInput
    profiles?: profilesUncheckedUpdateOneWithoutUsersNestedInput
    providers?: providersUncheckedUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUncheckedUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUncheckedUpdateOneWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type walletsCreateWithoutTransactionsInput = {
    id: string
    balance?: number
    createdAt?: Date | string
    updatedAt: Date | string
    users: usersCreateNestedOneWithoutWalletsInput
  }

  export type walletsUncheckedCreateWithoutTransactionsInput = {
    id: string
    userId: string
    balance?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type walletsCreateOrConnectWithoutTransactionsInput = {
    where: walletsWhereUniqueInput
    create: XOR<walletsCreateWithoutTransactionsInput, walletsUncheckedCreateWithoutTransactionsInput>
  }

  export type walletsUpsertWithoutTransactionsInput = {
    update: XOR<walletsUpdateWithoutTransactionsInput, walletsUncheckedUpdateWithoutTransactionsInput>
    create: XOR<walletsCreateWithoutTransactionsInput, walletsUncheckedCreateWithoutTransactionsInput>
    where?: walletsWhereInput
  }

  export type walletsUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: walletsWhereInput
    data: XOR<walletsUpdateWithoutTransactionsInput, walletsUncheckedUpdateWithoutTransactionsInput>
  }

  export type walletsUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutWalletsNestedInput
  }

  export type walletsUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateWithoutUser_payment_methodsInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersCreateNestedManyWithoutUsersInput
    profiles?: profilesCreateNestedOneWithoutUsersInput
    providers?: providersCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsCreateNestedOneWithoutUsersInput
    wallets?: walletsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_payment_methodsInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsUncheckedCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsUncheckedCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersUncheckedCreateNestedManyWithoutUsersInput
    profiles?: profilesUncheckedCreateNestedOneWithoutUsersInput
    providers?: providersUncheckedCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesUncheckedCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsUncheckedCreateNestedOneWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUser_payment_methodsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_payment_methodsInput, usersUncheckedCreateWithoutUser_payment_methodsInput>
  }

  export type usersUpsertWithoutUser_payment_methodsInput = {
    update: XOR<usersUpdateWithoutUser_payment_methodsInput, usersUncheckedUpdateWithoutUser_payment_methodsInput>
    create: XOR<usersCreateWithoutUser_payment_methodsInput, usersUncheckedCreateWithoutUser_payment_methodsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_payment_methodsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_payment_methodsInput, usersUncheckedUpdateWithoutUser_payment_methodsInput>
  }

  export type usersUpdateWithoutUser_payment_methodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUpdateManyWithoutUsersNestedInput
    profiles?: profilesUpdateOneWithoutUsersNestedInput
    providers?: providersUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUpdateOneWithoutUsersNestedInput
    wallets?: walletsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_payment_methodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUncheckedUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUncheckedUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUncheckedUpdateManyWithoutUsersNestedInput
    profiles?: profilesUncheckedUpdateOneWithoutUsersNestedInput
    providers?: providersUncheckedUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUncheckedUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUncheckedUpdateOneWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutUser_verificationsInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersCreateNestedManyWithoutUsersInput
    profiles?: profilesCreateNestedOneWithoutUsersInput
    providers?: providersCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    wallets?: walletsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_verificationsInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsUncheckedCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsUncheckedCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersUncheckedCreateNestedManyWithoutUsersInput
    profiles?: profilesUncheckedCreateNestedOneWithoutUsersInput
    providers?: providersUncheckedCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesUncheckedCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    wallets?: walletsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUser_verificationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_verificationsInput, usersUncheckedCreateWithoutUser_verificationsInput>
  }

  export type usersUpsertWithoutUser_verificationsInput = {
    update: XOR<usersUpdateWithoutUser_verificationsInput, usersUncheckedUpdateWithoutUser_verificationsInput>
    create: XOR<usersCreateWithoutUser_verificationsInput, usersUncheckedCreateWithoutUser_verificationsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_verificationsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_verificationsInput, usersUncheckedUpdateWithoutUser_verificationsInput>
  }

  export type usersUpdateWithoutUser_verificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUpdateManyWithoutUsersNestedInput
    profiles?: profilesUpdateOneWithoutUsersNestedInput
    providers?: providersUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    wallets?: walletsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_verificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUncheckedUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUncheckedUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUncheckedUpdateManyWithoutUsersNestedInput
    profiles?: profilesUncheckedUpdateOneWithoutUsersNestedInput
    providers?: providersUncheckedUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUncheckedUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    wallets?: walletsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type admin_actionsCreateWithoutUsersInput = {
    id: string
    action: string
    targetId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type admin_actionsUncheckedCreateWithoutUsersInput = {
    id: string
    action: string
    targetId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type admin_actionsCreateOrConnectWithoutUsersInput = {
    where: admin_actionsWhereUniqueInput
    create: XOR<admin_actionsCreateWithoutUsersInput, admin_actionsUncheckedCreateWithoutUsersInput>
  }

  export type admin_actionsCreateManyUsersInputEnvelope = {
    data: admin_actionsCreateManyUsersInput | admin_actionsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type call_sessionsCreateWithoutUsers_call_sessions_customerIdTousersInput = {
    id: string
    twilioCallSid?: string | null
    customerPhone: string
    providerPhone: string
    status?: string
    duration?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    call_logs?: call_logsCreateNestedManyWithoutCall_sessionsInput
    orders?: ordersCreateNestedOneWithoutCall_sessionsInput
    users_call_sessions_providerIdTousers: usersCreateNestedOneWithoutCall_sessions_call_sessions_providerIdTousersInput
  }

  export type call_sessionsUncheckedCreateWithoutUsers_call_sessions_customerIdTousersInput = {
    id: string
    providerId: string
    orderId?: string | null
    twilioCallSid?: string | null
    customerPhone: string
    providerPhone: string
    status?: string
    duration?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    call_logs?: call_logsUncheckedCreateNestedManyWithoutCall_sessionsInput
  }

  export type call_sessionsCreateOrConnectWithoutUsers_call_sessions_customerIdTousersInput = {
    where: call_sessionsWhereUniqueInput
    create: XOR<call_sessionsCreateWithoutUsers_call_sessions_customerIdTousersInput, call_sessionsUncheckedCreateWithoutUsers_call_sessions_customerIdTousersInput>
  }

  export type call_sessionsCreateManyUsers_call_sessions_customerIdTousersInputEnvelope = {
    data: call_sessionsCreateManyUsers_call_sessions_customerIdTousersInput | call_sessionsCreateManyUsers_call_sessions_customerIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type call_sessionsCreateWithoutUsers_call_sessions_providerIdTousersInput = {
    id: string
    twilioCallSid?: string | null
    customerPhone: string
    providerPhone: string
    status?: string
    duration?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    call_logs?: call_logsCreateNestedManyWithoutCall_sessionsInput
    users_call_sessions_customerIdTousers: usersCreateNestedOneWithoutCall_sessions_call_sessions_customerIdTousersInput
    orders?: ordersCreateNestedOneWithoutCall_sessionsInput
  }

  export type call_sessionsUncheckedCreateWithoutUsers_call_sessions_providerIdTousersInput = {
    id: string
    customerId: string
    orderId?: string | null
    twilioCallSid?: string | null
    customerPhone: string
    providerPhone: string
    status?: string
    duration?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    call_logs?: call_logsUncheckedCreateNestedManyWithoutCall_sessionsInput
  }

  export type call_sessionsCreateOrConnectWithoutUsers_call_sessions_providerIdTousersInput = {
    where: call_sessionsWhereUniqueInput
    create: XOR<call_sessionsCreateWithoutUsers_call_sessions_providerIdTousersInput, call_sessionsUncheckedCreateWithoutUsers_call_sessions_providerIdTousersInput>
  }

  export type call_sessionsCreateManyUsers_call_sessions_providerIdTousersInputEnvelope = {
    data: call_sessionsCreateManyUsers_call_sessions_providerIdTousersInput | call_sessionsCreateManyUsers_call_sessions_providerIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type messagesCreateWithoutUsers_messages_receiverIdTousersInput = {
    id: string
    content: string
    orderId?: string | null
    createdAt?: Date | string
    users_messages_senderIdTousers: usersCreateNestedOneWithoutMessages_messages_senderIdTousersInput
  }

  export type messagesUncheckedCreateWithoutUsers_messages_receiverIdTousersInput = {
    id: string
    senderId: string
    content: string
    orderId?: string | null
    createdAt?: Date | string
  }

  export type messagesCreateOrConnectWithoutUsers_messages_receiverIdTousersInput = {
    where: messagesWhereUniqueInput
    create: XOR<messagesCreateWithoutUsers_messages_receiverIdTousersInput, messagesUncheckedCreateWithoutUsers_messages_receiverIdTousersInput>
  }

  export type messagesCreateManyUsers_messages_receiverIdTousersInputEnvelope = {
    data: messagesCreateManyUsers_messages_receiverIdTousersInput | messagesCreateManyUsers_messages_receiverIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type messagesCreateWithoutUsers_messages_senderIdTousersInput = {
    id: string
    content: string
    orderId?: string | null
    createdAt?: Date | string
    users_messages_receiverIdTousers: usersCreateNestedOneWithoutMessages_messages_receiverIdTousersInput
  }

  export type messagesUncheckedCreateWithoutUsers_messages_senderIdTousersInput = {
    id: string
    receiverId: string
    content: string
    orderId?: string | null
    createdAt?: Date | string
  }

  export type messagesCreateOrConnectWithoutUsers_messages_senderIdTousersInput = {
    where: messagesWhereUniqueInput
    create: XOR<messagesCreateWithoutUsers_messages_senderIdTousersInput, messagesUncheckedCreateWithoutUsers_messages_senderIdTousersInput>
  }

  export type messagesCreateManyUsers_messages_senderIdTousersInputEnvelope = {
    data: messagesCreateManyUsers_messages_senderIdTousersInput | messagesCreateManyUsers_messages_senderIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type notification_preferencesCreateWithoutUsersInput = {
    id: string
    pushEnabled?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    orderUpdates?: boolean
    messages?: boolean
    promotions?: boolean
    systemAlerts?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type notification_preferencesUncheckedCreateWithoutUsersInput = {
    id: string
    pushEnabled?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    orderUpdates?: boolean
    messages?: boolean
    promotions?: boolean
    systemAlerts?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type notification_preferencesCreateOrConnectWithoutUsersInput = {
    where: notification_preferencesWhereUniqueInput
    create: XOR<notification_preferencesCreateWithoutUsersInput, notification_preferencesUncheckedCreateWithoutUsersInput>
  }

  export type notification_tokensCreateWithoutUsersInput = {
    id: string
    token: string
    platform?: string | null
    createdAt?: Date | string
  }

  export type notification_tokensUncheckedCreateWithoutUsersInput = {
    id: string
    token: string
    platform?: string | null
    createdAt?: Date | string
  }

  export type notification_tokensCreateOrConnectWithoutUsersInput = {
    where: notification_tokensWhereUniqueInput
    create: XOR<notification_tokensCreateWithoutUsersInput, notification_tokensUncheckedCreateWithoutUsersInput>
  }

  export type notification_tokensCreateManyUsersInputEnvelope = {
    data: notification_tokensCreateManyUsersInput | notification_tokensCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type notificationsCreateWithoutUsersInput = {
    id: string
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    type: string
    status?: string
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type notificationsUncheckedCreateWithoutUsersInput = {
    id: string
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    type: string
    status?: string
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type notificationsCreateOrConnectWithoutUsersInput = {
    where: notificationsWhereUniqueInput
    create: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput>
  }

  export type notificationsCreateManyUsersInputEnvelope = {
    data: notificationsCreateManyUsersInput | notificationsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type ordersCreateWithoutUsers_orders_customerIdTousersInput = {
    id: string
    status?: $Enums.OrderStatus
    totalAmount: number
    commission?: number
    serviceDate: Date | string
    address: string
    notes?: string | null
    cancelledBy?: string | null
    cancelReason?: string | null
    cancelledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    call_sessions?: call_sessionsCreateNestedManyWithoutOrdersInput
    users_orders_providerIdTousers: usersCreateNestedOneWithoutOrders_orders_providerIdTousersInput
    services: servicesCreateNestedOneWithoutOrdersInput
    reviews?: reviewsCreateNestedOneWithoutOrdersInput
    virtual_assignments?: virtual_assignmentsCreateNestedOneWithoutOrdersInput
  }

  export type ordersUncheckedCreateWithoutUsers_orders_customerIdTousersInput = {
    id: string
    providerId: string
    serviceId: string
    status?: $Enums.OrderStatus
    totalAmount: number
    commission?: number
    serviceDate: Date | string
    address: string
    notes?: string | null
    cancelledBy?: string | null
    cancelReason?: string | null
    cancelledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    call_sessions?: call_sessionsUncheckedCreateNestedManyWithoutOrdersInput
    reviews?: reviewsUncheckedCreateNestedOneWithoutOrdersInput
    virtual_assignments?: virtual_assignmentsUncheckedCreateNestedOneWithoutOrdersInput
  }

  export type ordersCreateOrConnectWithoutUsers_orders_customerIdTousersInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutUsers_orders_customerIdTousersInput, ordersUncheckedCreateWithoutUsers_orders_customerIdTousersInput>
  }

  export type ordersCreateManyUsers_orders_customerIdTousersInputEnvelope = {
    data: ordersCreateManyUsers_orders_customerIdTousersInput | ordersCreateManyUsers_orders_customerIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type ordersCreateWithoutUsers_orders_providerIdTousersInput = {
    id: string
    status?: $Enums.OrderStatus
    totalAmount: number
    commission?: number
    serviceDate: Date | string
    address: string
    notes?: string | null
    cancelledBy?: string | null
    cancelReason?: string | null
    cancelledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    call_sessions?: call_sessionsCreateNestedManyWithoutOrdersInput
    users_orders_customerIdTousers: usersCreateNestedOneWithoutOrders_orders_customerIdTousersInput
    services: servicesCreateNestedOneWithoutOrdersInput
    reviews?: reviewsCreateNestedOneWithoutOrdersInput
    virtual_assignments?: virtual_assignmentsCreateNestedOneWithoutOrdersInput
  }

  export type ordersUncheckedCreateWithoutUsers_orders_providerIdTousersInput = {
    id: string
    customerId: string
    serviceId: string
    status?: $Enums.OrderStatus
    totalAmount: number
    commission?: number
    serviceDate: Date | string
    address: string
    notes?: string | null
    cancelledBy?: string | null
    cancelReason?: string | null
    cancelledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    call_sessions?: call_sessionsUncheckedCreateNestedManyWithoutOrdersInput
    reviews?: reviewsUncheckedCreateNestedOneWithoutOrdersInput
    virtual_assignments?: virtual_assignmentsUncheckedCreateNestedOneWithoutOrdersInput
  }

  export type ordersCreateOrConnectWithoutUsers_orders_providerIdTousersInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutUsers_orders_providerIdTousersInput, ordersUncheckedCreateWithoutUsers_orders_providerIdTousersInput>
  }

  export type ordersCreateManyUsers_orders_providerIdTousersInputEnvelope = {
    data: ordersCreateManyUsers_orders_providerIdTousersInput | ordersCreateManyUsers_orders_providerIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type otpsCreateWithoutUsersInput = {
    id: string
    code: string
    type: string
    isUsed?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type otpsUncheckedCreateWithoutUsersInput = {
    id: string
    code: string
    type: string
    isUsed?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type otpsCreateOrConnectWithoutUsersInput = {
    where: otpsWhereUniqueInput
    create: XOR<otpsCreateWithoutUsersInput, otpsUncheckedCreateWithoutUsersInput>
  }

  export type otpsCreateManyUsersInputEnvelope = {
    data: otpsCreateManyUsersInput | otpsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type payment_ordersCreateWithoutUsersInput = {
    id: string
    orderId: string
    paymentId?: string | null
    amount: number
    currency?: string
    paymentMethod: string
    status?: string
    type: string
    signature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type payment_ordersUncheckedCreateWithoutUsersInput = {
    id: string
    orderId: string
    paymentId?: string | null
    amount: number
    currency?: string
    paymentMethod: string
    status?: string
    type: string
    signature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type payment_ordersCreateOrConnectWithoutUsersInput = {
    where: payment_ordersWhereUniqueInput
    create: XOR<payment_ordersCreateWithoutUsersInput, payment_ordersUncheckedCreateWithoutUsersInput>
  }

  export type payment_ordersCreateManyUsersInputEnvelope = {
    data: payment_ordersCreateManyUsersInput | payment_ordersCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type profilesCreateWithoutUsersInput = {
    id: string
    firstName: string
    lastName: string
    avatar?: string | null
    address?: string | null
    pincode?: string | null
    city?: string | null
    state?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt: Date | string
    passwordHash?: string | null
    googleId?: string | null
    googleVerified?: boolean
  }

  export type profilesUncheckedCreateWithoutUsersInput = {
    id: string
    firstName: string
    lastName: string
    avatar?: string | null
    address?: string | null
    pincode?: string | null
    city?: string | null
    state?: string | null
    country?: string
    createdAt?: Date | string
    updatedAt: Date | string
    passwordHash?: string | null
    googleId?: string | null
    googleVerified?: boolean
  }

  export type profilesCreateOrConnectWithoutUsersInput = {
    where: profilesWhereUniqueInput
    create: XOR<profilesCreateWithoutUsersInput, profilesUncheckedCreateWithoutUsersInput>
  }

  export type providersCreateWithoutUsersInput = {
    id: string
    businessName: string
    providerType: $Enums.ProviderType
    category: string
    area: string
    address: string
    panNumber: string
    aadhaarNumber: string
    gstNumber?: string | null
    bankAccount?: string | null
    upiId?: string | null
    isVerified?: boolean
    isActive?: boolean
    rating?: number
    totalOrders?: number
    isOnline?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    provider_locations?: provider_locationsCreateNestedManyWithoutProvidersInput
    reviews?: reviewsCreateNestedManyWithoutProvidersInput
    services?: servicesCreateNestedManyWithoutProvidersInput
  }

  export type providersUncheckedCreateWithoutUsersInput = {
    id: string
    businessName: string
    providerType: $Enums.ProviderType
    category: string
    area: string
    address: string
    panNumber: string
    aadhaarNumber: string
    gstNumber?: string | null
    bankAccount?: string | null
    upiId?: string | null
    isVerified?: boolean
    isActive?: boolean
    rating?: number
    totalOrders?: number
    isOnline?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    provider_locations?: provider_locationsUncheckedCreateNestedManyWithoutProvidersInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutProvidersInput
    services?: servicesUncheckedCreateNestedManyWithoutProvidersInput
  }

  export type providersCreateOrConnectWithoutUsersInput = {
    where: providersWhereUniqueInput
    create: XOR<providersCreateWithoutUsersInput, providersUncheckedCreateWithoutUsersInput>
  }

  export type report_schedulesCreateWithoutUsersInput = {
    id: string
    reportType: string
    frequency: string
    email: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type report_schedulesUncheckedCreateWithoutUsersInput = {
    id: string
    reportType: string
    frequency: string
    email: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type report_schedulesCreateOrConnectWithoutUsersInput = {
    where: report_schedulesWhereUniqueInput
    create: XOR<report_schedulesCreateWithoutUsersInput, report_schedulesUncheckedCreateWithoutUsersInput>
  }

  export type report_schedulesCreateManyUsersInputEnvelope = {
    data: report_schedulesCreateManyUsersInput | report_schedulesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type reviewsCreateWithoutUsers_reviews_revieweeIdTousersInput = {
    id: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    orders: ordersCreateNestedOneWithoutReviewsInput
    providers?: providersCreateNestedOneWithoutReviewsInput
    users_reviews_reviewerIdTousers: usersCreateNestedOneWithoutReviews_reviews_reviewerIdTousersInput
  }

  export type reviewsUncheckedCreateWithoutUsers_reviews_revieweeIdTousersInput = {
    id: string
    orderId: string
    reviewerId: string
    providerId?: string | null
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type reviewsCreateOrConnectWithoutUsers_reviews_revieweeIdTousersInput = {
    where: reviewsWhereUniqueInput
    create: XOR<reviewsCreateWithoutUsers_reviews_revieweeIdTousersInput, reviewsUncheckedCreateWithoutUsers_reviews_revieweeIdTousersInput>
  }

  export type reviewsCreateManyUsers_reviews_revieweeIdTousersInputEnvelope = {
    data: reviewsCreateManyUsers_reviews_revieweeIdTousersInput | reviewsCreateManyUsers_reviews_revieweeIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type reviewsCreateWithoutUsers_reviews_reviewerIdTousersInput = {
    id: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    orders: ordersCreateNestedOneWithoutReviewsInput
    providers?: providersCreateNestedOneWithoutReviewsInput
    users_reviews_revieweeIdTousers: usersCreateNestedOneWithoutReviews_reviews_revieweeIdTousersInput
  }

  export type reviewsUncheckedCreateWithoutUsers_reviews_reviewerIdTousersInput = {
    id: string
    orderId: string
    revieweeId: string
    providerId?: string | null
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type reviewsCreateOrConnectWithoutUsers_reviews_reviewerIdTousersInput = {
    where: reviewsWhereUniqueInput
    create: XOR<reviewsCreateWithoutUsers_reviews_reviewerIdTousersInput, reviewsUncheckedCreateWithoutUsers_reviews_reviewerIdTousersInput>
  }

  export type reviewsCreateManyUsers_reviews_reviewerIdTousersInputEnvelope = {
    data: reviewsCreateManyUsers_reviews_reviewerIdTousersInput | reviewsCreateManyUsers_reviews_reviewerIdTousersInput[]
    skipDuplicates?: boolean
  }

  export type ticketsCreateWithoutUsersInput = {
    id: string
    subject: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ticketsUncheckedCreateWithoutUsersInput = {
    id: string
    subject: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ticketsCreateOrConnectWithoutUsersInput = {
    where: ticketsWhereUniqueInput
    create: XOR<ticketsCreateWithoutUsersInput, ticketsUncheckedCreateWithoutUsersInput>
  }

  export type ticketsCreateManyUsersInputEnvelope = {
    data: ticketsCreateManyUsersInput | ticketsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type user_payment_methodsCreateWithoutUsersInput = {
    id: string
    type: string
    provider?: string | null
    upiId?: string | null
    cardNumber?: string | null
    cardName?: string | null
    expiryMonth?: string | null
    expiryYear?: string | null
    last4?: string | null
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type user_payment_methodsUncheckedCreateWithoutUsersInput = {
    id: string
    type: string
    provider?: string | null
    upiId?: string | null
    cardNumber?: string | null
    cardName?: string | null
    expiryMonth?: string | null
    expiryYear?: string | null
    last4?: string | null
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type user_payment_methodsCreateOrConnectWithoutUsersInput = {
    where: user_payment_methodsWhereUniqueInput
    create: XOR<user_payment_methodsCreateWithoutUsersInput, user_payment_methodsUncheckedCreateWithoutUsersInput>
  }

  export type user_payment_methodsCreateManyUsersInputEnvelope = {
    data: user_payment_methodsCreateManyUsersInput | user_payment_methodsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type user_verificationsCreateWithoutUsersInput = {
    id: string
    idType: string
    idNumber: string
    idFrontImage: string
    idBackImage?: string | null
    addressProofType: string
    addressProofNumber: string
    addressProofImage: string
    verificationStatus?: string
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type user_verificationsUncheckedCreateWithoutUsersInput = {
    id: string
    idType: string
    idNumber: string
    idFrontImage: string
    idBackImage?: string | null
    addressProofType: string
    addressProofNumber: string
    addressProofImage: string
    verificationStatus?: string
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type user_verificationsCreateOrConnectWithoutUsersInput = {
    where: user_verificationsWhereUniqueInput
    create: XOR<user_verificationsCreateWithoutUsersInput, user_verificationsUncheckedCreateWithoutUsersInput>
  }

  export type walletsCreateWithoutUsersInput = {
    id: string
    balance?: number
    createdAt?: Date | string
    updatedAt: Date | string
    transactions?: transactionsCreateNestedManyWithoutWalletsInput
  }

  export type walletsUncheckedCreateWithoutUsersInput = {
    id: string
    balance?: number
    createdAt?: Date | string
    updatedAt: Date | string
    transactions?: transactionsUncheckedCreateNestedManyWithoutWalletsInput
  }

  export type walletsCreateOrConnectWithoutUsersInput = {
    where: walletsWhereUniqueInput
    create: XOR<walletsCreateWithoutUsersInput, walletsUncheckedCreateWithoutUsersInput>
  }

  export type admin_actionsUpsertWithWhereUniqueWithoutUsersInput = {
    where: admin_actionsWhereUniqueInput
    update: XOR<admin_actionsUpdateWithoutUsersInput, admin_actionsUncheckedUpdateWithoutUsersInput>
    create: XOR<admin_actionsCreateWithoutUsersInput, admin_actionsUncheckedCreateWithoutUsersInput>
  }

  export type admin_actionsUpdateWithWhereUniqueWithoutUsersInput = {
    where: admin_actionsWhereUniqueInput
    data: XOR<admin_actionsUpdateWithoutUsersInput, admin_actionsUncheckedUpdateWithoutUsersInput>
  }

  export type admin_actionsUpdateManyWithWhereWithoutUsersInput = {
    where: admin_actionsScalarWhereInput
    data: XOR<admin_actionsUpdateManyMutationInput, admin_actionsUncheckedUpdateManyWithoutUsersInput>
  }

  export type admin_actionsScalarWhereInput = {
    AND?: admin_actionsScalarWhereInput | admin_actionsScalarWhereInput[]
    OR?: admin_actionsScalarWhereInput[]
    NOT?: admin_actionsScalarWhereInput | admin_actionsScalarWhereInput[]
    id?: StringFilter<"admin_actions"> | string
    adminId?: StringFilter<"admin_actions"> | string
    action?: StringFilter<"admin_actions"> | string
    targetId?: StringFilter<"admin_actions"> | string
    details?: JsonNullableFilter<"admin_actions">
    createdAt?: DateTimeFilter<"admin_actions"> | Date | string
  }

  export type call_sessionsUpsertWithWhereUniqueWithoutUsers_call_sessions_customerIdTousersInput = {
    where: call_sessionsWhereUniqueInput
    update: XOR<call_sessionsUpdateWithoutUsers_call_sessions_customerIdTousersInput, call_sessionsUncheckedUpdateWithoutUsers_call_sessions_customerIdTousersInput>
    create: XOR<call_sessionsCreateWithoutUsers_call_sessions_customerIdTousersInput, call_sessionsUncheckedCreateWithoutUsers_call_sessions_customerIdTousersInput>
  }

  export type call_sessionsUpdateWithWhereUniqueWithoutUsers_call_sessions_customerIdTousersInput = {
    where: call_sessionsWhereUniqueInput
    data: XOR<call_sessionsUpdateWithoutUsers_call_sessions_customerIdTousersInput, call_sessionsUncheckedUpdateWithoutUsers_call_sessions_customerIdTousersInput>
  }

  export type call_sessionsUpdateManyWithWhereWithoutUsers_call_sessions_customerIdTousersInput = {
    where: call_sessionsScalarWhereInput
    data: XOR<call_sessionsUpdateManyMutationInput, call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_customerIdTousersInput>
  }

  export type call_sessionsUpsertWithWhereUniqueWithoutUsers_call_sessions_providerIdTousersInput = {
    where: call_sessionsWhereUniqueInput
    update: XOR<call_sessionsUpdateWithoutUsers_call_sessions_providerIdTousersInput, call_sessionsUncheckedUpdateWithoutUsers_call_sessions_providerIdTousersInput>
    create: XOR<call_sessionsCreateWithoutUsers_call_sessions_providerIdTousersInput, call_sessionsUncheckedCreateWithoutUsers_call_sessions_providerIdTousersInput>
  }

  export type call_sessionsUpdateWithWhereUniqueWithoutUsers_call_sessions_providerIdTousersInput = {
    where: call_sessionsWhereUniqueInput
    data: XOR<call_sessionsUpdateWithoutUsers_call_sessions_providerIdTousersInput, call_sessionsUncheckedUpdateWithoutUsers_call_sessions_providerIdTousersInput>
  }

  export type call_sessionsUpdateManyWithWhereWithoutUsers_call_sessions_providerIdTousersInput = {
    where: call_sessionsScalarWhereInput
    data: XOR<call_sessionsUpdateManyMutationInput, call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_providerIdTousersInput>
  }

  export type messagesUpsertWithWhereUniqueWithoutUsers_messages_receiverIdTousersInput = {
    where: messagesWhereUniqueInput
    update: XOR<messagesUpdateWithoutUsers_messages_receiverIdTousersInput, messagesUncheckedUpdateWithoutUsers_messages_receiverIdTousersInput>
    create: XOR<messagesCreateWithoutUsers_messages_receiverIdTousersInput, messagesUncheckedCreateWithoutUsers_messages_receiverIdTousersInput>
  }

  export type messagesUpdateWithWhereUniqueWithoutUsers_messages_receiverIdTousersInput = {
    where: messagesWhereUniqueInput
    data: XOR<messagesUpdateWithoutUsers_messages_receiverIdTousersInput, messagesUncheckedUpdateWithoutUsers_messages_receiverIdTousersInput>
  }

  export type messagesUpdateManyWithWhereWithoutUsers_messages_receiverIdTousersInput = {
    where: messagesScalarWhereInput
    data: XOR<messagesUpdateManyMutationInput, messagesUncheckedUpdateManyWithoutUsers_messages_receiverIdTousersInput>
  }

  export type messagesScalarWhereInput = {
    AND?: messagesScalarWhereInput | messagesScalarWhereInput[]
    OR?: messagesScalarWhereInput[]
    NOT?: messagesScalarWhereInput | messagesScalarWhereInput[]
    id?: StringFilter<"messages"> | string
    senderId?: StringFilter<"messages"> | string
    receiverId?: StringFilter<"messages"> | string
    content?: StringFilter<"messages"> | string
    orderId?: StringNullableFilter<"messages"> | string | null
    createdAt?: DateTimeFilter<"messages"> | Date | string
  }

  export type messagesUpsertWithWhereUniqueWithoutUsers_messages_senderIdTousersInput = {
    where: messagesWhereUniqueInput
    update: XOR<messagesUpdateWithoutUsers_messages_senderIdTousersInput, messagesUncheckedUpdateWithoutUsers_messages_senderIdTousersInput>
    create: XOR<messagesCreateWithoutUsers_messages_senderIdTousersInput, messagesUncheckedCreateWithoutUsers_messages_senderIdTousersInput>
  }

  export type messagesUpdateWithWhereUniqueWithoutUsers_messages_senderIdTousersInput = {
    where: messagesWhereUniqueInput
    data: XOR<messagesUpdateWithoutUsers_messages_senderIdTousersInput, messagesUncheckedUpdateWithoutUsers_messages_senderIdTousersInput>
  }

  export type messagesUpdateManyWithWhereWithoutUsers_messages_senderIdTousersInput = {
    where: messagesScalarWhereInput
    data: XOR<messagesUpdateManyMutationInput, messagesUncheckedUpdateManyWithoutUsers_messages_senderIdTousersInput>
  }

  export type notification_preferencesUpsertWithoutUsersInput = {
    update: XOR<notification_preferencesUpdateWithoutUsersInput, notification_preferencesUncheckedUpdateWithoutUsersInput>
    create: XOR<notification_preferencesCreateWithoutUsersInput, notification_preferencesUncheckedCreateWithoutUsersInput>
    where?: notification_preferencesWhereInput
  }

  export type notification_preferencesUpdateToOneWithWhereWithoutUsersInput = {
    where?: notification_preferencesWhereInput
    data: XOR<notification_preferencesUpdateWithoutUsersInput, notification_preferencesUncheckedUpdateWithoutUsersInput>
  }

  export type notification_preferencesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    orderUpdates?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    promotions?: BoolFieldUpdateOperationsInput | boolean
    systemAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notification_preferencesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    orderUpdates?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    promotions?: BoolFieldUpdateOperationsInput | boolean
    systemAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notification_tokensUpsertWithWhereUniqueWithoutUsersInput = {
    where: notification_tokensWhereUniqueInput
    update: XOR<notification_tokensUpdateWithoutUsersInput, notification_tokensUncheckedUpdateWithoutUsersInput>
    create: XOR<notification_tokensCreateWithoutUsersInput, notification_tokensUncheckedCreateWithoutUsersInput>
  }

  export type notification_tokensUpdateWithWhereUniqueWithoutUsersInput = {
    where: notification_tokensWhereUniqueInput
    data: XOR<notification_tokensUpdateWithoutUsersInput, notification_tokensUncheckedUpdateWithoutUsersInput>
  }

  export type notification_tokensUpdateManyWithWhereWithoutUsersInput = {
    where: notification_tokensScalarWhereInput
    data: XOR<notification_tokensUpdateManyMutationInput, notification_tokensUncheckedUpdateManyWithoutUsersInput>
  }

  export type notification_tokensScalarWhereInput = {
    AND?: notification_tokensScalarWhereInput | notification_tokensScalarWhereInput[]
    OR?: notification_tokensScalarWhereInput[]
    NOT?: notification_tokensScalarWhereInput | notification_tokensScalarWhereInput[]
    id?: StringFilter<"notification_tokens"> | string
    userId?: StringFilter<"notification_tokens"> | string
    token?: StringFilter<"notification_tokens"> | string
    platform?: StringNullableFilter<"notification_tokens"> | string | null
    createdAt?: DateTimeFilter<"notification_tokens"> | Date | string
  }

  export type notificationsUpsertWithWhereUniqueWithoutUsersInput = {
    where: notificationsWhereUniqueInput
    update: XOR<notificationsUpdateWithoutUsersInput, notificationsUncheckedUpdateWithoutUsersInput>
    create: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput>
  }

  export type notificationsUpdateWithWhereUniqueWithoutUsersInput = {
    where: notificationsWhereUniqueInput
    data: XOR<notificationsUpdateWithoutUsersInput, notificationsUncheckedUpdateWithoutUsersInput>
  }

  export type notificationsUpdateManyWithWhereWithoutUsersInput = {
    where: notificationsScalarWhereInput
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyWithoutUsersInput>
  }

  export type notificationsScalarWhereInput = {
    AND?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    OR?: notificationsScalarWhereInput[]
    NOT?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    id?: StringFilter<"notifications"> | string
    userId?: StringFilter<"notifications"> | string
    title?: StringFilter<"notifications"> | string
    body?: StringFilter<"notifications"> | string
    data?: JsonNullableFilter<"notifications">
    type?: StringFilter<"notifications"> | string
    status?: StringFilter<"notifications"> | string
    readAt?: DateTimeNullableFilter<"notifications"> | Date | string | null
    createdAt?: DateTimeFilter<"notifications"> | Date | string
  }

  export type ordersUpsertWithWhereUniqueWithoutUsers_orders_customerIdTousersInput = {
    where: ordersWhereUniqueInput
    update: XOR<ordersUpdateWithoutUsers_orders_customerIdTousersInput, ordersUncheckedUpdateWithoutUsers_orders_customerIdTousersInput>
    create: XOR<ordersCreateWithoutUsers_orders_customerIdTousersInput, ordersUncheckedCreateWithoutUsers_orders_customerIdTousersInput>
  }

  export type ordersUpdateWithWhereUniqueWithoutUsers_orders_customerIdTousersInput = {
    where: ordersWhereUniqueInput
    data: XOR<ordersUpdateWithoutUsers_orders_customerIdTousersInput, ordersUncheckedUpdateWithoutUsers_orders_customerIdTousersInput>
  }

  export type ordersUpdateManyWithWhereWithoutUsers_orders_customerIdTousersInput = {
    where: ordersScalarWhereInput
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyWithoutUsers_orders_customerIdTousersInput>
  }

  export type ordersUpsertWithWhereUniqueWithoutUsers_orders_providerIdTousersInput = {
    where: ordersWhereUniqueInput
    update: XOR<ordersUpdateWithoutUsers_orders_providerIdTousersInput, ordersUncheckedUpdateWithoutUsers_orders_providerIdTousersInput>
    create: XOR<ordersCreateWithoutUsers_orders_providerIdTousersInput, ordersUncheckedCreateWithoutUsers_orders_providerIdTousersInput>
  }

  export type ordersUpdateWithWhereUniqueWithoutUsers_orders_providerIdTousersInput = {
    where: ordersWhereUniqueInput
    data: XOR<ordersUpdateWithoutUsers_orders_providerIdTousersInput, ordersUncheckedUpdateWithoutUsers_orders_providerIdTousersInput>
  }

  export type ordersUpdateManyWithWhereWithoutUsers_orders_providerIdTousersInput = {
    where: ordersScalarWhereInput
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyWithoutUsers_orders_providerIdTousersInput>
  }

  export type otpsUpsertWithWhereUniqueWithoutUsersInput = {
    where: otpsWhereUniqueInput
    update: XOR<otpsUpdateWithoutUsersInput, otpsUncheckedUpdateWithoutUsersInput>
    create: XOR<otpsCreateWithoutUsersInput, otpsUncheckedCreateWithoutUsersInput>
  }

  export type otpsUpdateWithWhereUniqueWithoutUsersInput = {
    where: otpsWhereUniqueInput
    data: XOR<otpsUpdateWithoutUsersInput, otpsUncheckedUpdateWithoutUsersInput>
  }

  export type otpsUpdateManyWithWhereWithoutUsersInput = {
    where: otpsScalarWhereInput
    data: XOR<otpsUpdateManyMutationInput, otpsUncheckedUpdateManyWithoutUsersInput>
  }

  export type otpsScalarWhereInput = {
    AND?: otpsScalarWhereInput | otpsScalarWhereInput[]
    OR?: otpsScalarWhereInput[]
    NOT?: otpsScalarWhereInput | otpsScalarWhereInput[]
    id?: StringFilter<"otps"> | string
    userId?: StringFilter<"otps"> | string
    code?: StringFilter<"otps"> | string
    type?: StringFilter<"otps"> | string
    isUsed?: BoolFilter<"otps"> | boolean
    expiresAt?: DateTimeFilter<"otps"> | Date | string
    createdAt?: DateTimeFilter<"otps"> | Date | string
  }

  export type payment_ordersUpsertWithWhereUniqueWithoutUsersInput = {
    where: payment_ordersWhereUniqueInput
    update: XOR<payment_ordersUpdateWithoutUsersInput, payment_ordersUncheckedUpdateWithoutUsersInput>
    create: XOR<payment_ordersCreateWithoutUsersInput, payment_ordersUncheckedCreateWithoutUsersInput>
  }

  export type payment_ordersUpdateWithWhereUniqueWithoutUsersInput = {
    where: payment_ordersWhereUniqueInput
    data: XOR<payment_ordersUpdateWithoutUsersInput, payment_ordersUncheckedUpdateWithoutUsersInput>
  }

  export type payment_ordersUpdateManyWithWhereWithoutUsersInput = {
    where: payment_ordersScalarWhereInput
    data: XOR<payment_ordersUpdateManyMutationInput, payment_ordersUncheckedUpdateManyWithoutUsersInput>
  }

  export type payment_ordersScalarWhereInput = {
    AND?: payment_ordersScalarWhereInput | payment_ordersScalarWhereInput[]
    OR?: payment_ordersScalarWhereInput[]
    NOT?: payment_ordersScalarWhereInput | payment_ordersScalarWhereInput[]
    id?: StringFilter<"payment_orders"> | string
    userId?: StringFilter<"payment_orders"> | string
    orderId?: StringFilter<"payment_orders"> | string
    paymentId?: StringNullableFilter<"payment_orders"> | string | null
    amount?: FloatFilter<"payment_orders"> | number
    currency?: StringFilter<"payment_orders"> | string
    paymentMethod?: StringFilter<"payment_orders"> | string
    status?: StringFilter<"payment_orders"> | string
    type?: StringFilter<"payment_orders"> | string
    signature?: StringNullableFilter<"payment_orders"> | string | null
    metadata?: JsonNullableFilter<"payment_orders">
    createdAt?: DateTimeFilter<"payment_orders"> | Date | string
    updatedAt?: DateTimeFilter<"payment_orders"> | Date | string
  }

  export type profilesUpsertWithoutUsersInput = {
    update: XOR<profilesUpdateWithoutUsersInput, profilesUncheckedUpdateWithoutUsersInput>
    create: XOR<profilesCreateWithoutUsersInput, profilesUncheckedCreateWithoutUsersInput>
    where?: profilesWhereInput
  }

  export type profilesUpdateToOneWithWhereWithoutUsersInput = {
    where?: profilesWhereInput
    data: XOR<profilesUpdateWithoutUsersInput, profilesUncheckedUpdateWithoutUsersInput>
  }

  export type profilesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type profilesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type providersUpsertWithoutUsersInput = {
    update: XOR<providersUpdateWithoutUsersInput, providersUncheckedUpdateWithoutUsersInput>
    create: XOR<providersCreateWithoutUsersInput, providersUncheckedCreateWithoutUsersInput>
    where?: providersWhereInput
  }

  export type providersUpdateToOneWithWhereWithoutUsersInput = {
    where?: providersWhereInput
    data: XOR<providersUpdateWithoutUsersInput, providersUncheckedUpdateWithoutUsersInput>
  }

  export type providersUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    category?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    panNumber?: StringFieldUpdateOperationsInput | string
    aadhaarNumber?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_locations?: provider_locationsUpdateManyWithoutProvidersNestedInput
    reviews?: reviewsUpdateManyWithoutProvidersNestedInput
    services?: servicesUpdateManyWithoutProvidersNestedInput
  }

  export type providersUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    providerType?: EnumProviderTypeFieldUpdateOperationsInput | $Enums.ProviderType
    category?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    panNumber?: StringFieldUpdateOperationsInput | string
    aadhaarNumber?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rating?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_locations?: provider_locationsUncheckedUpdateManyWithoutProvidersNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutProvidersNestedInput
    services?: servicesUncheckedUpdateManyWithoutProvidersNestedInput
  }

  export type report_schedulesUpsertWithWhereUniqueWithoutUsersInput = {
    where: report_schedulesWhereUniqueInput
    update: XOR<report_schedulesUpdateWithoutUsersInput, report_schedulesUncheckedUpdateWithoutUsersInput>
    create: XOR<report_schedulesCreateWithoutUsersInput, report_schedulesUncheckedCreateWithoutUsersInput>
  }

  export type report_schedulesUpdateWithWhereUniqueWithoutUsersInput = {
    where: report_schedulesWhereUniqueInput
    data: XOR<report_schedulesUpdateWithoutUsersInput, report_schedulesUncheckedUpdateWithoutUsersInput>
  }

  export type report_schedulesUpdateManyWithWhereWithoutUsersInput = {
    where: report_schedulesScalarWhereInput
    data: XOR<report_schedulesUpdateManyMutationInput, report_schedulesUncheckedUpdateManyWithoutUsersInput>
  }

  export type report_schedulesScalarWhereInput = {
    AND?: report_schedulesScalarWhereInput | report_schedulesScalarWhereInput[]
    OR?: report_schedulesScalarWhereInput[]
    NOT?: report_schedulesScalarWhereInput | report_schedulesScalarWhereInput[]
    id?: StringFilter<"report_schedules"> | string
    adminId?: StringFilter<"report_schedules"> | string
    reportType?: StringFilter<"report_schedules"> | string
    frequency?: StringFilter<"report_schedules"> | string
    email?: StringFilter<"report_schedules"> | string
    isActive?: BoolFilter<"report_schedules"> | boolean
    createdAt?: DateTimeFilter<"report_schedules"> | Date | string
    updatedAt?: DateTimeFilter<"report_schedules"> | Date | string
  }

  export type reviewsUpsertWithWhereUniqueWithoutUsers_reviews_revieweeIdTousersInput = {
    where: reviewsWhereUniqueInput
    update: XOR<reviewsUpdateWithoutUsers_reviews_revieweeIdTousersInput, reviewsUncheckedUpdateWithoutUsers_reviews_revieweeIdTousersInput>
    create: XOR<reviewsCreateWithoutUsers_reviews_revieweeIdTousersInput, reviewsUncheckedCreateWithoutUsers_reviews_revieweeIdTousersInput>
  }

  export type reviewsUpdateWithWhereUniqueWithoutUsers_reviews_revieweeIdTousersInput = {
    where: reviewsWhereUniqueInput
    data: XOR<reviewsUpdateWithoutUsers_reviews_revieweeIdTousersInput, reviewsUncheckedUpdateWithoutUsers_reviews_revieweeIdTousersInput>
  }

  export type reviewsUpdateManyWithWhereWithoutUsers_reviews_revieweeIdTousersInput = {
    where: reviewsScalarWhereInput
    data: XOR<reviewsUpdateManyMutationInput, reviewsUncheckedUpdateManyWithoutUsers_reviews_revieweeIdTousersInput>
  }

  export type reviewsUpsertWithWhereUniqueWithoutUsers_reviews_reviewerIdTousersInput = {
    where: reviewsWhereUniqueInput
    update: XOR<reviewsUpdateWithoutUsers_reviews_reviewerIdTousersInput, reviewsUncheckedUpdateWithoutUsers_reviews_reviewerIdTousersInput>
    create: XOR<reviewsCreateWithoutUsers_reviews_reviewerIdTousersInput, reviewsUncheckedCreateWithoutUsers_reviews_reviewerIdTousersInput>
  }

  export type reviewsUpdateWithWhereUniqueWithoutUsers_reviews_reviewerIdTousersInput = {
    where: reviewsWhereUniqueInput
    data: XOR<reviewsUpdateWithoutUsers_reviews_reviewerIdTousersInput, reviewsUncheckedUpdateWithoutUsers_reviews_reviewerIdTousersInput>
  }

  export type reviewsUpdateManyWithWhereWithoutUsers_reviews_reviewerIdTousersInput = {
    where: reviewsScalarWhereInput
    data: XOR<reviewsUpdateManyMutationInput, reviewsUncheckedUpdateManyWithoutUsers_reviews_reviewerIdTousersInput>
  }

  export type ticketsUpsertWithWhereUniqueWithoutUsersInput = {
    where: ticketsWhereUniqueInput
    update: XOR<ticketsUpdateWithoutUsersInput, ticketsUncheckedUpdateWithoutUsersInput>
    create: XOR<ticketsCreateWithoutUsersInput, ticketsUncheckedCreateWithoutUsersInput>
  }

  export type ticketsUpdateWithWhereUniqueWithoutUsersInput = {
    where: ticketsWhereUniqueInput
    data: XOR<ticketsUpdateWithoutUsersInput, ticketsUncheckedUpdateWithoutUsersInput>
  }

  export type ticketsUpdateManyWithWhereWithoutUsersInput = {
    where: ticketsScalarWhereInput
    data: XOR<ticketsUpdateManyMutationInput, ticketsUncheckedUpdateManyWithoutUsersInput>
  }

  export type ticketsScalarWhereInput = {
    AND?: ticketsScalarWhereInput | ticketsScalarWhereInput[]
    OR?: ticketsScalarWhereInput[]
    NOT?: ticketsScalarWhereInput | ticketsScalarWhereInput[]
    id?: StringFilter<"tickets"> | string
    userId?: StringFilter<"tickets"> | string
    subject?: StringFilter<"tickets"> | string
    description?: StringFilter<"tickets"> | string
    status?: StringFilter<"tickets"> | string
    priority?: StringFilter<"tickets"> | string
    createdAt?: DateTimeFilter<"tickets"> | Date | string
    updatedAt?: DateTimeFilter<"tickets"> | Date | string
  }

  export type user_payment_methodsUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_payment_methodsWhereUniqueInput
    update: XOR<user_payment_methodsUpdateWithoutUsersInput, user_payment_methodsUncheckedUpdateWithoutUsersInput>
    create: XOR<user_payment_methodsCreateWithoutUsersInput, user_payment_methodsUncheckedCreateWithoutUsersInput>
  }

  export type user_payment_methodsUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_payment_methodsWhereUniqueInput
    data: XOR<user_payment_methodsUpdateWithoutUsersInput, user_payment_methodsUncheckedUpdateWithoutUsersInput>
  }

  export type user_payment_methodsUpdateManyWithWhereWithoutUsersInput = {
    where: user_payment_methodsScalarWhereInput
    data: XOR<user_payment_methodsUpdateManyMutationInput, user_payment_methodsUncheckedUpdateManyWithoutUsersInput>
  }

  export type user_payment_methodsScalarWhereInput = {
    AND?: user_payment_methodsScalarWhereInput | user_payment_methodsScalarWhereInput[]
    OR?: user_payment_methodsScalarWhereInput[]
    NOT?: user_payment_methodsScalarWhereInput | user_payment_methodsScalarWhereInput[]
    id?: StringFilter<"user_payment_methods"> | string
    userId?: StringFilter<"user_payment_methods"> | string
    type?: StringFilter<"user_payment_methods"> | string
    provider?: StringNullableFilter<"user_payment_methods"> | string | null
    upiId?: StringNullableFilter<"user_payment_methods"> | string | null
    cardNumber?: StringNullableFilter<"user_payment_methods"> | string | null
    cardName?: StringNullableFilter<"user_payment_methods"> | string | null
    expiryMonth?: StringNullableFilter<"user_payment_methods"> | string | null
    expiryYear?: StringNullableFilter<"user_payment_methods"> | string | null
    last4?: StringNullableFilter<"user_payment_methods"> | string | null
    isDefault?: BoolFilter<"user_payment_methods"> | boolean
    isActive?: BoolFilter<"user_payment_methods"> | boolean
    createdAt?: DateTimeFilter<"user_payment_methods"> | Date | string
    updatedAt?: DateTimeFilter<"user_payment_methods"> | Date | string
  }

  export type user_verificationsUpsertWithoutUsersInput = {
    update: XOR<user_verificationsUpdateWithoutUsersInput, user_verificationsUncheckedUpdateWithoutUsersInput>
    create: XOR<user_verificationsCreateWithoutUsersInput, user_verificationsUncheckedCreateWithoutUsersInput>
    where?: user_verificationsWhereInput
  }

  export type user_verificationsUpdateToOneWithWhereWithoutUsersInput = {
    where?: user_verificationsWhereInput
    data: XOR<user_verificationsUpdateWithoutUsersInput, user_verificationsUncheckedUpdateWithoutUsersInput>
  }

  export type user_verificationsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    idType?: StringFieldUpdateOperationsInput | string
    idNumber?: StringFieldUpdateOperationsInput | string
    idFrontImage?: StringFieldUpdateOperationsInput | string
    idBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    addressProofType?: StringFieldUpdateOperationsInput | string
    addressProofNumber?: StringFieldUpdateOperationsInput | string
    addressProofImage?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_verificationsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    idType?: StringFieldUpdateOperationsInput | string
    idNumber?: StringFieldUpdateOperationsInput | string
    idFrontImage?: StringFieldUpdateOperationsInput | string
    idBackImage?: NullableStringFieldUpdateOperationsInput | string | null
    addressProofType?: StringFieldUpdateOperationsInput | string
    addressProofNumber?: StringFieldUpdateOperationsInput | string
    addressProofImage?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type walletsUpsertWithoutUsersInput = {
    update: XOR<walletsUpdateWithoutUsersInput, walletsUncheckedUpdateWithoutUsersInput>
    create: XOR<walletsCreateWithoutUsersInput, walletsUncheckedCreateWithoutUsersInput>
    where?: walletsWhereInput
  }

  export type walletsUpdateToOneWithWhereWithoutUsersInput = {
    where?: walletsWhereInput
    data: XOR<walletsUpdateWithoutUsersInput, walletsUncheckedUpdateWithoutUsersInput>
  }

  export type walletsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: transactionsUpdateManyWithoutWalletsNestedInput
  }

  export type walletsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: transactionsUncheckedUpdateManyWithoutWalletsNestedInput
  }

  export type ordersCreateWithoutVirtual_assignmentsInput = {
    id: string
    status?: $Enums.OrderStatus
    totalAmount: number
    commission?: number
    serviceDate: Date | string
    address: string
    notes?: string | null
    cancelledBy?: string | null
    cancelReason?: string | null
    cancelledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    call_sessions?: call_sessionsCreateNestedManyWithoutOrdersInput
    users_orders_customerIdTousers: usersCreateNestedOneWithoutOrders_orders_customerIdTousersInput
    users_orders_providerIdTousers: usersCreateNestedOneWithoutOrders_orders_providerIdTousersInput
    services: servicesCreateNestedOneWithoutOrdersInput
    reviews?: reviewsCreateNestedOneWithoutOrdersInput
  }

  export type ordersUncheckedCreateWithoutVirtual_assignmentsInput = {
    id: string
    customerId: string
    providerId: string
    serviceId: string
    status?: $Enums.OrderStatus
    totalAmount: number
    commission?: number
    serviceDate: Date | string
    address: string
    notes?: string | null
    cancelledBy?: string | null
    cancelReason?: string | null
    cancelledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    call_sessions?: call_sessionsUncheckedCreateNestedManyWithoutOrdersInput
    reviews?: reviewsUncheckedCreateNestedOneWithoutOrdersInput
  }

  export type ordersCreateOrConnectWithoutVirtual_assignmentsInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutVirtual_assignmentsInput, ordersUncheckedCreateWithoutVirtual_assignmentsInput>
  }

  export type virtual_numbersCreateWithoutVirtual_assignmentsInput = {
    id: string
    phoneNumber: string
    isAssigned?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type virtual_numbersUncheckedCreateWithoutVirtual_assignmentsInput = {
    id: string
    phoneNumber: string
    isAssigned?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type virtual_numbersCreateOrConnectWithoutVirtual_assignmentsInput = {
    where: virtual_numbersWhereUniqueInput
    create: XOR<virtual_numbersCreateWithoutVirtual_assignmentsInput, virtual_numbersUncheckedCreateWithoutVirtual_assignmentsInput>
  }

  export type ordersUpsertWithoutVirtual_assignmentsInput = {
    update: XOR<ordersUpdateWithoutVirtual_assignmentsInput, ordersUncheckedUpdateWithoutVirtual_assignmentsInput>
    create: XOR<ordersCreateWithoutVirtual_assignmentsInput, ordersUncheckedCreateWithoutVirtual_assignmentsInput>
    where?: ordersWhereInput
  }

  export type ordersUpdateToOneWithWhereWithoutVirtual_assignmentsInput = {
    where?: ordersWhereInput
    data: XOR<ordersUpdateWithoutVirtual_assignmentsInput, ordersUncheckedUpdateWithoutVirtual_assignmentsInput>
  }

  export type ordersUpdateWithoutVirtual_assignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    call_sessions?: call_sessionsUpdateManyWithoutOrdersNestedInput
    users_orders_customerIdTousers?: usersUpdateOneRequiredWithoutOrders_orders_customerIdTousersNestedInput
    users_orders_providerIdTousers?: usersUpdateOneRequiredWithoutOrders_orders_providerIdTousersNestedInput
    services?: servicesUpdateOneRequiredWithoutOrdersNestedInput
    reviews?: reviewsUpdateOneWithoutOrdersNestedInput
  }

  export type ordersUncheckedUpdateWithoutVirtual_assignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    call_sessions?: call_sessionsUncheckedUpdateManyWithoutOrdersNestedInput
    reviews?: reviewsUncheckedUpdateOneWithoutOrdersNestedInput
  }

  export type virtual_numbersUpsertWithoutVirtual_assignmentsInput = {
    update: XOR<virtual_numbersUpdateWithoutVirtual_assignmentsInput, virtual_numbersUncheckedUpdateWithoutVirtual_assignmentsInput>
    create: XOR<virtual_numbersCreateWithoutVirtual_assignmentsInput, virtual_numbersUncheckedCreateWithoutVirtual_assignmentsInput>
    where?: virtual_numbersWhereInput
  }

  export type virtual_numbersUpdateToOneWithWhereWithoutVirtual_assignmentsInput = {
    where?: virtual_numbersWhereInput
    data: XOR<virtual_numbersUpdateWithoutVirtual_assignmentsInput, virtual_numbersUncheckedUpdateWithoutVirtual_assignmentsInput>
  }

  export type virtual_numbersUpdateWithoutVirtual_assignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAssigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type virtual_numbersUncheckedUpdateWithoutVirtual_assignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    isAssigned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type virtual_assignmentsCreateWithoutVirtual_numbersInput = {
    id: string
    status?: string
    assignedAt?: Date | string
    releasedAt?: Date | string | null
    orders: ordersCreateNestedOneWithoutVirtual_assignmentsInput
  }

  export type virtual_assignmentsUncheckedCreateWithoutVirtual_numbersInput = {
    id: string
    orderId: string
    status?: string
    assignedAt?: Date | string
    releasedAt?: Date | string | null
  }

  export type virtual_assignmentsCreateOrConnectWithoutVirtual_numbersInput = {
    where: virtual_assignmentsWhereUniqueInput
    create: XOR<virtual_assignmentsCreateWithoutVirtual_numbersInput, virtual_assignmentsUncheckedCreateWithoutVirtual_numbersInput>
  }

  export type virtual_assignmentsCreateManyVirtual_numbersInputEnvelope = {
    data: virtual_assignmentsCreateManyVirtual_numbersInput | virtual_assignmentsCreateManyVirtual_numbersInput[]
    skipDuplicates?: boolean
  }

  export type virtual_assignmentsUpsertWithWhereUniqueWithoutVirtual_numbersInput = {
    where: virtual_assignmentsWhereUniqueInput
    update: XOR<virtual_assignmentsUpdateWithoutVirtual_numbersInput, virtual_assignmentsUncheckedUpdateWithoutVirtual_numbersInput>
    create: XOR<virtual_assignmentsCreateWithoutVirtual_numbersInput, virtual_assignmentsUncheckedCreateWithoutVirtual_numbersInput>
  }

  export type virtual_assignmentsUpdateWithWhereUniqueWithoutVirtual_numbersInput = {
    where: virtual_assignmentsWhereUniqueInput
    data: XOR<virtual_assignmentsUpdateWithoutVirtual_numbersInput, virtual_assignmentsUncheckedUpdateWithoutVirtual_numbersInput>
  }

  export type virtual_assignmentsUpdateManyWithWhereWithoutVirtual_numbersInput = {
    where: virtual_assignmentsScalarWhereInput
    data: XOR<virtual_assignmentsUpdateManyMutationInput, virtual_assignmentsUncheckedUpdateManyWithoutVirtual_numbersInput>
  }

  export type virtual_assignmentsScalarWhereInput = {
    AND?: virtual_assignmentsScalarWhereInput | virtual_assignmentsScalarWhereInput[]
    OR?: virtual_assignmentsScalarWhereInput[]
    NOT?: virtual_assignmentsScalarWhereInput | virtual_assignmentsScalarWhereInput[]
    id?: StringFilter<"virtual_assignments"> | string
    orderId?: StringFilter<"virtual_assignments"> | string
    virtualNumberId?: StringFilter<"virtual_assignments"> | string
    status?: StringFilter<"virtual_assignments"> | string
    assignedAt?: DateTimeFilter<"virtual_assignments"> | Date | string
    releasedAt?: DateTimeNullableFilter<"virtual_assignments"> | Date | string | null
  }

  export type transactionsCreateWithoutWalletsInput = {
    id: string
    amount: number
    type: $Enums.TransactionType
    description: string
    paymentMethod?: $Enums.PaymentMethod | null
    orderId?: string | null
    createdAt?: Date | string
  }

  export type transactionsUncheckedCreateWithoutWalletsInput = {
    id: string
    amount: number
    type: $Enums.TransactionType
    description: string
    paymentMethod?: $Enums.PaymentMethod | null
    orderId?: string | null
    createdAt?: Date | string
  }

  export type transactionsCreateOrConnectWithoutWalletsInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutWalletsInput, transactionsUncheckedCreateWithoutWalletsInput>
  }

  export type transactionsCreateManyWalletsInputEnvelope = {
    data: transactionsCreateManyWalletsInput | transactionsCreateManyWalletsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutWalletsInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersCreateNestedManyWithoutUsersInput
    profiles?: profilesCreateNestedOneWithoutUsersInput
    providers?: providersCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutWalletsInput = {
    id: string
    email?: string | null
    phone?: string | null
    userType: $Enums.UserType
    isVerified?: boolean
    isActive?: boolean
    isBlocked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    cancellationsCount?: number
    isSuspect?: boolean
    admin_actions?: admin_actionsUncheckedCreateNestedManyWithoutUsersInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_customerIdTousersInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedCreateNestedManyWithoutUsers_call_sessions_providerIdTousersInput
    messages_messages_receiverIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_receiverIdTousersInput
    messages_messages_senderIdTousers?: messagesUncheckedCreateNestedManyWithoutUsers_messages_senderIdTousersInput
    notification_preferences?: notification_preferencesUncheckedCreateNestedOneWithoutUsersInput
    notification_tokens?: notification_tokensUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    orders_orders_customerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_customerIdTousersInput
    orders_orders_providerIdTousers?: ordersUncheckedCreateNestedManyWithoutUsers_orders_providerIdTousersInput
    otps?: otpsUncheckedCreateNestedManyWithoutUsersInput
    payment_orders?: payment_ordersUncheckedCreateNestedManyWithoutUsersInput
    profiles?: profilesUncheckedCreateNestedOneWithoutUsersInput
    providers?: providersUncheckedCreateNestedOneWithoutUsersInput
    report_schedules?: report_schedulesUncheckedCreateNestedManyWithoutUsersInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_revieweeIdTousersInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedCreateNestedManyWithoutUsers_reviews_reviewerIdTousersInput
    tickets?: ticketsUncheckedCreateNestedManyWithoutUsersInput
    user_payment_methods?: user_payment_methodsUncheckedCreateNestedManyWithoutUsersInput
    user_verifications?: user_verificationsUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutWalletsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutWalletsInput, usersUncheckedCreateWithoutWalletsInput>
  }

  export type transactionsUpsertWithWhereUniqueWithoutWalletsInput = {
    where: transactionsWhereUniqueInput
    update: XOR<transactionsUpdateWithoutWalletsInput, transactionsUncheckedUpdateWithoutWalletsInput>
    create: XOR<transactionsCreateWithoutWalletsInput, transactionsUncheckedCreateWithoutWalletsInput>
  }

  export type transactionsUpdateWithWhereUniqueWithoutWalletsInput = {
    where: transactionsWhereUniqueInput
    data: XOR<transactionsUpdateWithoutWalletsInput, transactionsUncheckedUpdateWithoutWalletsInput>
  }

  export type transactionsUpdateManyWithWhereWithoutWalletsInput = {
    where: transactionsScalarWhereInput
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyWithoutWalletsInput>
  }

  export type transactionsScalarWhereInput = {
    AND?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
    OR?: transactionsScalarWhereInput[]
    NOT?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
    id?: StringFilter<"transactions"> | string
    walletId?: StringFilter<"transactions"> | string
    amount?: FloatFilter<"transactions"> | number
    type?: EnumTransactionTypeFilter<"transactions"> | $Enums.TransactionType
    description?: StringFilter<"transactions"> | string
    paymentMethod?: EnumPaymentMethodNullableFilter<"transactions"> | $Enums.PaymentMethod | null
    orderId?: StringNullableFilter<"transactions"> | string | null
    createdAt?: DateTimeFilter<"transactions"> | Date | string
  }

  export type usersUpsertWithoutWalletsInput = {
    update: XOR<usersUpdateWithoutWalletsInput, usersUncheckedUpdateWithoutWalletsInput>
    create: XOR<usersCreateWithoutWalletsInput, usersUncheckedCreateWithoutWalletsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutWalletsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutWalletsInput, usersUncheckedUpdateWithoutWalletsInput>
  }

  export type usersUpdateWithoutWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUpdateManyWithoutUsersNestedInput
    profiles?: profilesUpdateOneWithoutUsersNestedInput
    providers?: providersUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationsCount?: IntFieldUpdateOperationsInput | number
    isSuspect?: BoolFieldUpdateOperationsInput | boolean
    admin_actions?: admin_actionsUncheckedUpdateManyWithoutUsersNestedInput
    call_sessions_call_sessions_customerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_customerIdTousersNestedInput
    call_sessions_call_sessions_providerIdTousers?: call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_providerIdTousersNestedInput
    messages_messages_receiverIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_receiverIdTousersNestedInput
    messages_messages_senderIdTousers?: messagesUncheckedUpdateManyWithoutUsers_messages_senderIdTousersNestedInput
    notification_preferences?: notification_preferencesUncheckedUpdateOneWithoutUsersNestedInput
    notification_tokens?: notification_tokensUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    orders_orders_customerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_customerIdTousersNestedInput
    orders_orders_providerIdTousers?: ordersUncheckedUpdateManyWithoutUsers_orders_providerIdTousersNestedInput
    otps?: otpsUncheckedUpdateManyWithoutUsersNestedInput
    payment_orders?: payment_ordersUncheckedUpdateManyWithoutUsersNestedInput
    profiles?: profilesUncheckedUpdateOneWithoutUsersNestedInput
    providers?: providersUncheckedUpdateOneWithoutUsersNestedInput
    report_schedules?: report_schedulesUncheckedUpdateManyWithoutUsersNestedInput
    reviews_reviews_revieweeIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_revieweeIdTousersNestedInput
    reviews_reviews_reviewerIdTousers?: reviewsUncheckedUpdateManyWithoutUsers_reviews_reviewerIdTousersNestedInput
    tickets?: ticketsUncheckedUpdateManyWithoutUsersNestedInput
    user_payment_methods?: user_payment_methodsUncheckedUpdateManyWithoutUsersNestedInput
    user_verifications?: user_verificationsUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type provider_locationsCreateWithoutZonesInput = {
    id: string
    lat: number
    lng: number
    address?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    providers: providersCreateNestedOneWithoutProvider_locationsInput
  }

  export type provider_locationsUncheckedCreateWithoutZonesInput = {
    id: string
    providerId: string
    lat: number
    lng: number
    address?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type provider_locationsCreateOrConnectWithoutZonesInput = {
    where: provider_locationsWhereUniqueInput
    create: XOR<provider_locationsCreateWithoutZonesInput, provider_locationsUncheckedCreateWithoutZonesInput>
  }

  export type provider_locationsCreateManyZonesInputEnvelope = {
    data: provider_locationsCreateManyZonesInput | provider_locationsCreateManyZonesInput[]
    skipDuplicates?: boolean
  }

  export type provider_locationsUpsertWithWhereUniqueWithoutZonesInput = {
    where: provider_locationsWhereUniqueInput
    update: XOR<provider_locationsUpdateWithoutZonesInput, provider_locationsUncheckedUpdateWithoutZonesInput>
    create: XOR<provider_locationsCreateWithoutZonesInput, provider_locationsUncheckedCreateWithoutZonesInput>
  }

  export type provider_locationsUpdateWithWhereUniqueWithoutZonesInput = {
    where: provider_locationsWhereUniqueInput
    data: XOR<provider_locationsUpdateWithoutZonesInput, provider_locationsUncheckedUpdateWithoutZonesInput>
  }

  export type provider_locationsUpdateManyWithWhereWithoutZonesInput = {
    where: provider_locationsScalarWhereInput
    data: XOR<provider_locationsUpdateManyMutationInput, provider_locationsUncheckedUpdateManyWithoutZonesInput>
  }

  export type call_logsCreateManyCall_sessionsInput = {
    id: string
    status: string
    duration?: number | null
    timestamp?: Date | string
  }

  export type call_logsUpdateWithoutCall_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type call_logsUncheckedUpdateWithoutCall_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type call_logsUncheckedUpdateManyWithoutCall_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type call_sessionsCreateManyOrdersInput = {
    id: string
    customerId: string
    providerId: string
    twilioCallSid?: string | null
    customerPhone: string
    providerPhone: string
    status?: string
    duration?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type call_sessionsUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    call_logs?: call_logsUpdateManyWithoutCall_sessionsNestedInput
    users_call_sessions_customerIdTousers?: usersUpdateOneRequiredWithoutCall_sessions_call_sessions_customerIdTousersNestedInput
    users_call_sessions_providerIdTousers?: usersUpdateOneRequiredWithoutCall_sessions_call_sessions_providerIdTousersNestedInput
  }

  export type call_sessionsUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    call_logs?: call_logsUncheckedUpdateManyWithoutCall_sessionsNestedInput
  }

  export type call_sessionsUncheckedUpdateManyWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type provider_locationsCreateManyProvidersInput = {
    id: string
    lat: number
    lng: number
    address?: string | null
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type reviewsCreateManyProvidersInput = {
    id: string
    orderId: string
    reviewerId: string
    revieweeId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type servicesCreateManyProvidersInput = {
    id: string
    name: string
    description: string
    category: string
    price: number
    basePrice?: number | null
    offerPercent?: number | null
    estimatedTime?: number | null
    warrantyMonths?: number | null
    duration: number
    status?: string
    isActive?: boolean
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type provider_locationsUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: zonesUpdateOneWithoutProvider_locationsNestedInput
  }

  export type provider_locationsUncheckedUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type provider_locationsUncheckedUpdateManyWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewsUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: ordersUpdateOneRequiredWithoutReviewsNestedInput
    users_reviews_revieweeIdTousers?: usersUpdateOneRequiredWithoutReviews_reviews_revieweeIdTousersNestedInput
    users_reviews_reviewerIdTousers?: usersUpdateOneRequiredWithoutReviews_reviews_reviewerIdTousersNestedInput
  }

  export type reviewsUncheckedUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewsUncheckedUpdateManyWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type servicesUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    offerPercent?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedTime?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyMonths?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: ordersUpdateManyWithoutServicesNestedInput
  }

  export type servicesUncheckedUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    offerPercent?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedTime?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyMonths?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: ordersUncheckedUpdateManyWithoutServicesNestedInput
  }

  export type servicesUncheckedUpdateManyWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    basePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    offerPercent?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedTime?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyMonths?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ordersCreateManyServicesInput = {
    id: string
    customerId: string
    providerId: string
    status?: $Enums.OrderStatus
    totalAmount: number
    commission?: number
    serviceDate: Date | string
    address: string
    notes?: string | null
    cancelledBy?: string | null
    cancelReason?: string | null
    cancelledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ordersUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    call_sessions?: call_sessionsUpdateManyWithoutOrdersNestedInput
    users_orders_customerIdTousers?: usersUpdateOneRequiredWithoutOrders_orders_customerIdTousersNestedInput
    users_orders_providerIdTousers?: usersUpdateOneRequiredWithoutOrders_orders_providerIdTousersNestedInput
    reviews?: reviewsUpdateOneWithoutOrdersNestedInput
    virtual_assignments?: virtual_assignmentsUpdateOneWithoutOrdersNestedInput
  }

  export type ordersUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    call_sessions?: call_sessionsUncheckedUpdateManyWithoutOrdersNestedInput
    reviews?: reviewsUncheckedUpdateOneWithoutOrdersNestedInput
    virtual_assignments?: virtual_assignmentsUncheckedUpdateOneWithoutOrdersNestedInput
  }

  export type ordersUncheckedUpdateManyWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admin_actionsCreateManyUsersInput = {
    id: string
    action: string
    targetId: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type call_sessionsCreateManyUsers_call_sessions_customerIdTousersInput = {
    id: string
    providerId: string
    orderId?: string | null
    twilioCallSid?: string | null
    customerPhone: string
    providerPhone: string
    status?: string
    duration?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type call_sessionsCreateManyUsers_call_sessions_providerIdTousersInput = {
    id: string
    customerId: string
    orderId?: string | null
    twilioCallSid?: string | null
    customerPhone: string
    providerPhone: string
    status?: string
    duration?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type messagesCreateManyUsers_messages_receiverIdTousersInput = {
    id: string
    senderId: string
    content: string
    orderId?: string | null
    createdAt?: Date | string
  }

  export type messagesCreateManyUsers_messages_senderIdTousersInput = {
    id: string
    receiverId: string
    content: string
    orderId?: string | null
    createdAt?: Date | string
  }

  export type notification_tokensCreateManyUsersInput = {
    id: string
    token: string
    platform?: string | null
    createdAt?: Date | string
  }

  export type notificationsCreateManyUsersInput = {
    id: string
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    type: string
    status?: string
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ordersCreateManyUsers_orders_customerIdTousersInput = {
    id: string
    providerId: string
    serviceId: string
    status?: $Enums.OrderStatus
    totalAmount: number
    commission?: number
    serviceDate: Date | string
    address: string
    notes?: string | null
    cancelledBy?: string | null
    cancelReason?: string | null
    cancelledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ordersCreateManyUsers_orders_providerIdTousersInput = {
    id: string
    customerId: string
    serviceId: string
    status?: $Enums.OrderStatus
    totalAmount: number
    commission?: number
    serviceDate: Date | string
    address: string
    notes?: string | null
    cancelledBy?: string | null
    cancelReason?: string | null
    cancelledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type otpsCreateManyUsersInput = {
    id: string
    code: string
    type: string
    isUsed?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type payment_ordersCreateManyUsersInput = {
    id: string
    orderId: string
    paymentId?: string | null
    amount: number
    currency?: string
    paymentMethod: string
    status?: string
    type: string
    signature?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type report_schedulesCreateManyUsersInput = {
    id: string
    reportType: string
    frequency: string
    email: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type reviewsCreateManyUsers_reviews_revieweeIdTousersInput = {
    id: string
    orderId: string
    reviewerId: string
    providerId?: string | null
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type reviewsCreateManyUsers_reviews_reviewerIdTousersInput = {
    id: string
    orderId: string
    revieweeId: string
    providerId?: string | null
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type ticketsCreateManyUsersInput = {
    id: string
    subject: string
    description: string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type user_payment_methodsCreateManyUsersInput = {
    id: string
    type: string
    provider?: string | null
    upiId?: string | null
    cardNumber?: string | null
    cardName?: string | null
    expiryMonth?: string | null
    expiryYear?: string | null
    last4?: string | null
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type admin_actionsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admin_actionsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admin_actionsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type call_sessionsUpdateWithoutUsers_call_sessions_customerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    call_logs?: call_logsUpdateManyWithoutCall_sessionsNestedInput
    orders?: ordersUpdateOneWithoutCall_sessionsNestedInput
    users_call_sessions_providerIdTousers?: usersUpdateOneRequiredWithoutCall_sessions_call_sessions_providerIdTousersNestedInput
  }

  export type call_sessionsUncheckedUpdateWithoutUsers_call_sessions_customerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    call_logs?: call_logsUncheckedUpdateManyWithoutCall_sessionsNestedInput
  }

  export type call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_customerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type call_sessionsUpdateWithoutUsers_call_sessions_providerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    call_logs?: call_logsUpdateManyWithoutCall_sessionsNestedInput
    users_call_sessions_customerIdTousers?: usersUpdateOneRequiredWithoutCall_sessions_call_sessions_customerIdTousersNestedInput
    orders?: ordersUpdateOneWithoutCall_sessionsNestedInput
  }

  export type call_sessionsUncheckedUpdateWithoutUsers_call_sessions_providerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    call_logs?: call_logsUncheckedUpdateManyWithoutCall_sessionsNestedInput
  }

  export type call_sessionsUncheckedUpdateManyWithoutUsers_call_sessions_providerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    twilioCallSid?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type messagesUpdateWithoutUsers_messages_receiverIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_messages_senderIdTousers?: usersUpdateOneRequiredWithoutMessages_messages_senderIdTousersNestedInput
  }

  export type messagesUncheckedUpdateWithoutUsers_messages_receiverIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type messagesUncheckedUpdateManyWithoutUsers_messages_receiverIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type messagesUpdateWithoutUsers_messages_senderIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_messages_receiverIdTousers?: usersUpdateOneRequiredWithoutMessages_messages_receiverIdTousersNestedInput
  }

  export type messagesUncheckedUpdateWithoutUsers_messages_senderIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type messagesUncheckedUpdateManyWithoutUsers_messages_senderIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notification_tokensUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notification_tokensUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notification_tokensUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ordersUpdateWithoutUsers_orders_customerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    call_sessions?: call_sessionsUpdateManyWithoutOrdersNestedInput
    users_orders_providerIdTousers?: usersUpdateOneRequiredWithoutOrders_orders_providerIdTousersNestedInput
    services?: servicesUpdateOneRequiredWithoutOrdersNestedInput
    reviews?: reviewsUpdateOneWithoutOrdersNestedInput
    virtual_assignments?: virtual_assignmentsUpdateOneWithoutOrdersNestedInput
  }

  export type ordersUncheckedUpdateWithoutUsers_orders_customerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    call_sessions?: call_sessionsUncheckedUpdateManyWithoutOrdersNestedInput
    reviews?: reviewsUncheckedUpdateOneWithoutOrdersNestedInput
    virtual_assignments?: virtual_assignmentsUncheckedUpdateOneWithoutOrdersNestedInput
  }

  export type ordersUncheckedUpdateManyWithoutUsers_orders_customerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ordersUpdateWithoutUsers_orders_providerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    call_sessions?: call_sessionsUpdateManyWithoutOrdersNestedInput
    users_orders_customerIdTousers?: usersUpdateOneRequiredWithoutOrders_orders_customerIdTousersNestedInput
    services?: servicesUpdateOneRequiredWithoutOrdersNestedInput
    reviews?: reviewsUpdateOneWithoutOrdersNestedInput
    virtual_assignments?: virtual_assignmentsUpdateOneWithoutOrdersNestedInput
  }

  export type ordersUncheckedUpdateWithoutUsers_orders_providerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    call_sessions?: call_sessionsUncheckedUpdateManyWithoutOrdersNestedInput
    reviews?: reviewsUncheckedUpdateOneWithoutOrdersNestedInput
    virtual_assignments?: virtual_assignmentsUncheckedUpdateOneWithoutOrdersNestedInput
  }

  export type ordersUncheckedUpdateManyWithoutUsers_orders_providerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    serviceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type otpsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type otpsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type otpsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_ordersUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_ordersUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_ordersUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type report_schedulesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type report_schedulesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type report_schedulesUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewsUpdateWithoutUsers_reviews_revieweeIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: ordersUpdateOneRequiredWithoutReviewsNestedInput
    providers?: providersUpdateOneWithoutReviewsNestedInput
    users_reviews_reviewerIdTousers?: usersUpdateOneRequiredWithoutReviews_reviews_reviewerIdTousersNestedInput
  }

  export type reviewsUncheckedUpdateWithoutUsers_reviews_revieweeIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewsUncheckedUpdateManyWithoutUsers_reviews_revieweeIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewsUpdateWithoutUsers_reviews_reviewerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: ordersUpdateOneRequiredWithoutReviewsNestedInput
    providers?: providersUpdateOneWithoutReviewsNestedInput
    users_reviews_revieweeIdTousers?: usersUpdateOneRequiredWithoutReviews_reviews_revieweeIdTousersNestedInput
  }

  export type reviewsUncheckedUpdateWithoutUsers_reviews_reviewerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewsUncheckedUpdateManyWithoutUsers_reviews_reviewerIdTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ticketsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ticketsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ticketsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_payment_methodsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardName?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableStringFieldUpdateOperationsInput | string | null
    expiryYear?: NullableStringFieldUpdateOperationsInput | string | null
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_payment_methodsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardName?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableStringFieldUpdateOperationsInput | string | null
    expiryYear?: NullableStringFieldUpdateOperationsInput | string | null
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_payment_methodsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    upiId?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardName?: NullableStringFieldUpdateOperationsInput | string | null
    expiryMonth?: NullableStringFieldUpdateOperationsInput | string | null
    expiryYear?: NullableStringFieldUpdateOperationsInput | string | null
    last4?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type virtual_assignmentsCreateManyVirtual_numbersInput = {
    id: string
    orderId: string
    status?: string
    assignedAt?: Date | string
    releasedAt?: Date | string | null
  }

  export type virtual_assignmentsUpdateWithoutVirtual_numbersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: ordersUpdateOneRequiredWithoutVirtual_assignmentsNestedInput
  }

  export type virtual_assignmentsUncheckedUpdateWithoutVirtual_numbersInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type virtual_assignmentsUncheckedUpdateManyWithoutVirtual_numbersInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transactionsCreateManyWalletsInput = {
    id: string
    amount: number
    type: $Enums.TransactionType
    description: string
    paymentMethod?: $Enums.PaymentMethod | null
    orderId?: string | null
    createdAt?: Date | string
  }

  export type transactionsUpdateWithoutWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsUncheckedUpdateWithoutWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsUncheckedUpdateManyWithoutWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type provider_locationsCreateManyZonesInput = {
    id: string
    providerId: string
    lat: number
    lng: number
    address?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type provider_locationsUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providers?: providersUpdateOneRequiredWithoutProvider_locationsNestedInput
  }

  export type provider_locationsUncheckedUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type provider_locationsUncheckedUpdateManyWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}